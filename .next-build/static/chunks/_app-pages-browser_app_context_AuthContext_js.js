"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_app_context_AuthContext_js"],{

/***/ "(app-pages-browser)/./app/context/AuthContext.js":
/*!************************************!*\
  !*** ./app/context/AuthContext.js ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthProvider: () => (/* binding */ AuthProvider),\n/* harmony export */   useAuth: () => (/* binding */ useAuth)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _lib_firebase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/firebase */ \"(app-pages-browser)/./app/lib/firebase.js\");\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! firebase/firestore */ \"(app-pages-browser)/./node_modules/firebase/firestore/dist/esm/index.esm.js\");\n/* harmony import */ var _lib_dataAccess__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../lib/dataAccess */ \"(app-pages-browser)/./app/lib/dataAccess.js\");\n/* harmony import */ var _utils_sessionRecording__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/sessionRecording */ \"(app-pages-browser)/./app/utils/sessionRecording.js\");\n/* __next_internal_client_entry_do_not_use__ useAuth,AuthProvider auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\n\n\n\n// ระยะเวลาที่ session token หมดอายุ (20 นาที)\nconst SESSION_EXPIRY_TIME = 20 * 60 * 1000; // 20 นาที ในมิลลิวินาที\n// สร้าง session token แบบสุ่ม\nconst generateSessionToken = ()=>{\n    return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15) + Date.now().toString(36);\n};\n// Initialize with default values including the function signatures\nconst AuthContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({\n    user: null,\n    loading: true,\n    isAuthenticated: false,\n    authError: null,\n    login: async (username, password)=>{},\n    logout: ()=>{},\n    clearAuthError: ()=>{}\n});\nconst useAuth = ()=>{\n    _s();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(AuthContext);\n};\n_s(useAuth, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nfunction AuthProvider(param) {\n    let { children } = param;\n    _s1();\n    const [user, setUser] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [authError, setAuthError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // Add function to clear auth errors\n    const clearAuthError = ()=>{\n        setAuthError(null);\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"AuthProvider.useEffect\": ()=>{\n            // Add timeout to prevent indefinite loading\n            const loadingTimeout = setTimeout({\n                \"AuthProvider.useEffect.loadingTimeout\": ()=>{\n                    if (loading) {\n                        console.log('Auth loading timeout reached');\n                        setLoading(false);\n                        setAuthError('การตรวจสอบสถานะผู้ใช้ใช้เวลานานเกินไป กรุณาลองใหม่อีกครั้ง');\n                    }\n                }\n            }[\"AuthProvider.useEffect.loadingTimeout\"], 10000); // 10 seconds timeout\n            return ({\n                \"AuthProvider.useEffect\": ()=>clearTimeout(loadingTimeout)\n            })[\"AuthProvider.useEffect\"];\n        }\n    }[\"AuthProvider.useEffect\"], [\n        loading\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"AuthProvider.useEffect\": ()=>{\n            // Check if user is stored in sessionStorage\n            const checkSessionStorage = {\n                \"AuthProvider.useEffect.checkSessionStorage\": ()=>{\n                    console.log('Checking sessionStorage for user data');\n                    try {\n                        // ตรวจสอบว่า sessionStorage พร้อมใช้งานหรือไม่\n                        if ( false || !window.sessionStorage) {\n                            console.log('sessionStorage is not available');\n                            setLoading(false);\n                            return;\n                        }\n                        const storedUser = sessionStorage.getItem('user');\n                        console.log('User data in sessionStorage:', storedUser ? 'Found' : 'Not found');\n                        if (storedUser) {\n                            try {\n                                const userData = JSON.parse(storedUser);\n                                console.log('Successfully parsed user data');\n                                // ตรวจสอบข้อมูลพื้นฐาน\n                                if (userData && userData.uid && userData.username) {\n                                    console.log('Setting user state with data from sessionStorage');\n                                    setUser(userData);\n                                    // ไม่ต้องตรวจสอบ session อีกต่อไป\n                                    setLoading(false);\n                                } else {\n                                    console.log('Invalid user data, missing required fields');\n                                    sessionStorage.removeItem('user');\n                                    setLoading(false);\n                                }\n                            } catch (parseError) {\n                                console.error('Error parsing user data from sessionStorage:', parseError);\n                                // ล้างข้อมูลที่อาจเสียหาย\n                                sessionStorage.removeItem('user');\n                                setAuthError('ข้อมูลการเข้าสู่ระบบไม่ถูกต้อง กรุณาเข้าสู่ระบบใหม่');\n                                setLoading(false);\n                            }\n                        } else {\n                            // ไม่พบข้อมูลผู้ใช้ใน sessionStorage\n                            console.log('No user data found in sessionStorage');\n                            setLoading(false);\n                        }\n                    } catch (error) {\n                        console.error('Error checking sessionStorage:', error);\n                        setAuthError(error.message || 'เกิดข้อผิดพลาดในการตรวจสอบข้อมูลผู้ใช้');\n                        setLoading(false);\n                    }\n                }\n            }[\"AuthProvider.useEffect.checkSessionStorage\"];\n            // หน่วงเวลาเล็กน้อยเพื่อให้แน่ใจว่า client side hydration เสร็จสมบูรณ์\n            const timer = setTimeout({\n                \"AuthProvider.useEffect.timer\": ()=>{\n                    checkSessionStorage();\n                }\n            }[\"AuthProvider.useEffect.timer\"], 100);\n            return ({\n                \"AuthProvider.useEffect\": ()=>clearTimeout(timer)\n            })[\"AuthProvider.useEffect\"];\n        }\n    }[\"AuthProvider.useEffect\"], []);\n    // ติดตามการเปลี่ยนแปลงของ session\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"AuthProvider.useEffect\": ()=>{\n            // ยกเลิกการติดตาม session เนื่องจากอาจทำให้เกิดปัญหา\n            console.log('Session tracking disabled for troubleshooting');\n            // แทนที่จะใช้ listener ให้ใช้ setInterval ตรวจสอบข้อมูลผู้ใช้เป็นระยะ\n            const checkInterval = setInterval({\n                \"AuthProvider.useEffect.checkInterval\": ()=>{\n                    if (user) {\n                        // ตรวจสอบว่า user ยังมีอยู่ใน sessionStorage หรือไม่\n                        const storedUser = sessionStorage.getItem('user');\n                        if (!storedUser) {\n                            console.log('User data removed from sessionStorage, logging out');\n                            setUser(null);\n                        }\n                    }\n                }\n            }[\"AuthProvider.useEffect.checkInterval\"], 30000); // ตรวจสอบทุก 30 วินาที\n            return ({\n                \"AuthProvider.useEffect\": ()=>{\n                    clearInterval(checkInterval);\n                }\n            })[\"AuthProvider.useEffect\"];\n        }\n    }[\"AuthProvider.useEffect\"], [\n        user\n    ]);\n    // ฟังก์ชันตรวจสอบความถูกต้องของ session (แบบง่าย)\n    const validateUserSession = async (user)=>{\n        try {\n            console.log('Basic user validation');\n            // ตรวจสอบเฉพาะข้อมูลพื้นฐาน\n            if (!user || !user.uid || !user.username) {\n                console.error('Invalid user data - missing required fields');\n                logout();\n                return false;\n            }\n            return true;\n        } catch (error) {\n            console.error('Error in validateUserSession:', error);\n            setLoading(false);\n            return false;\n        }\n    };\n    // Login function - simplified version\n    const login = async (username, password)=>{\n        setLoading(true);\n        setAuthError(null);\n        try {\n            console.log('[DEBUG-AUTH] Attempting login with username:', username);\n            console.log('[DEBUG-AUTH] Password length:', (password === null || password === void 0 ? void 0 : password.length) || 0);\n            // ตรวจสอบค่า input\n            if (!(username === null || username === void 0 ? void 0 : username.trim()) || !(password === null || password === void 0 ? void 0 : password.trim())) {\n                console.error('[DEBUG-AUTH] Empty username or password');\n                setAuthError('กรุณากรอกชื่อผู้ใช้และรหัสผ่าน');\n                setLoading(false);\n                return {\n                    success: false,\n                    error: 'กรุณากรอกชื่อผู้ใช้และรหัสผ่าน'\n                };\n            }\n            // เรียกใช้ฟังก์ชัน loginUser ที่ปรับปรุงใหม่\n            const result = await (0,_lib_dataAccess__WEBPACK_IMPORTED_MODULE_4__.loginUser)(username, password);\n            // ตรวจสอบผลลัพธ์\n            if (!result || !result.success) {\n                const errorMsg = (result === null || result === void 0 ? void 0 : result.error) || 'ชื่อผู้ใช้หรือรหัสผ่านไม่ถูกต้อง';\n                console.debug('[DEBUG-AUTH] Login failed:', errorMsg);\n                setAuthError(errorMsg);\n                setLoading(false);\n                return result || {\n                    success: false,\n                    error: errorMsg\n                };\n            }\n            console.log('[DEBUG-AUTH] Login successful, user data:', {\n                uid: result.user.uid,\n                username: result.user.username,\n                role: result.user.role\n            });\n            // ตรวจสอบว่ามีข้อมูลผู้ใช้หรือไม่\n            if (!result.user || !result.user.uid) {\n                console.debug('[DEBUG-AUTH] User data is incomplete');\n                setAuthError('ข้อมูลผู้ใช้ไม่สมบูรณ์ โปรดติดต่อผู้ดูแลระบบ');\n                setLoading(false);\n                return {\n                    success: false,\n                    error: 'ข้อมูลผู้ใช้ไม่สมบูรณ์'\n                };\n            }\n            // บันทึกข้อมูลใน sessionStorage\n            try {\n                const userData = JSON.stringify(result.user);\n                sessionStorage.setItem('user', userData);\n                console.log('[DEBUG-AUTH] User data saved to sessionStorage, length:', userData.length);\n            } catch (storageError) {\n                console.error('[DEBUG-AUTH] Error saving to sessionStorage:', storageError);\n            }\n            // อัปเดตสถานะผู้ใช้ใน state\n            setUser(result.user);\n            // บันทึกการเข้าสู่ระบบ\n            try {\n                (0,_utils_sessionRecording__WEBPACK_IMPORTED_MODULE_5__.logEvent)('user_login', {\n                    userId: result.user.uid,\n                    username: result.user.username,\n                    role: result.user.role,\n                    timestamp: new Date().toISOString()\n                });\n            } catch (logError) {\n                console.warn('[DEBUG-AUTH] Error logging login event:', logError);\n            }\n            console.log('[DEBUG-AUTH] Login process complete, returning result');\n            setLoading(false);\n            return result;\n        } catch (error) {\n            console.error('[DEBUG-AUTH] Login error in AuthContext:', error);\n            const errorMsg = error.message || 'เกิดข้อผิดพลาดในการเข้าสู่ระบบ กรุณาลองใหม่อีกครั้ง';\n            setAuthError(errorMsg);\n            setLoading(false);\n            return {\n                success: false,\n                error: errorMsg\n            };\n        }\n    };\n    // Logout function (simplified)\n    const logout = async ()=>{\n        try {\n            console.log('Logging out user');\n            // ตรวจสอบว่ามี user ที่ล็อกอินอยู่หรือไม่\n            if (user && user.uid && user.sessionToken) {\n                try {\n                    console.log('Calling logoutUser function');\n                    // เรียกใช้ฟังก์ชัน logoutUser แทน invalidateSession\n                    const result = await (0,_lib_dataAccess__WEBPACK_IMPORTED_MODULE_4__.logoutUser)(user.uid, user.sessionToken, user.sessionId);\n                    if (result.success) {\n                        console.log('Logout successful in database');\n                    } else {\n                        console.warn('Issue during logout:', result.messages || result.error);\n                    }\n                } catch (dbError) {\n                    console.error('Error during database logout:', dbError);\n                }\n            } else {\n                // กรณีไม่มี user data ใน state แต่อาจมีใน sessionStorage\n                const userData = sessionStorage.getItem('user');\n                if (userData) {\n                    try {\n                        const parsedUser = JSON.parse(userData);\n                        if (parsedUser && parsedUser.uid && parsedUser.sessionToken) {\n                            console.log('Logging out user from sessionStorage data');\n                            await (0,_lib_dataAccess__WEBPACK_IMPORTED_MODULE_4__.logoutUser)(parsedUser.uid, parsedUser.sessionToken, parsedUser.sessionId);\n                        }\n                    } catch (parseError) {\n                        console.error('Error parsing user data for logout:', parseError);\n                    }\n                }\n            }\n            // ล้างข้อมูลใน sessionStorage\n            sessionStorage.removeItem('user');\n            // รีเซ็ต state\n            setUser(null);\n            setAuthError(null);\n            console.log('Logged out successfully (client-side)');\n            // นำทางไปยังหน้า login หลังจากการออกจากระบบ\n            try {\n                window.location.href = '/page/login';\n            } catch (navError) {\n                console.error('Error navigating after logout:', navError);\n            }\n        } catch (error) {\n            console.error('Logout error:', error);\n        }\n    };\n    const contextValue = {\n        user,\n        loading,\n        isAuthenticated: !!user,\n        authError,\n        login,\n        logout,\n        clearAuthError\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(AuthContext.Provider, {\n        value: contextValue,\n        children: children\n    }, void 0, false, {\n        fileName: \"C:\\\\Active 14-3-2025\\\\Summary_of_Personnel_Ratio\\\\app\\\\context\\\\AuthContext.js\",\n        lineNumber: 312,\n        columnNumber: 5\n    }, this);\n}\n_s1(AuthProvider, \"76MNfp0tazfQpgpif3PspRKGE6w=\");\n_c = AuthProvider;\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9jb250ZXh0L0F1dGhDb250ZXh0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQ3VFO0FBQzVCO0FBQ3lGO0FBQ3RDO0FBQ3pDO0FBQ2pCO0FBRXBDLDhDQUE4QztBQUM5QyxNQUFNdUIsc0JBQXNCLEtBQUssS0FBSyxNQUFNLHdCQUF3QjtBQUVwRSw4QkFBOEI7QUFDOUIsTUFBTUMsdUJBQXVCO0lBQzNCLE9BQU9DLEtBQUtDLE1BQU0sR0FBR0MsUUFBUSxDQUFDLElBQUlDLFNBQVMsQ0FBQyxHQUFHLE1BQ3hDSCxLQUFLQyxNQUFNLEdBQUdDLFFBQVEsQ0FBQyxJQUFJQyxTQUFTLENBQUMsR0FBRyxNQUN4Q0MsS0FBS0MsR0FBRyxHQUFHSCxRQUFRLENBQUM7QUFDN0I7QUFFQSxtRUFBbUU7QUFDbkUsTUFBTUksNEJBQWMvQixvREFBYUEsQ0FBQztJQUNoQ2dDLE1BQU07SUFDTkMsU0FBUztJQUNUQyxpQkFBaUI7SUFDakJDLFdBQVc7SUFDWEMsT0FBTyxPQUFPQyxVQUFVQyxZQUFjO0lBQ3RDQyxRQUFRLEtBQU87SUFDZkMsZ0JBQWdCLEtBQU87QUFDekI7QUFFTyxNQUFNQyxVQUFVOztJQUFNeEMsT0FBQUEsaURBQVVBLENBQUM4QjtBQUFXLEVBQUU7R0FBeENVO0FBRU4sU0FBU0MsYUFBYSxLQUFZO1FBQVosRUFBRUMsUUFBUSxFQUFFLEdBQVo7O0lBQzNCLE1BQU0sQ0FBQ1gsTUFBTVksUUFBUSxHQUFHMUMsK0NBQVFBLENBQUM7SUFDakMsTUFBTSxDQUFDK0IsU0FBU1ksV0FBVyxHQUFHM0MsK0NBQVFBLENBQUM7SUFDdkMsTUFBTSxDQUFDaUMsV0FBV1csYUFBYSxHQUFHNUMsK0NBQVFBLENBQUM7SUFFM0Msb0NBQW9DO0lBQ3BDLE1BQU1zQyxpQkFBaUI7UUFDckJNLGFBQWE7SUFDZjtJQUVBM0MsZ0RBQVNBO2tDQUFDO1lBQ1IsNENBQTRDO1lBQzVDLE1BQU00QyxpQkFBaUJDO3lEQUFXO29C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QUFRYyxLQUFLLENBQUMsaUJBQWlCQTtRQUNqQztJQUNGO0lBRUEsTUFBTThCLGVBQWU7UUFDbkI3RDtRQUNBQztRQUNBQyxpQkFBaUIsQ0FBQyxDQUFDRjtRQUNuQkc7UUFDQUM7UUFDQUc7UUFDQUM7SUFDRjtJQUVBLHFCQUNFLDhEQUFDVCxZQUFZK0QsUUFBUTtRQUFDQyxPQUFPRjtrQkFDMUJsRDs7Ozs7O0FBR1A7SUE1UmdCRDtLQUFBQSIsInNvdXJjZXMiOlsiQzpcXEFjdGl2ZSAxNC0zLTIwMjVcXFN1bW1hcnlfb2ZfUGVyc29ubmVsX1JhdGlvXFxhcHBcXGNvbnRleHRcXEF1dGhDb250ZXh0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcclxuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHsgYXV0aCwgZGIgfSBmcm9tICcuLi9saWIvZmlyZWJhc2UnO1xyXG5pbXBvcnQgeyBkb2MsIGdldERvYywgc2V0RG9jLCB1cGRhdGVEb2MsIHNlcnZlclRpbWVzdGFtcCwgb25TbmFwc2hvdCwgY29sbGVjdGlvbiwgcXVlcnksIHdoZXJlLCBnZXREb2NzIH0gZnJvbSAnZmlyZWJhc2UvZmlyZXN0b3JlJztcclxuaW1wb3J0IHsgbG9naW5Vc2VyLCB2YWxpZGF0ZVNlc3Npb24sIGludmFsaWRhdGVTZXNzaW9uLCBsb2dvdXRVc2VyIH0gZnJvbSAnLi4vbGliL2RhdGFBY2Nlc3MnO1xyXG5pbXBvcnQgeyBsb2dFdmVudCB9IGZyb20gJy4uL3V0aWxzL3Nlc3Npb25SZWNvcmRpbmcnO1xyXG5pbXBvcnQgeyB2NCBhcyB1dWlkdjQgfSBmcm9tICd1dWlkJztcclxuXHJcbi8vIOC4o+C4sOC4ouC4sOC5gOC4p+C4peC4suC4l+C4teC5iCBzZXNzaW9uIHRva2VuIOC4q+C4oeC4lOC4reC4suC4ouC4uCAoMjAg4LiZ4Liy4LiX4Li1KVxyXG5jb25zdCBTRVNTSU9OX0VYUElSWV9USU1FID0gMjAgKiA2MCAqIDEwMDA7IC8vIDIwIOC4meC4suC4l+C4tSDguYPguJnguKHguLTguKXguKXguLTguKfguLTguJnguLLguJfguLVcclxuXHJcbi8vIOC4quC4o+C5ieC4suC4hyBzZXNzaW9uIHRva2VuIOC5geC4muC4muC4quC4uOC5iOC4oVxyXG5jb25zdCBnZW5lcmF0ZVNlc3Npb25Ub2tlbiA9ICgpID0+IHtcclxuICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDE1KSArIFxyXG4gICAgICAgICBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgMTUpICsgXHJcbiAgICAgICAgIERhdGUubm93KCkudG9TdHJpbmcoMzYpO1xyXG59O1xyXG5cclxuLy8gSW5pdGlhbGl6ZSB3aXRoIGRlZmF1bHQgdmFsdWVzIGluY2x1ZGluZyB0aGUgZnVuY3Rpb24gc2lnbmF0dXJlc1xyXG5jb25zdCBBdXRoQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoe1xyXG4gIHVzZXI6IG51bGwsXHJcbiAgbG9hZGluZzogdHJ1ZSxcclxuICBpc0F1dGhlbnRpY2F0ZWQ6IGZhbHNlLFxyXG4gIGF1dGhFcnJvcjogbnVsbCxcclxuICBsb2dpbjogYXN5bmMgKHVzZXJuYW1lLCBwYXNzd29yZCkgPT4ge30sXHJcbiAgbG9nb3V0OiAoKSA9PiB7fSxcclxuICBjbGVhckF1dGhFcnJvcjogKCkgPT4ge30sXHJcbn0pO1xyXG5cclxuZXhwb3J0IGNvbnN0IHVzZUF1dGggPSAoKSA9PiB1c2VDb250ZXh0KEF1dGhDb250ZXh0KTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBBdXRoUHJvdmlkZXIoeyBjaGlsZHJlbiB9KSB7XHJcbiAgY29uc3QgW3VzZXIsIHNldFVzZXJdID0gdXNlU3RhdGUobnVsbCk7XHJcbiAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGUodHJ1ZSk7XHJcbiAgY29uc3QgW2F1dGhFcnJvciwgc2V0QXV0aEVycm9yXSA9IHVzZVN0YXRlKG51bGwpO1xyXG4gIFxyXG4gIC8vIEFkZCBmdW5jdGlvbiB0byBjbGVhciBhdXRoIGVycm9yc1xyXG4gIGNvbnN0IGNsZWFyQXV0aEVycm9yID0gKCkgPT4ge1xyXG4gICAgc2V0QXV0aEVycm9yKG51bGwpO1xyXG4gIH07XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAvLyBBZGQgdGltZW91dCB0byBwcmV2ZW50IGluZGVmaW5pdGUgbG9hZGluZ1xyXG4gICAgY29uc3QgbG9hZGluZ1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgaWYgKGxvYWRpbmcpIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnQXV0aCBsb2FkaW5nIHRpbWVvdXQgcmVhY2hlZCcpO1xyXG4gICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xyXG4gICAgICAgIHNldEF1dGhFcnJvcign4LiB4Liy4Lij4LiV4Lij4Lin4LiI4Liq4Lit4Lia4Liq4LiW4Liy4LiZ4Liw4Lic4Li54LmJ4LmD4LiK4LmJ4LmD4LiK4LmJ4LmA4Lin4Lil4Liy4LiZ4Liy4LiZ4LmA4LiB4Li04LiZ4LmE4LibIOC4geC4o+C4uOC4k+C4suC4peC4reC4h+C5g+C4q+C4oeC5iOC4reC4teC4geC4hOC4o+C4seC5ieC4hycpO1xyXG4gICAgICB9XHJcbiAgICB9LCAxMDAwMCk7IC8vIDEwIHNlY29uZHMgdGltZW91dFxyXG5cclxuICAgIHJldHVybiAoKSA9PiBjbGVhclRpbWVvdXQobG9hZGluZ1RpbWVvdXQpO1xyXG4gIH0sIFtsb2FkaW5nXSk7XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAvLyBDaGVjayBpZiB1c2VyIGlzIHN0b3JlZCBpbiBzZXNzaW9uU3RvcmFnZVxyXG4gICAgY29uc3QgY2hlY2tTZXNzaW9uU3RvcmFnZSA9ICgpID0+IHtcclxuICAgICAgY29uc29sZS5sb2coJ0NoZWNraW5nIHNlc3Npb25TdG9yYWdlIGZvciB1c2VyIGRhdGEnKTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICAvLyDguJXguKPguKfguIjguKrguK3guJrguKfguYjguLIgc2Vzc2lvblN0b3JhZ2Ug4Lie4Lij4LmJ4Lit4Lih4LmD4LiK4LmJ4LiH4Liy4LiZ4Lir4Lij4Li34Lit4LmE4Lih4LmIXHJcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICF3aW5kb3cuc2Vzc2lvblN0b3JhZ2UpIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKCdzZXNzaW9uU3RvcmFnZSBpcyBub3QgYXZhaWxhYmxlJyk7XHJcbiAgICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc3Qgc3RvcmVkVXNlciA9IHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oJ3VzZXInKTtcclxuICAgICAgICBjb25zb2xlLmxvZygnVXNlciBkYXRhIGluIHNlc3Npb25TdG9yYWdlOicsIHN0b3JlZFVzZXIgPyAnRm91bmQnIDogJ05vdCBmb3VuZCcpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChzdG9yZWRVc2VyKSB7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCB1c2VyRGF0YSA9IEpTT04ucGFyc2Uoc3RvcmVkVXNlcik7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdTdWNjZXNzZnVsbHkgcGFyc2VkIHVzZXIgZGF0YScpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8g4LiV4Lij4Lin4LiI4Liq4Lit4Lia4LiC4LmJ4Lit4Lih4Li54Lil4Lie4Li34LmJ4LiZ4LiQ4Liy4LiZXHJcbiAgICAgICAgICAgIGlmICh1c2VyRGF0YSAmJiB1c2VyRGF0YS51aWQgJiYgdXNlckRhdGEudXNlcm5hbWUpIHtcclxuICAgICAgICAgICAgICBjb25zb2xlLmxvZygnU2V0dGluZyB1c2VyIHN0YXRlIHdpdGggZGF0YSBmcm9tIHNlc3Npb25TdG9yYWdlJyk7XHJcbiAgICAgICAgICAgICAgc2V0VXNlcih1c2VyRGF0YSk7XHJcbiAgICAgICAgICAgICAgLy8g4LmE4Lih4LmI4LiV4LmJ4Lit4LiH4LiV4Lij4Lin4LiI4Liq4Lit4LiaIHNlc3Npb24g4Lit4Li14LiB4LiV4LmI4Lit4LmE4LibXHJcbiAgICAgICAgICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0ludmFsaWQgdXNlciBkYXRhLCBtaXNzaW5nIHJlcXVpcmVkIGZpZWxkcycpO1xyXG4gICAgICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0oJ3VzZXInKTtcclxuICAgICAgICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBjYXRjaCAocGFyc2VFcnJvcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBwYXJzaW5nIHVzZXIgZGF0YSBmcm9tIHNlc3Npb25TdG9yYWdlOicsIHBhcnNlRXJyb3IpO1xyXG4gICAgICAgICAgICAvLyDguKXguYnguLLguIfguILguYnguK3guKHguLnguKXguJfguLXguYjguK3guLLguIjguYDguKrguLXguKLguKvguLLguKJcclxuICAgICAgICAgICAgc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbSgndXNlcicpO1xyXG4gICAgICAgICAgICBzZXRBdXRoRXJyb3IoJ+C4guC5ieC4reC4oeC4ueC4peC4geC4suC4o+C5gOC4guC5ieC4suC4quC4ueC5iOC4o+C4sOC4muC4muC5hOC4oeC5iOC4luC4ueC4geC4leC5ieC4reC4hyDguIHguKPguLjguJPguLLguYDguILguYnguLLguKrguLnguYjguKPguLDguJrguJrguYPguKvguKHguYgnKTtcclxuICAgICAgICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIOC5hOC4oeC5iOC4nuC4muC4guC5ieC4reC4oeC4ueC4peC4nOC4ueC5ieC5g+C4iuC5ieC5g+C4mSBzZXNzaW9uU3RvcmFnZVxyXG4gICAgICAgICAgY29uc29sZS5sb2coJ05vIHVzZXIgZGF0YSBmb3VuZCBpbiBzZXNzaW9uU3RvcmFnZScpO1xyXG4gICAgICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNoZWNraW5nIHNlc3Npb25TdG9yYWdlOicsIGVycm9yKTtcclxuICAgICAgICBzZXRBdXRoRXJyb3IoZXJyb3IubWVzc2FnZSB8fCAn4LmA4LiB4Li04LiU4LiC4LmJ4Lit4Lic4Li04LiU4Lie4Lil4Liy4LiU4LmD4LiZ4LiB4Liy4Lij4LiV4Lij4Lin4LiI4Liq4Lit4Lia4LiC4LmJ4Lit4Lih4Li54Lil4Lic4Li54LmJ4LmD4LiK4LmJJyk7XHJcbiAgICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICBcclxuICAgIC8vIOC4q+C4meC5iOC4p+C4h+C5gOC4p+C4peC4suC5gOC4peC5h+C4geC4meC5ieC4reC4ouC5gOC4nuC4t+C5iOC4reC5g+C4q+C5ieC5geC4meC5iOC5g+C4iOC4p+C5iOC4siBjbGllbnQgc2lkZSBoeWRyYXRpb24g4LmA4Liq4Lij4LmH4LiI4Liq4Lih4Lia4Li54Lij4LiT4LmMXHJcbiAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICBjaGVja1Nlc3Npb25TdG9yYWdlKCk7XHJcbiAgICB9LCAxMDApO1xyXG4gICAgXHJcbiAgICByZXR1cm4gKCkgPT4gY2xlYXJUaW1lb3V0KHRpbWVyKTtcclxuICB9LCBbXSk7XHJcblxyXG4gIC8vIOC4leC4tOC4lOC4leC4suC4oeC4geC4suC4o+C5gOC4m+C4peC4teC5iOC4ouC4meC5geC4m+C4peC4h+C4guC4reC4hyBzZXNzaW9uXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIC8vIOC4ouC4geC5gOC4peC4tOC4geC4geC4suC4o+C4leC4tOC4lOC4leC4suC4oSBzZXNzaW9uIOC5gOC4meC4t+C5iOC4reC4h+C4iOC4suC4geC4reC4suC4iOC4l+C4s+C5g+C4q+C5ieC5gOC4geC4tOC4lOC4m+C4seC4jeC4q+C4slxyXG4gICAgY29uc29sZS5sb2coJ1Nlc3Npb24gdHJhY2tpbmcgZGlzYWJsZWQgZm9yIHRyb3VibGVzaG9vdGluZycpO1xyXG4gICAgXHJcbiAgICAvLyDguYHguJfguJnguJfguLXguYjguIjguLDguYPguIrguYkgbGlzdGVuZXIg4LmD4Lir4LmJ4LmD4LiK4LmJIHNldEludGVydmFsIOC4leC4o+C4p+C4iOC4quC4reC4muC4guC5ieC4reC4oeC4ueC4peC4nOC4ueC5ieC5g+C4iuC5ieC5gOC4m+C5h+C4meC4o+C4sOC4ouC4sFxyXG4gICAgY29uc3QgY2hlY2tJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcclxuICAgICAgaWYgKHVzZXIpIHtcclxuICAgICAgICAvLyDguJXguKPguKfguIjguKrguK3guJrguKfguYjguLIgdXNlciDguKLguLHguIfguKHguLXguK3guKLguLnguYjguYPguJkgc2Vzc2lvblN0b3JhZ2Ug4Lir4Lij4Li34Lit4LmE4Lih4LmIXHJcbiAgICAgICAgY29uc3Qgc3RvcmVkVXNlciA9IHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oJ3VzZXInKTtcclxuICAgICAgICBpZiAoIXN0b3JlZFVzZXIpIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKCdVc2VyIGRhdGEgcmVtb3ZlZCBmcm9tIHNlc3Npb25TdG9yYWdlLCBsb2dnaW5nIG91dCcpO1xyXG4gICAgICAgICAgc2V0VXNlcihudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0sIDMwMDAwKTsgLy8g4LiV4Lij4Lin4LiI4Liq4Lit4Lia4LiX4Li44LiBIDMwIOC4p+C4tOC4meC4suC4l+C4tVxyXG4gICAgXHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICBjbGVhckludGVydmFsKGNoZWNrSW50ZXJ2YWwpO1xyXG4gICAgfTtcclxuICB9LCBbdXNlcl0pO1xyXG5cclxuICAvLyDguJ/guLHguIfguIHguYzguIrguLHguJnguJXguKPguKfguIjguKrguK3guJrguITguKfguLLguKHguJbguLnguIHguJXguYnguK3guIfguILguK3guIcgc2Vzc2lvbiAo4LmB4Lia4Lia4LiH4LmI4Liy4LiiKVxyXG4gIGNvbnN0IHZhbGlkYXRlVXNlclNlc3Npb24gPSBhc3luYyAodXNlcikgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2coJ0Jhc2ljIHVzZXIgdmFsaWRhdGlvbicpO1xyXG4gICAgICBcclxuICAgICAgLy8g4LiV4Lij4Lin4LiI4Liq4Lit4Lia4LmA4LiJ4Lie4Liy4Liw4LiC4LmJ4Lit4Lih4Li54Lil4Lie4Li34LmJ4LiZ4LiQ4Liy4LiZXHJcbiAgICAgIGlmICghdXNlciB8fCAhdXNlci51aWQgfHwgIXVzZXIudXNlcm5hbWUpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIHVzZXIgZGF0YSAtIG1pc3NpbmcgcmVxdWlyZWQgZmllbGRzJyk7XHJcbiAgICAgICAgbG9nb3V0KCk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIHZhbGlkYXRlVXNlclNlc3Npb246JywgZXJyb3IpO1xyXG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8vIExvZ2luIGZ1bmN0aW9uIC0gc2ltcGxpZmllZCB2ZXJzaW9uXHJcbiAgY29uc3QgbG9naW4gPSBhc3luYyAodXNlcm5hbWUsIHBhc3N3b3JkKSA9PiB7XHJcbiAgICBzZXRMb2FkaW5nKHRydWUpO1xyXG4gICAgc2V0QXV0aEVycm9yKG51bGwpO1xyXG4gICAgXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZygnW0RFQlVHLUFVVEhdIEF0dGVtcHRpbmcgbG9naW4gd2l0aCB1c2VybmFtZTonLCB1c2VybmFtZSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdbREVCVUctQVVUSF0gUGFzc3dvcmQgbGVuZ3RoOicsIHBhc3N3b3JkPy5sZW5ndGggfHwgMCk7XHJcbiAgICAgIFxyXG4gICAgICAvLyDguJXguKPguKfguIjguKrguK3guJrguITguYjguLIgaW5wdXRcclxuICAgICAgaWYgKCF1c2VybmFtZT8udHJpbSgpIHx8ICFwYXNzd29yZD8udHJpbSgpKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignW0RFQlVHLUFVVEhdIEVtcHR5IHVzZXJuYW1lIG9yIHBhc3N3b3JkJyk7XHJcbiAgICAgICAgc2V0QXV0aEVycm9yKCfguIHguKPguLjguJPguLLguIHguKPguK3guIHguIrguLfguYjguK3guJzguLnguYnguYPguIrguYnguYHguKXguLDguKPguKvguLHguKrguJzguYjguLLguJknKTtcclxuICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXHJcbiAgICAgICAgICBlcnJvcjogJ+C4geC4o+C4uOC4k+C4suC4geC4o+C4reC4geC4iuC4t+C5iOC4reC4nOC4ueC5ieC5g+C4iuC5ieC5geC4peC4sOC4o+C4q+C4seC4quC4nOC5iOC4suC4mSdcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyDguYDguKPguLXguKLguIHguYPguIrguYnguJ/guLHguIfguIHguYzguIrguLHguJkgbG9naW5Vc2VyIOC4l+C4teC5iOC4m+C4o+C4seC4muC4m+C4o+C4uOC4h+C5g+C4q+C4oeC5iFxyXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBsb2dpblVzZXIodXNlcm5hbWUsIHBhc3N3b3JkKTtcclxuICAgICAgXHJcbiAgICAgIC8vIOC4leC4o+C4p+C4iOC4quC4reC4muC4nOC4peC4peC4seC4nuC4mOC5jFxyXG4gICAgICBpZiAoIXJlc3VsdCB8fCAhcmVzdWx0LnN1Y2Nlc3MpIHtcclxuICAgICAgICBjb25zdCBlcnJvck1zZyA9IHJlc3VsdD8uZXJyb3IgfHwgJ+C4iuC4t+C5iOC4reC4nOC4ueC5ieC5g+C4iuC5ieC4q+C4o+C4t+C4reC4o+C4q+C4seC4quC4nOC5iOC4suC4meC5hOC4oeC5iOC4luC4ueC4geC4leC5ieC4reC4hyc7XHJcbiAgICAgICAgY29uc29sZS5kZWJ1ZygnW0RFQlVHLUFVVEhdIExvZ2luIGZhaWxlZDonLCBlcnJvck1zZyk7XHJcbiAgICAgICAgc2V0QXV0aEVycm9yKGVycm9yTXNnKTtcclxuICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0IHx8IHsgXHJcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcclxuICAgICAgICAgIGVycm9yOiBlcnJvck1zZ1xyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKCdbREVCVUctQVVUSF0gTG9naW4gc3VjY2Vzc2Z1bCwgdXNlciBkYXRhOicsIHtcclxuICAgICAgICB1aWQ6IHJlc3VsdC51c2VyLnVpZCxcclxuICAgICAgICB1c2VybmFtZTogcmVzdWx0LnVzZXIudXNlcm5hbWUsXHJcbiAgICAgICAgcm9sZTogcmVzdWx0LnVzZXIucm9sZVxyXG4gICAgICB9KTtcclxuICAgICAgXHJcbiAgICAgIC8vIOC4leC4o+C4p+C4iOC4quC4reC4muC4p+C5iOC4suC4oeC4teC4guC5ieC4reC4oeC4ueC4peC4nOC4ueC5ieC5g+C4iuC5ieC4q+C4o+C4t+C4reC5hOC4oeC5iFxyXG4gICAgICBpZiAoIXJlc3VsdC51c2VyIHx8ICFyZXN1bHQudXNlci51aWQpIHtcclxuICAgICAgICBjb25zb2xlLmRlYnVnKCdbREVCVUctQVVUSF0gVXNlciBkYXRhIGlzIGluY29tcGxldGUnKTtcclxuICAgICAgICBzZXRBdXRoRXJyb3IoJ+C4guC5ieC4reC4oeC4ueC4peC4nOC4ueC5ieC5g+C4iuC5ieC5hOC4oeC5iOC4quC4oeC4muC4ueC4o+C4k+C5jCDguYLguJvguKPguJTguJXguLTguJTguJXguYjguK3guJzguLnguYnguJTguLnguYHguKXguKPguLDguJrguJonKTtcclxuICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXHJcbiAgICAgICAgICBlcnJvcjogJ+C4guC5ieC4reC4oeC4ueC4peC4nOC4ueC5ieC5g+C4iuC5ieC5hOC4oeC5iOC4quC4oeC4muC4ueC4o+C4k+C5jCdcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyDguJrguLHguJnguJfguLbguIHguILguYnguK3guKHguLnguKXguYPguJkgc2Vzc2lvblN0b3JhZ2VcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCB1c2VyRGF0YSA9IEpTT04uc3RyaW5naWZ5KHJlc3VsdC51c2VyKTtcclxuICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKCd1c2VyJywgdXNlckRhdGEpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdbREVCVUctQVVUSF0gVXNlciBkYXRhIHNhdmVkIHRvIHNlc3Npb25TdG9yYWdlLCBsZW5ndGg6JywgdXNlckRhdGEubGVuZ3RoKTtcclxuICAgICAgfSBjYXRjaCAoc3RvcmFnZUVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignW0RFQlVHLUFVVEhdIEVycm9yIHNhdmluZyB0byBzZXNzaW9uU3RvcmFnZTonLCBzdG9yYWdlRXJyb3IpO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyDguK3guLHguJvguYDguJTguJXguKrguJbguLLguJnguLDguJzguLnguYnguYPguIrguYnguYPguJkgc3RhdGVcclxuICAgICAgc2V0VXNlcihyZXN1bHQudXNlcik7XHJcbiAgICAgIFxyXG4gICAgICAvLyDguJrguLHguJnguJfguLbguIHguIHguLLguKPguYDguILguYnguLLguKrguLnguYjguKPguLDguJrguJpcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBsb2dFdmVudCgndXNlcl9sb2dpbicsIHtcclxuICAgICAgICAgIHVzZXJJZDogcmVzdWx0LnVzZXIudWlkLFxyXG4gICAgICAgICAgdXNlcm5hbWU6IHJlc3VsdC51c2VyLnVzZXJuYW1lLFxyXG4gICAgICAgICAgcm9sZTogcmVzdWx0LnVzZXIucm9sZSxcclxuICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gY2F0Y2ggKGxvZ0Vycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdbREVCVUctQVVUSF0gRXJyb3IgbG9nZ2luZyBsb2dpbiBldmVudDonLCBsb2dFcnJvcik7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKCdbREVCVUctQVVUSF0gTG9naW4gcHJvY2VzcyBjb21wbGV0ZSwgcmV0dXJuaW5nIHJlc3VsdCcpO1xyXG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tERUJVRy1BVVRIXSBMb2dpbiBlcnJvciBpbiBBdXRoQ29udGV4dDonLCBlcnJvcik7XHJcbiAgICAgIGNvbnN0IGVycm9yTXNnID0gZXJyb3IubWVzc2FnZSB8fCAn4LmA4LiB4Li04LiU4LiC4LmJ4Lit4Lic4Li04LiU4Lie4Lil4Liy4LiU4LmD4LiZ4LiB4Liy4Lij4LmA4LiC4LmJ4Liy4Liq4Li54LmI4Lij4Liw4Lia4LiaIOC4geC4o+C4uOC4k+C4suC4peC4reC4h+C5g+C4q+C4oeC5iOC4reC4teC4geC4hOC4o+C4seC5ieC4hyc7XHJcbiAgICAgIHNldEF1dGhFcnJvcihlcnJvck1zZyk7XHJcbiAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxyXG4gICAgICAgIGVycm9yOiBlcnJvck1zZ1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8vIExvZ291dCBmdW5jdGlvbiAoc2ltcGxpZmllZClcclxuICBjb25zdCBsb2dvdXQgPSBhc3luYyAoKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZygnTG9nZ2luZyBvdXQgdXNlcicpO1xyXG4gICAgICBcclxuICAgICAgLy8g4LiV4Lij4Lin4LiI4Liq4Lit4Lia4Lin4LmI4Liy4Lih4Li1IHVzZXIg4LiX4Li14LmI4Lil4LmH4Lit4LiB4Lit4Li04LiZ4Lit4Lii4Li54LmI4Lir4Lij4Li34Lit4LmE4Lih4LmIXHJcbiAgICAgIGlmICh1c2VyICYmIHVzZXIudWlkICYmIHVzZXIuc2Vzc2lvblRva2VuKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKCdDYWxsaW5nIGxvZ291dFVzZXIgZnVuY3Rpb24nKTtcclxuICAgICAgICAgIC8vIOC5gOC4o+C4teC4ouC4geC5g+C4iuC5ieC4n+C4seC4h+C4geC5jOC4iuC4seC4mSBsb2dvdXRVc2VyIOC5geC4l+C4mSBpbnZhbGlkYXRlU2Vzc2lvblxyXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbG9nb3V0VXNlcih1c2VyLnVpZCwgdXNlci5zZXNzaW9uVG9rZW4sIHVzZXIuc2Vzc2lvbklkKTtcclxuICAgICAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnTG9nb3V0IHN1Y2Nlc3NmdWwgaW4gZGF0YWJhc2UnKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignSXNzdWUgZHVyaW5nIGxvZ291dDonLCByZXN1bHQubWVzc2FnZXMgfHwgcmVzdWx0LmVycm9yKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChkYkVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkdXJpbmcgZGF0YWJhc2UgbG9nb3V0OicsIGRiRXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyDguIHguKPguJPguLXguYTguKHguYjguKHguLUgdXNlciBkYXRhIOC5g+C4mSBzdGF0ZSDguYHguJXguYjguK3guLLguIjguKHguLXguYPguJkgc2Vzc2lvblN0b3JhZ2VcclxuICAgICAgICBjb25zdCB1c2VyRGF0YSA9IHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oJ3VzZXInKTtcclxuICAgICAgICBpZiAodXNlckRhdGEpIHtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZFVzZXIgPSBKU09OLnBhcnNlKHVzZXJEYXRhKTtcclxuICAgICAgICAgICAgaWYgKHBhcnNlZFVzZXIgJiYgcGFyc2VkVXNlci51aWQgJiYgcGFyc2VkVXNlci5zZXNzaW9uVG9rZW4pIHtcclxuICAgICAgICAgICAgICBjb25zb2xlLmxvZygnTG9nZ2luZyBvdXQgdXNlciBmcm9tIHNlc3Npb25TdG9yYWdlIGRhdGEnKTtcclxuICAgICAgICAgICAgICBhd2FpdCBsb2dvdXRVc2VyKHBhcnNlZFVzZXIudWlkLCBwYXJzZWRVc2VyLnNlc3Npb25Ub2tlbiwgcGFyc2VkVXNlci5zZXNzaW9uSWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGNhdGNoIChwYXJzZUVycm9yKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHBhcnNpbmcgdXNlciBkYXRhIGZvciBsb2dvdXQ6JywgcGFyc2VFcnJvcik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyDguKXguYnguLLguIfguILguYnguK3guKHguLnguKXguYPguJkgc2Vzc2lvblN0b3JhZ2VcclxuICAgICAgc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbSgndXNlcicpO1xyXG4gICAgICBcclxuICAgICAgLy8g4Lij4Li14LmA4LiL4LmH4LiVIHN0YXRlXHJcbiAgICAgIHNldFVzZXIobnVsbCk7XHJcbiAgICAgIHNldEF1dGhFcnJvcihudWxsKTtcclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKCdMb2dnZWQgb3V0IHN1Y2Nlc3NmdWxseSAoY2xpZW50LXNpZGUpJyk7XHJcbiAgICAgIFxyXG4gICAgICAvLyDguJnguLPguJfguLLguIfguYTguJvguKLguLHguIfguKvguJnguYnguLIgbG9naW4g4Lir4Lil4Lix4LiH4LiI4Liy4LiB4LiB4Liy4Lij4Lit4Lit4LiB4LiI4Liy4LiB4Lij4Liw4Lia4LiaXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSAnL3BhZ2UvbG9naW4nO1xyXG4gICAgICB9IGNhdGNoIChuYXZFcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIG5hdmlnYXRpbmcgYWZ0ZXIgbG9nb3V0OicsIG5hdkVycm9yKTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignTG9nb3V0IGVycm9yOicsIGVycm9yKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBjb25zdCBjb250ZXh0VmFsdWUgPSB7XHJcbiAgICB1c2VyLFxyXG4gICAgbG9hZGluZyxcclxuICAgIGlzQXV0aGVudGljYXRlZDogISF1c2VyLFxyXG4gICAgYXV0aEVycm9yLFxyXG4gICAgbG9naW4sXHJcbiAgICBsb2dvdXQsXHJcbiAgICBjbGVhckF1dGhFcnJvcixcclxuICB9O1xyXG5cclxuICByZXR1cm4gKFxyXG4gICAgPEF1dGhDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtjb250ZXh0VmFsdWV9PlxyXG4gICAgICB7Y2hpbGRyZW59XHJcbiAgICA8L0F1dGhDb250ZXh0LlByb3ZpZGVyPlxyXG4gICk7XHJcbn0iXSwibmFtZXMiOlsiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsImF1dGgiLCJkYiIsImRvYyIsImdldERvYyIsInNldERvYyIsInVwZGF0ZURvYyIsInNlcnZlclRpbWVzdGFtcCIsIm9uU25hcHNob3QiLCJjb2xsZWN0aW9uIiwicXVlcnkiLCJ3aGVyZSIsImdldERvY3MiLCJsb2dpblVzZXIiLCJ2YWxpZGF0ZVNlc3Npb24iLCJpbnZhbGlkYXRlU2Vzc2lvbiIsImxvZ291dFVzZXIiLCJsb2dFdmVudCIsInY0IiwidXVpZHY0IiwiU0VTU0lPTl9FWFBJUllfVElNRSIsImdlbmVyYXRlU2Vzc2lvblRva2VuIiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyaW5nIiwiRGF0ZSIsIm5vdyIsIkF1dGhDb250ZXh0IiwidXNlciIsImxvYWRpbmciLCJpc0F1dGhlbnRpY2F0ZWQiLCJhdXRoRXJyb3IiLCJsb2dpbiIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJsb2dvdXQiLCJjbGVhckF1dGhFcnJvciIsInVzZUF1dGgiLCJBdXRoUHJvdmlkZXIiLCJjaGlsZHJlbiIsInNldFVzZXIiLCJzZXRMb2FkaW5nIiwic2V0QXV0aEVycm9yIiwibG9hZGluZ1RpbWVvdXQiLCJzZXRUaW1lb3V0IiwiY29uc29sZSIsImxvZyIsImNsZWFyVGltZW91dCIsImNoZWNrU2Vzc2lvblN0b3JhZ2UiLCJ3aW5kb3ciLCJzZXNzaW9uU3RvcmFnZSIsInN0b3JlZFVzZXIiLCJnZXRJdGVtIiwidXNlckRhdGEiLCJKU09OIiwicGFyc2UiLCJ1aWQiLCJyZW1vdmVJdGVtIiwicGFyc2VFcnJvciIsImVycm9yIiwibWVzc2FnZSIsInRpbWVyIiwiY2hlY2tJbnRlcnZhbCIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsInZhbGlkYXRlVXNlclNlc3Npb24iLCJsZW5ndGgiLCJ0cmltIiwic3VjY2VzcyIsInJlc3VsdCIsImVycm9yTXNnIiwiZGVidWciLCJyb2xlIiwic3RyaW5naWZ5Iiwic2V0SXRlbSIsInN0b3JhZ2VFcnJvciIsInVzZXJJZCIsInRpbWVzdGFtcCIsInRvSVNPU3RyaW5nIiwibG9nRXJyb3IiLCJ3YXJuIiwic2Vzc2lvblRva2VuIiwic2Vzc2lvbklkIiwibWVzc2FnZXMiLCJkYkVycm9yIiwicGFyc2VkVXNlciIsImxvY2F0aW9uIiwiaHJlZiIsIm5hdkVycm9yIiwiY29udGV4dFZhbHVlIiwiUHJvdmlkZXIiLCJ2YWx1ZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/context/AuthContext.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/lib/dataAccess.js":
/*!*******************************!*\
  !*** ./app/lib/dataAccess.js ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addUser: () => (/* binding */ addUser),\n/* harmony export */   checkLast7DaysData: () => (/* binding */ checkLast7DaysData),\n/* harmony export */   deleteUser: () => (/* binding */ deleteUser),\n/* harmony export */   deleteWardDataDraft: () => (/* binding */ deleteWardDataDraft),\n/* harmony export */   getAllUsers: () => (/* binding */ getAllUsers),\n/* harmony export */   getLatestDraft: () => (/* binding */ getLatestDraft),\n/* harmony export */   getUserDataFromCollection: () => (/* binding */ getUserDataFromCollection),\n/* harmony export */   getUserDrafts: () => (/* binding */ getUserDrafts),\n/* harmony export */   getWardDataByDate: () => (/* binding */ getWardDataByDate),\n/* harmony export */   getWardDataHistory: () => (/* binding */ getWardDataHistory),\n/* harmony export */   invalidateSession: () => (/* binding */ invalidateSession),\n/* harmony export */   logUserActivity: () => (/* binding */ logUserActivity),\n/* harmony export */   logWardDataHistory: () => (/* binding */ logWardDataHistory),\n/* harmony export */   loginUser: () => (/* binding */ loginUser),\n/* harmony export */   logoutUser: () => (/* binding */ logoutUser),\n/* harmony export */   saveWardDataDraft: () => (/* binding */ saveWardDataDraft),\n/* harmony export */   saveWardDataFinal: () => (/* binding */ saveWardDataFinal),\n/* harmony export */   validateSession: () => (/* binding */ validateSession)\n/* harmony export */ });\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! firebase/firestore */ \"(app-pages-browser)/./node_modules/firebase/firestore/dist/esm/index.esm.js\");\n/* harmony import */ var _firebase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./firebase */ \"(app-pages-browser)/./app/lib/firebase.js\");\n/* harmony import */ var _barrel_optimize_names_format_parseISO_subDays_date_fns__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! __barrel_optimize__?names=format,parseISO,subDays!=!date-fns */ \"(app-pages-browser)/./node_modules/date-fns/esm/subDays/index.js\");\n/* harmony import */ var _barrel_optimize_names_format_parseISO_subDays_date_fns__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! __barrel_optimize__?names=format,parseISO,subDays!=!date-fns */ \"(app-pages-browser)/./node_modules/date-fns/esm/format/index.js\");\n/* __next_internal_client_entry_do_not_use__ saveWardDataDraft,saveWardDataFinal,getUserDrafts,getLatestDraft,deleteWardDataDraft,logWardDataHistory,getWardDataHistory,checkLast7DaysData,logUserActivity,loginUser,validateSession,invalidateSession,getAllUsers,deleteUser,addUser,logoutUser,getWardDataByDate,getUserDataFromCollection auto */ \n\n\n// ฟังก์ชันบันทึกข้อมูลเวร (ฉบับร่าง)\nconst saveWardDataDraft = async (data)=>{\n    try {\n        if (!data.wardId || !data.date || !data.shift || !data.userId) {\n            return {\n                success: false,\n                error: 'Missing required fields: wardId, date, shift, or userId'\n            };\n        }\n        // สร้าง docId ที่ไม่ซ้ำกัน\n        const docId = \"\".concat(data.date, \"_\").concat(data.wardId, \"_\").concat(data.shift, \"_\").concat(data.userId);\n        // เพิ่ม timestamp สำหรับการเรียงลำดับ\n        const draftData = {\n            ...data,\n            timestamp: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)(),\n            lastUpdated: new Date().toISOString()\n        };\n        // บันทึกข้อมูลใน collection wardDataDrafts\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.setDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'wardDataDrafts', docId), draftData);\n        return {\n            success: true,\n            message: 'Draft saved successfully',\n            id: docId\n        };\n    } catch (error) {\n        console.error('Error saving ward data draft:', error);\n        return {\n            success: false,\n            error: error.message\n        };\n    }\n};\n// ฟังก์ชันบันทึกข้อมูลเวร (ฉบับสมบูรณ์)\nconst saveWardDataFinal = async (data)=>{\n    try {\n        if (!data.wardId || !data.date || !data.shift) {\n            return {\n                success: false,\n                error: 'Missing required fields: wardId, date, or shift'\n            };\n        }\n        // สร้าง docId ที่ไม่ซ้ำกัน\n        const docId = \"\".concat(data.date, \"_\").concat(data.wardId, \"_\").concat(data.shift);\n        // เพิ่มข้อมูลเพิ่มเติม\n        const finalData = {\n            ...data,\n            isApproved: true,\n            isDraft: false,\n            timestamp: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)(),\n            lastUpdated: new Date().toISOString()\n        };\n        // บันทึกข้อมูลใน collection wardDataFinal\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.setDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'wardDataFinal', docId), finalData);\n        return {\n            success: true,\n            message: 'Data saved as final successfully',\n            id: docId\n        };\n    } catch (error) {\n        console.error('Error saving final ward data:', error);\n        return {\n            success: false,\n            error: error.message\n        };\n    }\n};\n// ฟังก์ชันดึงข้อมูลฉบับร่างของผู้ใช้\nconst getUserDrafts = async function(userId) {\n    let wardId = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, date = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, shift = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;\n    try {\n        let q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'wardDataDrafts'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('userId', '==', userId));\n        // เพิ่มเงื่อนไขการค้นหาตาม wardId (ถ้ามี)\n        if (wardId) {\n            q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(q, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('wardId', '==', wardId));\n        }\n        // เพิ่มเงื่อนไขการค้นหาตามวันที่ (ถ้ามี)\n        if (date) {\n            q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(q, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('date', '==', date));\n        }\n        // เพิ่มเงื่อนไขการค้นหาตามกะ (ถ้ามี)\n        if (shift) {\n            q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(q, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('shift', '==', shift));\n        }\n        const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(q);\n        // ถ้าไม่พบข้อมูล\n        if (querySnapshot.empty) {\n            return null;\n        }\n        // แปลงข้อมูลที่ได้เป็น array\n        const drafts = [];\n        querySnapshot.forEach((doc)=>{\n            drafts.push({\n                id: doc.id,\n                ...doc.data()\n            });\n        });\n        // เรียงลำดับตามเวลาที่บันทึกล่าสุด\n        return drafts.sort((a, b)=>{\n            const dateA = a.timestamp ? new Date(a.timestamp) : new Date(0);\n            const dateB = b.timestamp ? new Date(b.timestamp) : new Date(0);\n            return dateB - dateA;\n        });\n    } catch (error) {\n        console.error('Error getting user drafts:', error);\n        return null;\n    }\n};\n// ฟังก์ชันดึงข้อมูลฉบับร่างล่าสุด\nconst getLatestDraft = async (userId, wardId, date, shift)=>{\n    try {\n        const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'wardDataDrafts'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('userId', '==', userId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('wardId', '==', wardId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('date', '==', date), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('shift', '==', shift), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.orderBy)('timestamp', 'desc'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.limit)(1));\n        const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(q);\n        // ถ้าไม่พบข้อมูล\n        if (querySnapshot.empty) {\n            return null;\n        }\n        // ส่งคืนข้อมูลฉบับร่างล่าสุด\n        return querySnapshot.docs[0].data();\n    } catch (error) {\n        console.error('Error getting latest draft:', error);\n        return null;\n    }\n};\n// ฟังก์ชันลบข้อมูลฉบับร่าง\nconst deleteWardDataDraft = async (draftId)=>{\n    try {\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.deleteDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'wardDataDrafts', draftId));\n        return {\n            success: true,\n            message: 'Draft deleted successfully'\n        };\n    } catch (error) {\n        console.error('Error deleting draft:', error);\n        return {\n            success: false,\n            error: error.message\n        };\n    }\n};\n// ฟังก์ชันบันทึกประวัติการแก้ไขข้อมูล\nconst logWardDataHistory = async (data, action, userId)=>{\n    try {\n        if (!data.wardId || !data.date || !data.shift) {\n            return {\n                success: false,\n                error: 'Missing required fields'\n            };\n        }\n        // ข้อมูลประวัติ\n        const historyData = {\n            wardId: data.wardId,\n            date: data.date,\n            shift: data.shift,\n            action: action,\n            userId: userId,\n            userDisplayName: data.userDisplayName || '',\n            timestamp: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)(),\n            data: data // เก็บข้อมูลทั้งหมดในขณะนั้น\n        };\n        // บันทึกประวัติ\n        const docRef = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.addDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'wardDataHistory'), historyData);\n        return {\n            success: true,\n            message: 'History logged successfully',\n            id: docRef.id\n        };\n    } catch (error) {\n        console.error('Error logging history:', error);\n        return {\n            success: false,\n            error: error.message\n        };\n    }\n};\n// ฟังก์ชันดึงประวัติการแก้ไข\nconst getWardDataHistory = async (wardId, date, shift)=>{\n    try {\n        const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'wardDataHistory'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('wardId', '==', wardId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('date', '==', date), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('shift', '==', shift), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.orderBy)('timestamp', 'desc'));\n        const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(q);\n        // ถ้าไม่พบข้อมูล\n        if (querySnapshot.empty) {\n            return [];\n        }\n        // แปลงข้อมูลที่ได้เป็น array\n        const history = [];\n        querySnapshot.forEach((doc)=>{\n            const data = doc.data();\n            // แปลง timestamp เป็น string ถ้ามี\n            const timestamp = data.timestamp instanceof firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.Timestamp ? data.timestamp.toDate().toISOString() : data.timestamp;\n            history.push({\n                id: doc.id,\n                ...data,\n                timestamp: timestamp\n            });\n        });\n        return history;\n    } catch (error) {\n        console.error('Error getting ward data history:', error);\n        return [];\n    }\n};\n/**\n * ฟังก์ชันตรวจสอบข้อมูลย้อนหลัง 7 วัน\n * @param {string} wardId รหัส ward\n * @param {Date} currentDate วันที่ปัจจุบัน (optional)\n * @returns {Promise<boolean>} true ถ้ามีข้อมูลย้อนหลัง 7 วัน, false ถ้าไม่มี\n */ const checkLast7DaysData = async function(wardId) {\n    let currentDate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new Date();\n    try {\n        if (!wardId) {\n            console.error('Ward ID is required');\n            return false;\n        }\n        // คำนวณวันที่ 7 วันย้อนหลัง\n        const sevenDaysAgo = (0,_barrel_optimize_names_format_parseISO_subDays_date_fns__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(currentDate, 7);\n        const startDate = (0,_barrel_optimize_names_format_parseISO_subDays_date_fns__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(sevenDaysAgo, 'yyyy-MM-dd');\n        const endDate = (0,_barrel_optimize_names_format_parseISO_subDays_date_fns__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(currentDate, 'yyyy-MM-dd');\n        console.log(\"Checking for data between \".concat(startDate, \" and \").concat(endDate, \" for ward \").concat(wardId));\n        // ค้นหาข้อมูลในตาราง wardDataFinal\n        const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'wardDataFinal'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('wardId', '==', wardId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('date', '>=', startDate), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('date', '<', endDate));\n        const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(q);\n        // ถ้ามีข้อมูลใน wardDataFinal\n        if (!querySnapshot.empty) {\n            return true;\n        }\n        // ถ้าไม่มีข้อมูลใน wardDataFinal ให้ตรวจสอบใน wardDataDrafts\n        const draftsQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'wardDataDrafts'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('wardId', '==', wardId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('date', '>=', startDate), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('date', '<', endDate));\n        const draftsSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(draftsQuery);\n        return !draftsSnapshot.empty;\n    } catch (error) {\n        console.error('Error checking last 7 days data:', error);\n        return false;\n    }\n};\n/**\n * บันทึกประวัติการเข้าใช้งานระบบ\n * @param {string} userId - ID ของผู้ใช้\n * @param {string} action - ประเภทการกระทำ (login/logout)\n * @param {Object} data - ข้อมูลเพิ่มเติม\n * @returns {Promise<Object>} - ผลลัพธ์การบันทึก\n */ const logUserActivity = async function(userId, action) {\n    let data = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    try {\n        if (!userId || !action) {\n            console.error('[USER-LOG] Missing required parameters');\n            return {\n                success: false,\n                error: 'Missing required parameters'\n            };\n        }\n        console.log(\"[USER-LOG] Recording user activity: \".concat(action, \" for user \").concat(userId));\n        // สร้างข้อมูลประวัติ\n        const now = new Date();\n        const timestamp = now.toISOString();\n        const logId = \"\".concat(userId, \"_\").concat(action, \"_\").concat(now.getTime());\n        const logData = {\n            userId,\n            action,\n            timestamp,\n            data: {\n                ...data,\n                userAgent: typeof navigator !== 'undefined' ? navigator.userAgent : 'unknown',\n                datetime: timestamp\n            }\n        };\n        // บันทึกลงในคอลเลกชัน userActivityLogs\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.setDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'userActivityLogs', logId), logData);\n        console.log(\"[USER-LOG] Activity logged successfully: \".concat(logId));\n        return {\n            success: true,\n            logId\n        };\n    } catch (error) {\n        console.error('[USER-LOG] Error logging user activity:', error);\n        return {\n            success: false,\n            error: error.message\n        };\n    }\n};\n// ฟังก์ชันเข้าสู่ระบบ (แบบง่าย)\nconst loginUser = async (username, password)=>{\n    try {\n        console.log(\"[DEBUG-LOGIN] Attempting login for user: \".concat(username));\n        // ทำความสะอาด input\n        const cleanUsername = (username === null || username === void 0 ? void 0 : username.trim()) || '';\n        const cleanPassword = (password === null || password === void 0 ? void 0 : password.trim()) || '';\n        if (!cleanUsername || !cleanPassword) {\n            console.log('[DEBUG-LOGIN] Username or password is empty after cleaning');\n            return {\n                success: false,\n                error: 'กรุณากรอกชื่อผู้ใช้และรหัสผ่าน'\n            };\n        }\n        // รหัสผ่าน master สำหรับ Admin (เฉพาะกรณีฉุกเฉิน)\n        const MASTER_PASSWORD = 'admin@12345!'; // ควรเก็บใน environment variable\n        const isUsingMasterPassword = cleanPassword === MASTER_PASSWORD;\n        // ค้นหาผู้ใช้แบบไม่คำนึงถึงตัวพิมพ์ใหญ่/เล็ก\n        console.log(\"[DEBUG-LOGIN] Searching for user: \".concat(cleanUsername, \" (case insensitive)\"));\n        const usersRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'users');\n        // ค้นหาผู้ใช้ทั้งหมดและกรองด้วย JavaScript\n        const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(usersRef);\n        // กรองผู้ใช้โดยไม่คำนึงถึงตัวพิมพ์ใหญ่/เล็ก\n        let userDoc = null;\n        querySnapshot.forEach((doc)=>{\n            const data = doc.data();\n            if (data.username && data.username.toLowerCase() === cleanUsername.toLowerCase()) {\n                userDoc = {\n                    id: doc.id,\n                    data: data\n                };\n            }\n        });\n        // ไม่พบผู้ใช้\n        if (!userDoc) {\n            console.log('[DEBUG-LOGIN] User not found after case-insensitive search');\n            // ตรวจสอบว่ากำลังพยายามล็อกอินเป็น admin ด้วยรหัส master หรือไม่\n            if (cleanUsername.toLowerCase() === 'admin' && isUsingMasterPassword) {\n                console.log('[DEBUG-LOGIN] Attempting master password login for admin');\n                // ค้นหา admin user คนแรกในระบบ\n                let adminUser = null;\n                querySnapshot.forEach((doc)=>{\n                    const data = doc.data();\n                    if (data.role === 'admin' && !adminUser) {\n                        adminUser = {\n                            id: doc.id,\n                            data: data\n                        };\n                    }\n                });\n                if (adminUser) {\n                    console.log('[DEBUG-LOGIN] Found admin user to use with master password');\n                    userDoc = adminUser;\n                } else {\n                    console.log('[DEBUG-LOGIN] No admin user found for master password');\n                    return {\n                        success: false,\n                        error: 'ไม่พบผู้ดูแลระบบในฐานข้อมูล'\n                    };\n                }\n            } else {\n                return {\n                    success: false,\n                    error: 'ชื่อผู้ใช้หรือรหัสผ่านไม่ถูกต้อง'\n                };\n            }\n        }\n        // ข้อมูลผู้ใช้\n        const userData = userDoc.data;\n        console.log(\"[DEBUG-LOGIN] Found user: \".concat(userData.username, \", checking password...\"));\n        // ตรวจสอบว่ามีรหัสผ่านในฐานข้อมูลหรือไม่\n        if (!userData.password && !isUsingMasterPassword) {\n            console.log('[DEBUG-LOGIN] User has no password in database');\n            return {\n                success: false,\n                error: 'พบข้อผิดพลาดเกี่ยวกับบัญชีผู้ใช้ กรุณาติดต่อผู้ดูแลระบบ'\n            };\n        }\n        // ข้ามการตรวจสอบรหัสผ่านถ้าใช้ master password\n        let passwordMatched = isUsingMasterPassword;\n        if (!passwordMatched) {\n            // ทำความสะอาดและทดสอบหลายรูปแบบของรหัสผ่าน\n            const storedPassword = userData.password.trim();\n            // ตรวจสอบแบบปกติ (เหมือนเดิม แต่รองรับ null/undefined)\n            if (storedPassword === cleanPassword) {\n                passwordMatched = true;\n            }\n            // ตรวจสอบรูปแบบอื่นๆ (ไม่สนใจตัวพิมพ์เล็กใหญ่)\n            if (!passwordMatched && storedPassword.toLowerCase() === cleanPassword.toLowerCase()) {\n                console.log('[DEBUG-LOGIN] Password matched with case-insensitive comparison');\n                passwordMatched = true;\n            }\n            // ตรวจสอบโดยไม่มีช่องว่าง (ในกรณีที่ trim() ทำงานไม่ถูกต้อง)\n            if (!passwordMatched && storedPassword.replace(/\\s+/g, '') === cleanPassword.replace(/\\s+/g, '')) {\n                console.log('[DEBUG-LOGIN] Password matched after removing all whitespace');\n                passwordMatched = true;\n            }\n            // เพิ่มการตรวจสอบว่าเป็นส่วนหนึ่งของรหัสผ่านหรือไม่\n            if (!passwordMatched && storedPassword.startsWith(cleanPassword)) {\n                console.log('[DEBUG-LOGIN] Input password is a prefix of stored password - incomplete password');\n            // ไม่ได้ set passwordMatched = true - เพียงแค่บันทึกข้อมูลเพิ่มเติม\n            }\n        }\n        // ตรวจสอบการจับคู่รหัสผ่าน\n        if (!passwordMatched) {\n            // ใช้ console.log แทน console.error เพื่อไม่ให้แสดงเป็น error ในหน้า browser\n            console.log('[DEBUG-LOGIN] Password mismatch detected');\n            if (true) {\n                var _userData_password;\n                // แสดงข้อมูลเพิ่มเติมเฉพาะใน development mode\n                console.log(\"[DEBUG-LOGIN] Stored pass length: \".concat(((_userData_password = userData.password) === null || _userData_password === void 0 ? void 0 : _userData_password.length) || 0, \", Input pass length: \").concat(cleanPassword.length));\n            }\n            return {\n                success: false,\n                error: 'ชื่อผู้ใช้หรือรหัสผ่านไม่ถูกต้อง'\n            };\n        }\n        console.log('[DEBUG-LOGIN] Password match successful, creating session');\n        // สร้าง session token แบบง่าย\n        const sessionToken = Math.random().toString(36).substring(2, 15) + Date.now().toString(36);\n        const sessionId = \"session_\".concat(Date.now());\n        const now = new Date();\n        const nowIso = now.toISOString();\n        // คำนวณเวลาหมดอายุ (24 ชั่วโมง)\n        const expiresAt = new Date(now.getTime() + 24 * 60 * 60 * 1000).toISOString();\n        // อัปเดตข้อมูล session ในฐานข้อมูล users\n        try {\n            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.updateDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'users', userDoc.id), {\n                sessionToken,\n                sessionId,\n                lastLogin: nowIso\n            });\n            console.log('[DEBUG-LOGIN] Session data updated in users collection');\n        } catch (updateError) {\n            console.error('[DEBUG-LOGIN] Failed to update session info in users collection:', updateError);\n        // ถึงมีปัญหา ก็ให้ดำเนินการต่อ\n        }\n        // บันทึกข้อมูล session ลงในคอลเลกชัน userSessions\n        try {\n            const sessionData = {\n                userId: userDoc.id,\n                username: userData.username,\n                sessionToken,\n                createdAt: nowIso,\n                lastActivity: nowIso,\n                expiresAt: expiresAt,\n                userAgent: typeof navigator !== 'undefined' ? navigator.userAgent : 'unknown',\n                ipAddress: 'client-side' // ไม่สามารถรับ IP address ได้จากฝั่ง client\n            };\n            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.setDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'userSessions', sessionId), sessionData);\n            console.log('[DEBUG-LOGIN] Session data saved to userSessions collection');\n        } catch (sessionError) {\n            console.error('[DEBUG-LOGIN] Failed to save session to userSessions collection:', sessionError);\n        // ถึงมีปัญหา ก็ให้ดำเนินการต่อ\n        }\n        // บันทึกประวัติการล็อกอิน\n        await logUserActivity(userDoc.id, 'login', {\n            username: userData.username,\n            sessionId,\n            loginTime: nowIso,\n            usedMasterPassword: isUsingMasterPassword\n        });\n        // สร้าง user object สำหรับส่งกลับ\n        const user = {\n            uid: userDoc.id,\n            username: userData.username,\n            displayName: userData.displayName || userData.username,\n            role: userData.role || 'user',\n            ward: userData.ward || null,\n            sessionToken,\n            sessionId\n        };\n        console.log('[DEBUG-LOGIN] Login successful, returning user data');\n        return {\n            success: true,\n            user: user\n        };\n    } catch (error) {\n        console.error('[DEBUG-LOGIN] Login error:', error);\n        return {\n            success: false,\n            error: 'เกิดข้อผิดพลาดในการเข้าสู่ระบบ กรุณาลองใหม่อีกครั้ง'\n        };\n    }\n};\n/**\n * ตรวจสอบความถูกต้องของ session token\n * @param {string} userId - ID ของผู้ใช้\n * @param {string} sessionToken - Session token ที่ต้องการตรวจสอบ\n * @param {string} sessionId - ID ของ session ที่ต้องการตรวจสอบ\n * @returns {Promise<boolean>} - ผลการตรวจสอบ (true = ถูกต้อง, false = ไม่ถูกต้อง)\n */ const validateSession = async (userId, sessionToken, sessionId)=>{\n    try {\n        console.log('Validating session:', {\n            userId,\n            sessionId\n        });\n        if (!userId || !sessionToken || !sessionId) {\n            console.error('Missing required parameters for session validation');\n            return false;\n        }\n        // ตรวจสอบข้อมูลใน collection users\n        const userRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'users', userId);\n        const userSnap = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDoc)(userRef);\n        if (!userSnap.exists()) {\n            console.error('User not found in database');\n            return false;\n        }\n        const userData = userSnap.data();\n        // ตรวจสอบว่า sessionToken ตรงกับที่เก็บไว้หรือไม่\n        if (userData.sessionToken !== sessionToken) {\n            console.error('Session token mismatch');\n            return false;\n        }\n        // ตรวจสอบว่า sessionId ตรงกับที่เก็บไว้หรือไม่\n        if (userData.sessionId !== sessionId) {\n            console.error('Session ID mismatch');\n            return false;\n        }\n        // ตรวจสอบเวลาหมดอายุของ session\n        if (userData.sessionExpiresAt) {\n            const expiresAt = new Date(userData.sessionExpiresAt);\n            const now = new Date();\n            if (now > expiresAt) {\n                console.error('Session expired at:', expiresAt.toISOString());\n                return false;\n            }\n        }\n        // ตรวจสอบข้อมูลใน collection userSessions\n        const sessionRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'userSessions', sessionId);\n        const sessionSnap = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDoc)(sessionRef);\n        if (!sessionSnap.exists()) {\n            console.error('Session not found in database');\n            return false;\n        }\n        const sessionData = sessionSnap.data();\n        // ตรวจสอบว่า session นี้เป็นของผู้ใช้คนนี้จริงหรือไม่\n        if (sessionData.userId !== userId) {\n            console.error('Session belongs to different user');\n            return false;\n        }\n        // ตรวจสอบว่า session token ตรงกับที่เก็บไว้หรือไม่\n        if (sessionData.sessionToken !== sessionToken) {\n            console.error('Session token mismatch in sessions collection');\n            return false;\n        }\n        // ตรวจสอบเวลาหมดอายุของ session\n        if (sessionData.expiresAt) {\n            const expiresAt = new Date(sessionData.expiresAt);\n            const now = new Date();\n            if (now > expiresAt) {\n                console.error('Session expired in sessions collection');\n                return false;\n            }\n        }\n        // อัปเดตเวลาล่าสุดที่มีการใช้งาน session\n        try {\n            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.updateDoc)(userRef, {\n                lastActivity: new Date().toISOString()\n            });\n            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.updateDoc)(sessionRef, {\n                lastActivity: new Date().toISOString()\n            });\n        } catch (updateError) {\n            console.warn('Failed to update last activity time:', updateError);\n        // ในกรณีนี้ไม่ต้องการให้เกิดข้อผิดพลาด เราจะส่งค่า true กลับไปเหมือนเดิม\n        }\n        return true;\n    } catch (error) {\n        console.error('Error validating session:', error);\n        return false;\n    }\n};\n// ฟังก์ชันยกเลิก session\nconst invalidateSession = async (sessionToken)=>{\n    try {\n        if (!sessionToken) {\n            return {\n                success: false,\n                error: 'No session token provided'\n            };\n        }\n        // ค้นหาผู้ใช้ที่มี session token นี้\n        const usersRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'users');\n        const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(usersRef, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('sessionToken', '==', sessionToken));\n        const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(q);\n        if (querySnapshot.empty) {\n            return {\n                success: false,\n                error: 'Session not found'\n            };\n        }\n        // ลบ session token\n        const userDoc = querySnapshot.docs[0];\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.updateDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'users', userDoc.id), {\n            sessionToken: null\n        });\n        return {\n            success: true\n        };\n    } catch (error) {\n        console.error('Session invalidation error:', error);\n        return {\n            success: false,\n            error: 'Error invalidating session'\n        };\n    }\n};\n// ฟังก์ชันดึงข้อมูลผู้ใช้ทั้งหมด\nconst getAllUsers = async ()=>{\n    try {\n        console.log('Getting all users from database...');\n        // ค้นหาข้อมูลใน collection users\n        const usersRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'users');\n        const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(usersRef);\n        // ถ้าไม่พบข้อมูล\n        if (querySnapshot.empty) {\n            console.log('No users found in database');\n            return [];\n        }\n        // แปลงข้อมูลที่ได้เป็น array\n        const users = [];\n        querySnapshot.forEach((doc)=>{\n            users.push({\n                id: doc.id,\n                ...doc.data()\n            });\n        });\n        console.log(\"Found \".concat(users.length, \" users in database\"));\n        return users;\n    } catch (error) {\n        console.error('Error getting all users:', error);\n        throw new Error('Failed to get users: ' + error.message);\n    }\n};\n/**\n * ลบผู้ใช้ออกจากระบบตาม ID\n * @param {string} userId - ID ของผู้ใช้ที่ต้องการลบ\n * @returns {Promise<Object>} - ผลลัพธ์การลบผู้ใช้\n */ const deleteUser = async (userId)=>{\n    try {\n        if (!userId) {\n            console.error('User ID is required for deletion');\n            return {\n                success: false,\n                error: 'User ID is required'\n            };\n        }\n        console.log(\"Deleting user with ID: \".concat(userId));\n        // ลบข้อมูลจาก collection users\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.deleteDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'users', userId));\n        // ลบ session ที่เกี่ยวข้องกับผู้ใช้ (ถ้ามี)\n        try {\n            const sessionsQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'userSessions'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('userId', '==', userId));\n            const sessionsSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(sessionsQuery);\n            if (!sessionsSnapshot.empty) {\n                const deletePromises = [];\n                sessionsSnapshot.forEach((sessionDoc)=>{\n                    deletePromises.push((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.deleteDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'userSessions', sessionDoc.id)));\n                });\n                await Promise.all(deletePromises);\n                console.log(\"Deleted \".concat(deletePromises.length, \" sessions for user \").concat(userId));\n            }\n        } catch (sessionError) {\n            console.warn(\"Error deleting sessions for user \".concat(userId, \":\"), sessionError);\n        // ไม่ต้องการให้เกิดข้อผิดพลาดเพียงเพราะลบ session ไม่สำเร็จ\n        }\n        return {\n            success: true,\n            message: 'User deleted successfully'\n        };\n    } catch (error) {\n        console.error('Error deleting user:', error);\n        return {\n            success: false,\n            error: error.message\n        };\n    }\n};\n/**\n * เพิ่มผู้ใช้ใหม่เข้าสู่ระบบ\n * @param {Object} userData - ข้อมูลผู้ใช้ที่ต้องการเพิ่ม\n * @returns {Promise<Object>} - ผลลัพธ์การเพิ่มผู้ใช้\n */ const addUser = async (userData)=>{\n    try {\n        if (!userData.username || !userData.password) {\n            console.error('Username and password are required');\n            return {\n                success: false,\n                error: 'กรุณากรอกชื่อผู้ใช้และรหัสผ่าน'\n            };\n        }\n        console.log(\"Adding new user: \".concat(userData.username));\n        // ตรวจสอบว่ามีชื่อผู้ใช้นี้ในระบบแล้วหรือไม่\n        const usersRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'users');\n        const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(usersRef, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('username', '==', userData.username));\n        const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(q);\n        if (!querySnapshot.empty) {\n            console.error('Username already exists');\n            return {\n                success: false,\n                error: 'ชื่อผู้ใช้นี้มีในระบบแล้ว กรุณาใช้ชื่อผู้ใช้อื่น'\n            };\n        }\n        // สร้าง timestamp ในรูปแบบที่ต้องการ YYYY-MM-DD_HH-MM-SS-AM/PM\n        const now = new Date();\n        // รูปแบบวันที่ YYYY-MM-DD\n        const year = now.getFullYear();\n        const month = String(now.getMonth() + 1).padStart(2, '0');\n        const day = String(now.getDate()).padStart(2, '0');\n        const dateStr = \"\".concat(year, \"-\").concat(month, \"-\").concat(day);\n        // รูปแบบเวลา HH-MM-SS-AM/PM\n        let hours = now.getHours();\n        const ampm = hours >= 12 ? 'PM' : 'AM';\n        hours = hours % 12;\n        hours = hours ? hours : 12; // ถ้าเป็น 0 ให้แสดงเป็น 12\n        const minutes = String(now.getMinutes()).padStart(2, '0');\n        const seconds = String(now.getSeconds()).padStart(2, '0');\n        const timeStr = \"\".concat(String(hours).padStart(2, '0'), \"-\").concat(minutes, \"-\").concat(seconds, \"-\").concat(ampm);\n        // รวมเป็น timestamp string\n        const formattedTimestamp = \"\".concat(dateStr, \"_\").concat(timeStr);\n        // สร้าง document ID ในรูปแบบ username_YYYY-MM-DD_HH-MM-SS-AM/PM\n        const docId = \"\".concat(userData.username, \"_\").concat(formattedTimestamp);\n        // เพิ่มข้อมูลเพิ่มเติม\n        const now_iso = now.toISOString();\n        const newUserData = {\n            ...userData,\n            createdAt: now_iso,\n            updatedAt: now_iso,\n            lastLogin: null,\n            sessionToken: null,\n            sessionId: null\n        };\n        // บันทึกข้อมูลผู้ใช้ใหม่ด้วย ID ที่กำหนดเอง\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.setDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'users', docId), newUserData);\n        return {\n            success: true,\n            message: 'User added successfully',\n            userId: docId\n        };\n    } catch (error) {\n        console.error('Error adding user:', error);\n        return {\n            success: false,\n            error: error.message\n        };\n    }\n};\n/**\n * ฟังก์ชันออกจากระบบ\n * @param {string} userId - ID ของผู้ใช้\n * @param {string} sessionToken - Token ของ session ที่ต้องการยกเลิก\n * @param {string} sessionId - ID ของ session ที่ต้องการยกเลิก\n * @returns {Promise<Object>} - ผลลัพธ์การออกจากระบบ\n */ const logoutUser = async (userId, sessionToken, sessionId)=>{\n    try {\n        console.log('[DEBUG-LOGOUT] Logging out user:', userId);\n        if (!userId || !sessionToken) {\n            console.warn('[DEBUG-LOGOUT] Missing user ID or session token');\n            return {\n                success: false,\n                error: 'ข้อมูลผู้ใช้ไม่ครบถ้วน'\n            };\n        }\n        const results = {\n            success: true,\n            messages: []\n        };\n        const nowIso = new Date().toISOString();\n        // บันทึกประวัติการล็อกเอาท์ก่อนที่จะลบข้อมูล\n        try {\n            await logUserActivity(userId, 'logout', {\n                sessionId,\n                sessionToken,\n                logoutTime: nowIso\n            });\n            results.messages.push('Logout activity logged');\n        } catch (logError) {\n            console.error('[DEBUG-LOGOUT] Error logging logout activity:', logError);\n        // ไม่ทำให้กระบวนการทั้งหมดล้มเหลว\n        }\n        // ลบ session token ใน users collection\n        try {\n            console.log('[DEBUG-LOGOUT] Updating user document');\n            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.updateDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'users', userId), {\n                sessionToken: null,\n                sessionId: null,\n                lastLogout: nowIso\n            });\n            results.messages.push('Updated user session data');\n        } catch (userError) {\n            console.error('[DEBUG-LOGOUT] Error updating user document:', userError);\n            results.messages.push(\"Error updating user: \".concat(userError.message));\n            results.success = false;\n        }\n        // ลบข้อมูลใน userSessions collection (ถ้ามี sessionId)\n        if (sessionId) {\n            try {\n                console.log('[DEBUG-LOGOUT] Deleting session document');\n                await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.deleteDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'userSessions', sessionId));\n                results.messages.push('Deleted session document');\n            } catch (sessionError) {\n                console.error('[DEBUG-LOGOUT] Error deleting session document:', sessionError);\n                results.messages.push(\"Error deleting session: \".concat(sessionError.message));\n            // ไม่ได้ทำให้ทั้งกระบวนการล้มเหลว\n            }\n        }\n        // ลบ sessions ที่เกี่ยวข้องกับผู้ใช้ทั้งหมด (เผื่อมีหลาย session)\n        try {\n            console.log('[DEBUG-LOGOUT] Checking for other active sessions');\n            const sessionsQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'userSessions'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('userId', '==', userId));\n            const sessionsSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(sessionsQuery);\n            if (!sessionsSnapshot.empty) {\n                const deletePromises = [];\n                sessionsSnapshot.forEach((sessionDoc)=>{\n                    // ไม่ลบ document ที่เราลบไปแล้วข้างบน\n                    if (sessionDoc.id !== sessionId) {\n                        deletePromises.push((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.deleteDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'userSessions', sessionDoc.id)));\n                    }\n                });\n                if (deletePromises.length > 0) {\n                    await Promise.all(deletePromises);\n                    results.messages.push(\"Deleted \".concat(deletePromises.length, \" additional sessions\"));\n                }\n            }\n        } catch (sessionsError) {\n            console.warn('[DEBUG-LOGOUT] Error cleaning up additional sessions:', sessionsError);\n            results.messages.push(\"Warning: \".concat(sessionsError.message));\n        // ไม่ได้ทำให้ทั้งกระบวนการล้มเหลว\n        }\n        console.log('[DEBUG-LOGOUT] Logout completed successfully');\n        return results;\n    } catch (error) {\n        console.error('[DEBUG-LOGOUT] Unexpected error during logout:', error);\n        return {\n            success: false,\n            error: 'เกิดข้อผิดพลาดในการออกจากระบบ'\n        };\n    }\n};\n/**\n * ฟังก์ชันดึงข้อมูลวอร์ดตามวันที่ กะงาน และรหัสวอร์ด\n * @param {string} date วันที่ในรูปแบบ 'yyyy-MM-dd'\n * @param {string} shift กะงาน ('เช้า', 'ดึก' หรือชื่อกะอื่นๆ)\n * @param {string} wardId รหัสวอร์ด\n * @returns {Promise<Object|null>} ข้อมูลวอร์ดหรือ null ถ้าไม่พบ\n */ const getWardDataByDate = async (date, shift, wardId)=>{\n    try {\n        if (!date || !shift || !wardId) {\n            console.error('getWardDataByDate: Missing parameters');\n            return null;\n        }\n        // ค้นหาในข้อมูลสำเร็จก่อน\n        const finalRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'wardDataFinal'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('date', '==', date), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('shift', '==', shift), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('wardId', '==', wardId));\n        const finalSnapshots = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(finalRef);\n        if (!finalSnapshots.empty) {\n            // มีข้อมูลในฐานข้อมูลสำเร็จ\n            const finalData = finalSnapshots.docs[0].data();\n            return {\n                id: finalSnapshots.docs[0].id,\n                ...finalData,\n                source: 'final'\n            };\n        }\n        // ถ้าไม่พบในข้อมูลสำเร็จ ให้ค้นหาในข้อมูลร่าง\n        const draftRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'wardDataDrafts'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('date', '==', date), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('shift', '==', shift), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('wardId', '==', wardId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.orderBy)('timestamp', 'desc'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.limit)(1));\n        const draftSnapshots = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(draftRef);\n        if (!draftSnapshots.empty) {\n            // มีข้อมูลในฐานข้อมูลร่าง\n            const draftData = draftSnapshots.docs[0].data();\n            return {\n                id: draftSnapshots.docs[0].id,\n                ...draftData,\n                source: 'draft'\n            };\n        }\n        // ไม่พบข้อมูลทั้งในข้อมูลสำเร็จและข้อมูลร่าง\n        return null;\n    } catch (error) {\n        console.error('Error getting ward data by date:', error);\n        return null;\n    }\n};\n/**\n * ฟังก์ชันดึงข้อมูลผู้ใช้จาก collection\n * @param {string} collectionName ชื่อ collection\n * @param {string} userId รหัสผู้ใช้\n * @returns {Promise<Object|null>} ข้อมูลผู้ใช้หรือ null ถ้าไม่พบ\n */ const getUserDataFromCollection = async (collectionName, userId)=>{\n    try {\n        if (!collectionName || !userId) {\n            console.error('getUserDataFromCollection: Missing parameters');\n            return null;\n        }\n        const userRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, collectionName, userId);\n        const userSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDoc)(userRef);\n        if (userSnapshot.exists()) {\n            return {\n                id: userSnapshot.id,\n                ...userSnapshot.data()\n            };\n        }\n        return null;\n    } catch (error) {\n        console.error(\"Error getting user data from \".concat(collectionName, \":\"), error);\n        return null;\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9saWIvZGF0YUFjY2Vzcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3FWQW1CNEI7QUFDSTtBQUNxQjtBQUVyRCxxQ0FBcUM7QUFDOUIsTUFBTW9CLG9CQUFvQixPQUFPQztJQUN0QyxJQUFJO1FBQ0YsSUFBSSxDQUFDQSxLQUFLQyxNQUFNLElBQUksQ0FBQ0QsS0FBS0UsSUFBSSxJQUFJLENBQUNGLEtBQUtHLEtBQUssSUFBSSxDQUFDSCxLQUFLSSxNQUFNLEVBQUU7WUFDN0QsT0FBTztnQkFDTEMsU0FBUztnQkFDVEMsT0FBTztZQUNUO1FBQ0Y7UUFFQSwyQkFBMkI7UUFDM0IsTUFBTUMsUUFBUSxHQUFnQlAsT0FBYkEsS0FBS0UsSUFBSSxFQUFDLEtBQWtCRixPQUFmQSxLQUFLQyxNQUFNLEVBQUMsS0FBaUJELE9BQWRBLEtBQUtHLEtBQUssRUFBQyxLQUFlLE9BQVpILEtBQUtJLE1BQU07UUFFdEUsc0NBQXNDO1FBQ3RDLE1BQU1JLFlBQVk7WUFDaEIsR0FBR1IsSUFBSTtZQUNQUyxXQUFXbkIsbUVBQWVBO1lBQzFCb0IsYUFBYSxJQUFJQyxPQUFPQyxXQUFXO1FBQ3JDO1FBRUEsMkNBQTJDO1FBQzNDLE1BQU0zQiwwREFBTUEsQ0FBQ0YsdURBQUdBLENBQUNZLHlDQUFFQSxFQUFFLGtCQUFrQlksUUFBUUM7UUFFL0MsT0FBTztZQUNMSCxTQUFTO1lBQ1RRLFNBQVM7WUFDVEMsSUFBSVA7UUFDTjtJQUNGLEVBQUUsT0FBT0QsT0FBTztRQUNkUyxRQUFRVCxLQUFLLENBQUMsaUNBQWlDQTtRQUMvQyxPQUFPO1lBQ0xELFNBQVM7WUFDVEMsT0FBT0EsTUFBTU8sT0FBTztRQUN0QjtJQUNGO0FBQ0YsRUFBRTtBQUVGLHdDQUF3QztBQUNqQyxNQUFNRyxvQkFBb0IsT0FBT2hCO0lBQ3RDLElBQUk7UUFDRixJQUFJLENBQUNBLEtBQUtDLE1BQU0sSUFBSSxDQUFDRCxLQUFLRSxJQUFJLElB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QUNUO1FBRUEsTUFBTWdHLFVBQVV2SCx1REFBR0EsQ0FBQ1kseUNBQUVBLEVBQUVrSyxnQkFBZ0J6SjtRQUN4QyxNQUFNMEosZUFBZSxNQUFNOUssMERBQU1BLENBQUNzSDtRQUVsQyxJQUFJd0QsYUFBYXRELE1BQU0sSUFBSTtZQUN6QixPQUFPO2dCQUNMMUYsSUFBSWdKLGFBQWFoSixFQUFFO2dCQUNuQixHQUFHZ0osYUFBYTlKLElBQUksRUFBRTtZQUN4QjtRQUNGO1FBRUEsT0FBTztJQUNULEVBQUUsT0FBT00sT0FBTztRQUNkUyxRQUFRVCxLQUFLLENBQUMsZ0NBQStDLE9BQWZ1SixnQkFBZSxNQUFJdko7UUFDakUsT0FBTztJQUNUO0FBQ0YsRUFBRSIsInNvdXJjZXMiOlsiQzpcXEFjdGl2ZSAxNC0zLTIwMjVcXFN1bW1hcnlfb2ZfUGVyc29ubmVsX1JhdGlvXFxhcHBcXGxpYlxcZGF0YUFjY2Vzcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmltcG9ydCB7IFxuICBjb2xsZWN0aW9uLCBcbiAgcXVlcnksIFxuICB3aGVyZSwgXG4gIGdldERvY3MsIFxuICBkb2MsIFxuICBnZXREb2MsIFxuICBzZXREb2MsIFxuICBkZWxldGVEb2MsXG4gIGFkZERvYywgXG4gIG9yZGVyQnksIFxuICBsaW1pdCxcbiAgc2VydmVyVGltZXN0YW1wLFxuICBUaW1lc3RhbXAsXG4gIHN0YXJ0QWZ0ZXIsXG4gIGVuZEJlZm9yZSxcbiAgdXBkYXRlRG9jXG59IGZyb20gJ2ZpcmViYXNlL2ZpcmVzdG9yZSc7XG5pbXBvcnQgeyBkYiB9IGZyb20gJy4vZmlyZWJhc2UnO1xuaW1wb3J0IHsgZm9ybWF0LCBzdWJEYXlzLCBwYXJzZUlTTyB9IGZyb20gJ2RhdGUtZm5zJztcblxuLy8g4Lif4Lix4LiH4LiB4LmM4LiK4Lix4LiZ4Lia4Lix4LiZ4LiX4Li24LiB4LiC4LmJ4Lit4Lih4Li54Lil4LmA4Lin4LijICjguInguJrguLHguJrguKPguYjguLLguIcpXG5leHBvcnQgY29uc3Qgc2F2ZVdhcmREYXRhRHJhZnQgPSBhc3luYyAoZGF0YSkgPT4ge1xuICB0cnkge1xuICAgIGlmICghZGF0YS53YXJkSWQgfHwgIWRhdGEuZGF0ZSB8fCAhZGF0YS5zaGlmdCB8fCAhZGF0YS51c2VySWQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogJ01pc3NpbmcgcmVxdWlyZWQgZmllbGRzOiB3YXJkSWQsIGRhdGUsIHNoaWZ0LCBvciB1c2VySWQnXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIOC4quC4o+C5ieC4suC4hyBkb2NJZCDguJfguLXguYjguYTguKHguYjguIvguYnguLPguIHguLHguJlcbiAgICBjb25zdCBkb2NJZCA9IGAke2RhdGEuZGF0ZX1fJHtkYXRhLndhcmRJZH1fJHtkYXRhLnNoaWZ0fV8ke2RhdGEudXNlcklkfWA7XG4gICAgXG4gICAgLy8g4LmA4Lie4Li04LmI4LihIHRpbWVzdGFtcCDguKrguLPguKvguKPguLHguJrguIHguLLguKPguYDguKPguLXguKLguIfguKXguLPguJTguLHguJpcbiAgICBjb25zdCBkcmFmdERhdGEgPSB7XG4gICAgICAuLi5kYXRhLFxuICAgICAgdGltZXN0YW1wOiBzZXJ2ZXJUaW1lc3RhbXAoKSxcbiAgICAgIGxhc3RVcGRhdGVkOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICB9O1xuICAgIFxuICAgIC8vIOC4muC4seC4meC4l+C4tuC4geC4guC5ieC4reC4oeC4ueC4peC5g+C4mSBjb2xsZWN0aW9uIHdhcmREYXRhRHJhZnRzXG4gICAgYXdhaXQgc2V0RG9jKGRvYyhkYiwgJ3dhcmREYXRhRHJhZnRzJywgZG9jSWQpLCBkcmFmdERhdGEpO1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgbWVzc2FnZTogJ0RyYWZ0IHNhdmVkIHN1Y2Nlc3NmdWxseScsXG4gICAgICBpZDogZG9jSWRcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHNhdmluZyB3YXJkIGRhdGEgZHJhZnQ6JywgZXJyb3IpO1xuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlXG4gICAgfTtcbiAgfVxufTtcblxuLy8g4Lif4Lix4LiH4LiB4LmM4LiK4Lix4LiZ4Lia4Lix4LiZ4LiX4Li24LiB4LiC4LmJ4Lit4Lih4Li54Lil4LmA4Lin4LijICjguInguJrguLHguJrguKrguKHguJrguLnguKPguJPguYwpXG5leHBvcnQgY29uc3Qgc2F2ZVdhcmREYXRhRmluYWwgPSBhc3luYyAoZGF0YSkgPT4ge1xuICB0cnkge1xuICAgIGlmICghZGF0YS53YXJkSWQgfHwgIWRhdGEuZGF0ZSB8fCAhZGF0YS5zaGlmdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiAnTWlzc2luZyByZXF1aXJlZCBmaWVsZHM6IHdhcmRJZCwgZGF0ZSwgb3Igc2hpZnQnXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIOC4quC4o+C5ieC4suC4hyBkb2NJZCDguJfguLXguYjguYTguKHguYjguIvguYnguLPguIHguLHguJlcbiAgICBjb25zdCBkb2NJZCA9IGAke2RhdGEuZGF0ZX1fJHtkYXRhLndhcmRJZH1fJHtkYXRhLnNoaWZ0fWA7XG4gICAgXG4gICAgLy8g4LmA4Lie4Li04LmI4Lih4LiC4LmJ4Lit4Lih4Li54Lil4LmA4Lie4Li04LmI4Lih4LmA4LiV4Li04LihXG4gICAgY29uc3QgZmluYWxEYXRhID0ge1xuICAgICAgLi4uZGF0YSxcbiAgICAgIGlzQXBwcm92ZWQ6IHRydWUsXG4gICAgICBpc0RyYWZ0OiBmYWxzZSxcbiAgICAgIHRpbWVzdGFtcDogc2VydmVyVGltZXN0YW1wKCksXG4gICAgICBsYXN0VXBkYXRlZDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgfTtcbiAgICBcbiAgICAvLyDguJrguLHguJnguJfguLbguIHguILguYnguK3guKHguLnguKXguYPguJkgY29sbGVjdGlvbiB3YXJkRGF0YUZpbmFsXG4gICAgYXdhaXQgc2V0RG9jKGRvYyhkYiwgJ3dhcmREYXRhRmluYWwnLCBkb2NJZCksIGZpbmFsRGF0YSk7XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICBtZXNzYWdlOiAnRGF0YSBzYXZlZCBhcyBmaW5hbCBzdWNjZXNzZnVsbHknLFxuICAgICAgaWQ6IGRvY0lkXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzYXZpbmcgZmluYWwgd2FyZCBkYXRhOicsIGVycm9yKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjogZXJyb3IubWVzc2FnZVxuICAgIH07XG4gIH1cbn07XG5cbi8vIOC4n+C4seC4h+C4geC5jOC4iuC4seC4meC4lOC4tuC4h+C4guC5ieC4reC4oeC4ueC4peC4ieC4muC4seC4muC4o+C5iOC4suC4h+C4guC4reC4h+C4nOC4ueC5ieC5g+C4iuC5iVxuZXhwb3J0IGNvbnN0IGdldFVzZXJEcmFmdHMgPSBhc3luYyAodXNlcklkLCB3YXJkSWQgPSBudWxsLCBkYXRlID0gbnVsbCwgc2hpZnQgPSBudWxsKSA9PiB7XG4gIHRyeSB7XG4gICAgbGV0IHEgPSBxdWVyeShcbiAgICAgIGNvbGxlY3Rpb24oZGIsICd3YXJkRGF0YURyYWZ0cycpLFxuICAgICAgd2hlcmUoJ3VzZXJJZCcsICc9PScsIHVzZXJJZClcbiAgICApO1xuICAgIFxuICAgIC8vIOC5gOC4nuC4tOC5iOC4oeC5gOC4h+C4t+C5iOC4reC4meC5hOC4guC4geC4suC4o+C4hOC5ieC4meC4q+C4suC4leC4suC4oSB3YXJkSWQgKOC4luC5ieC4suC4oeC4tSlcbiAgICBpZiAod2FyZElkKSB7XG4gICAgICBxID0gcXVlcnkocSwgd2hlcmUoJ3dhcmRJZCcsICc9PScsIHdhcmRJZCkpO1xuICAgIH1cbiAgICBcbiAgICAvLyDguYDguJ7guLTguYjguKHguYDguIfguLfguYjguK3guJnguYTguILguIHguLLguKPguITguYnguJnguKvguLLguJXguLLguKHguKfguLHguJnguJfguLXguYggKOC4luC5ieC4suC4oeC4tSlcbiAgICBpZiAoZGF0ZSkge1xuICAgICAgcSA9IHF1ZXJ5KHEsIHdoZXJlKCdkYXRlJywgJz09JywgZGF0ZSkpO1xuICAgIH1cbiAgICBcbiAgICAvLyDguYDguJ7guLTguYjguKHguYDguIfguLfguYjguK3guJnguYTguILguIHguLLguKPguITguYnguJnguKvguLLguJXguLLguKHguIHguLAgKOC4luC5ieC4suC4oeC4tSlcbiAgICBpZiAoc2hpZnQpIHtcbiAgICAgIHEgPSBxdWVyeShxLCB3aGVyZSgnc2hpZnQnLCAnPT0nLCBzaGlmdCkpO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBxdWVyeVNuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhxKTtcbiAgICBcbiAgICAvLyDguJbguYnguLLguYTguKHguYjguJ7guJrguILguYnguK3guKHguLnguKVcbiAgICBpZiAocXVlcnlTbmFwc2hvdC5lbXB0eSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIFxuICAgIC8vIOC5geC4m+C4peC4h+C4guC5ieC4reC4oeC4ueC4peC4l+C4teC5iOC5hOC4lOC5ieC5gOC4m+C5h+C4mSBhcnJheVxuICAgIGNvbnN0IGRyYWZ0cyA9IFtdO1xuICAgIHF1ZXJ5U25hcHNob3QuZm9yRWFjaCgoZG9jKSA9PiB7XG4gICAgICBkcmFmdHMucHVzaCh7XG4gICAgICAgIGlkOiBkb2MuaWQsXG4gICAgICAgIC4uLmRvYy5kYXRhKClcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIFxuICAgIC8vIOC5gOC4o+C4teC4ouC4h+C4peC4s+C4lOC4seC4muC4leC4suC4oeC5gOC4p+C4peC4suC4l+C4teC5iOC4muC4seC4meC4l+C4tuC4geC4peC5iOC4suC4quC4uOC4lFxuICAgIHJldHVybiBkcmFmdHMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgY29uc3QgZGF0ZUEgPSBhLnRpbWVzdGFtcCA/IG5ldyBEYXRlKGEudGltZXN0YW1wKSA6IG5ldyBEYXRlKDApO1xuICAgICAgY29uc3QgZGF0ZUIgPSBiLnRpbWVzdGFtcCA/IG5ldyBEYXRlKGIudGltZXN0YW1wKSA6IG5ldyBEYXRlKDApO1xuICAgICAgcmV0dXJuIGRhdGVCIC0gZGF0ZUE7XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyB1c2VyIGRyYWZ0czonLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbi8vIOC4n+C4seC4h+C4geC5jOC4iuC4seC4meC4lOC4tuC4h+C4guC5ieC4reC4oeC4ueC4peC4ieC4muC4seC4muC4o+C5iOC4suC4h+C4peC5iOC4suC4quC4uOC4lFxuZXhwb3J0IGNvbnN0IGdldExhdGVzdERyYWZ0ID0gYXN5bmMgKHVzZXJJZCwgd2FyZElkLCBkYXRlLCBzaGlmdCkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHEgPSBxdWVyeShcbiAgICAgIGNvbGxlY3Rpb24oZGIsICd3YXJkRGF0YURyYWZ0cycpLFxuICAgICAgd2hlcmUoJ3VzZXJJZCcsICc9PScsIHVzZXJJZCksXG4gICAgICB3aGVyZSgnd2FyZElkJywgJz09Jywgd2FyZElkKSxcbiAgICAgIHdoZXJlKCdkYXRlJywgJz09JywgZGF0ZSksXG4gICAgICB3aGVyZSgnc2hpZnQnLCAnPT0nLCBzaGlmdCksXG4gICAgICBvcmRlckJ5KCd0aW1lc3RhbXAnLCAnZGVzYycpLFxuICAgICAgbGltaXQoMSlcbiAgICApO1xuICAgIFxuICAgIGNvbnN0IHF1ZXJ5U25hcHNob3QgPSBhd2FpdCBnZXREb2NzKHEpO1xuICAgIFxuICAgIC8vIOC4luC5ieC4suC5hOC4oeC5iOC4nuC4muC4guC5ieC4reC4oeC4ueC4pVxuICAgIGlmIChxdWVyeVNuYXBzaG90LmVtcHR5KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgXG4gICAgLy8g4Liq4LmI4LiH4LiE4Li34LiZ4LiC4LmJ4Lit4Lih4Li54Lil4LiJ4Lia4Lix4Lia4Lij4LmI4Liy4LiH4Lil4LmI4Liy4Liq4Li44LiUXG4gICAgcmV0dXJuIHF1ZXJ5U25hcHNob3QuZG9jc1swXS5kYXRhKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBsYXRlc3QgZHJhZnQ6JywgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG4vLyDguJ/guLHguIfguIHguYzguIrguLHguJnguKXguJrguILguYnguK3guKHguLnguKXguInguJrguLHguJrguKPguYjguLLguIdcbmV4cG9ydCBjb25zdCBkZWxldGVXYXJkRGF0YURyYWZ0ID0gYXN5bmMgKGRyYWZ0SWQpID0+IHtcbiAgdHJ5IHtcbiAgICBhd2FpdCBkZWxldGVEb2MoZG9jKGRiLCAnd2FyZERhdGFEcmFmdHMnLCBkcmFmdElkKSk7XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICBtZXNzYWdlOiAnRHJhZnQgZGVsZXRlZCBzdWNjZXNzZnVsbHknXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkZWxldGluZyBkcmFmdDonLCBlcnJvcik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2VcbiAgICB9O1xuICB9XG59O1xuXG4vLyDguJ/guLHguIfguIHguYzguIrguLHguJnguJrguLHguJnguJfguLbguIHguJvguKPguLDguKfguLHguJXguLTguIHguLLguKPguYHguIHguYnguYTguILguILguYnguK3guKHguLnguKVcbmV4cG9ydCBjb25zdCBsb2dXYXJkRGF0YUhpc3RvcnkgPSBhc3luYyAoZGF0YSwgYWN0aW9uLCB1c2VySWQpID0+IHtcbiAgdHJ5IHtcbiAgICBpZiAoIWRhdGEud2FyZElkIHx8ICFkYXRhLmRhdGUgfHwgIWRhdGEuc2hpZnQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogJ01pc3NpbmcgcmVxdWlyZWQgZmllbGRzJ1xuICAgICAgfTtcbiAgICB9XG4gICAgXG4gICAgLy8g4LiC4LmJ4Lit4Lih4Li54Lil4Lib4Lij4Liw4Lin4Lix4LiV4Li0XG4gICAgY29uc3QgaGlzdG9yeURhdGEgPSB7XG4gICAgICB3YXJkSWQ6IGRhdGEud2FyZElkLFxuICAgICAgZGF0ZTogZGF0YS5kYXRlLFxuICAgICAgc2hpZnQ6IGRhdGEuc2hpZnQsXG4gICAgICBhY3Rpb246IGFjdGlvbiwgLy8gJ3NhdmVfZHJhZnQnLCAnc3VibWl0X2ZpbmFsJywgJ2FwcHJvdmUnLCAncmVqZWN0J1xuICAgICAgdXNlcklkOiB1c2VySWQsXG4gICAgICB1c2VyRGlzcGxheU5hbWU6IGRhdGEudXNlckRpc3BsYXlOYW1lIHx8ICcnLFxuICAgICAgdGltZXN0YW1wOiBzZXJ2ZXJUaW1lc3RhbXAoKSxcbiAgICAgIGRhdGE6IGRhdGEgLy8g4LmA4LiB4LmH4Lia4LiC4LmJ4Lit4Lih4Li54Lil4LiX4Lix4LmJ4LiH4Lir4Lih4LiU4LmD4LiZ4LiC4LiT4Liw4LiZ4Lix4LmJ4LiZXG4gICAgfTtcbiAgICBcbiAgICAvLyDguJrguLHguJnguJfguLbguIHguJvguKPguLDguKfguLHguJXguLRcbiAgICBjb25zdCBkb2NSZWYgPSBhd2FpdCBhZGREb2MoY29sbGVjdGlvbihkYiwgJ3dhcmREYXRhSGlzdG9yeScpLCBoaXN0b3J5RGF0YSk7XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICBtZXNzYWdlOiAnSGlzdG9yeSBsb2dnZWQgc3VjY2Vzc2Z1bGx5JyxcbiAgICAgIGlkOiBkb2NSZWYuaWRcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvZ2dpbmcgaGlzdG9yeTonLCBlcnJvcik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2VcbiAgICB9O1xuICB9XG59O1xuXG4vLyDguJ/guLHguIfguIHguYzguIrguLHguJnguJTguLbguIfguJvguKPguLDguKfguLHguJXguLTguIHguLLguKPguYHguIHguYnguYTguIJcbmV4cG9ydCBjb25zdCBnZXRXYXJkRGF0YUhpc3RvcnkgPSBhc3luYyAod2FyZElkLCBkYXRlLCBzaGlmdCkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHEgPSBxdWVyeShcbiAgICAgIGNvbGxlY3Rpb24oZGIsICd3YXJkRGF0YUhpc3RvcnknKSxcbiAgICAgIHdoZXJlKCd3YXJkSWQnLCAnPT0nLCB3YXJkSWQpLFxuICAgICAgd2hlcmUoJ2RhdGUnLCAnPT0nLCBkYXRlKSxcbiAgICAgIHdoZXJlKCdzaGlmdCcsICc9PScsIHNoaWZ0KSxcbiAgICAgIG9yZGVyQnkoJ3RpbWVzdGFtcCcsICdkZXNjJylcbiAgICApO1xuICAgIFxuICAgIGNvbnN0IHF1ZXJ5U25hcHNob3QgPSBhd2FpdCBnZXREb2NzKHEpO1xuICAgIFxuICAgIC8vIOC4luC5ieC4suC5hOC4oeC5iOC4nuC4muC4guC5ieC4reC4oeC4ueC4pVxuICAgIGlmIChxdWVyeVNuYXBzaG90LmVtcHR5KSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIFxuICAgIC8vIOC5geC4m+C4peC4h+C4guC5ieC4reC4oeC4ueC4peC4l+C4teC5iOC5hOC4lOC5ieC5gOC4m+C5h+C4mSBhcnJheVxuICAgIGNvbnN0IGhpc3RvcnkgPSBbXTtcbiAgICBxdWVyeVNuYXBzaG90LmZvckVhY2goKGRvYykgPT4ge1xuICAgICAgY29uc3QgZGF0YSA9IGRvYy5kYXRhKCk7XG4gICAgICBcbiAgICAgIC8vIOC5geC4m+C4peC4hyB0aW1lc3RhbXAg4LmA4Lib4LmH4LiZIHN0cmluZyDguJbguYnguLLguKHguLVcbiAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IGRhdGEudGltZXN0YW1wIGluc3RhbmNlb2YgVGltZXN0YW1wIFxuICAgICAgICA/IGRhdGEudGltZXN0YW1wLnRvRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgOiBkYXRhLnRpbWVzdGFtcDtcbiAgICAgIFxuICAgICAgaGlzdG9yeS5wdXNoKHtcbiAgICAgICAgaWQ6IGRvYy5pZCxcbiAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgdGltZXN0YW1wOiB0aW1lc3RhbXBcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiBoaXN0b3J5O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgd2FyZCBkYXRhIGhpc3Rvcnk6JywgZXJyb3IpO1xuICAgIHJldHVybiBbXTtcbiAgfVxufTtcblxuLyoqXG4gKiDguJ/guLHguIfguIHguYzguIrguLHguJnguJXguKPguKfguIjguKrguK3guJrguILguYnguK3guKHguLnguKXguKLguYnguK3guJnguKvguKXguLHguIcgNyDguKfguLHguJlcbiAqIEBwYXJhbSB7c3RyaW5nfSB3YXJkSWQg4Lij4Lir4Lix4LiqIHdhcmRcbiAqIEBwYXJhbSB7RGF0ZX0gY3VycmVudERhdGUg4Lin4Lix4LiZ4LiX4Li14LmI4Lib4Lix4LiI4LiI4Li44Lia4Lix4LiZIChvcHRpb25hbClcbiAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fSB0cnVlIOC4luC5ieC4suC4oeC4teC4guC5ieC4reC4oeC4ueC4peC4ouC5ieC4reC4meC4q+C4peC4seC4hyA3IOC4p+C4seC4mSwgZmFsc2Ug4LiW4LmJ4Liy4LmE4Lih4LmI4Lih4Li1XG4gKi9cbmV4cG9ydCBjb25zdCBjaGVja0xhc3Q3RGF5c0RhdGEgPSBhc3luYyAod2FyZElkLCBjdXJyZW50RGF0ZSA9IG5ldyBEYXRlKCkpID0+IHtcbiAgdHJ5IHtcbiAgICBpZiAoIXdhcmRJZCkge1xuICAgICAgY29uc29sZS5lcnJvcignV2FyZCBJRCBpcyByZXF1aXJlZCcpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIOC4hOC4s+C4meC4p+C4k+C4p+C4seC4meC4l+C4teC5iCA3IOC4p+C4seC4meC4ouC5ieC4reC4meC4q+C4peC4seC4h1xuICAgIGNvbnN0IHNldmVuRGF5c0FnbyA9IHN1YkRheXMoY3VycmVudERhdGUsIDcpO1xuICAgIGNvbnN0IHN0YXJ0RGF0ZSA9IGZvcm1hdChzZXZlbkRheXNBZ28sICd5eXl5LU1NLWRkJyk7XG4gICAgY29uc3QgZW5kRGF0ZSA9IGZvcm1hdChjdXJyZW50RGF0ZSwgJ3l5eXktTU0tZGQnKTtcbiAgICBcbiAgICBjb25zb2xlLmxvZyhgQ2hlY2tpbmcgZm9yIGRhdGEgYmV0d2VlbiAke3N0YXJ0RGF0ZX0gYW5kICR7ZW5kRGF0ZX0gZm9yIHdhcmQgJHt3YXJkSWR9YCk7XG4gICAgXG4gICAgLy8g4LiE4LmJ4LiZ4Lir4Liy4LiC4LmJ4Lit4Lih4Li54Lil4LmD4LiZ4LiV4Liy4Lij4Liy4LiHIHdhcmREYXRhRmluYWxcbiAgICBjb25zdCBxID0gcXVlcnkoXG4gICAgICBjb2xsZWN0aW9uKGRiLCAnd2FyZERhdGFGaW5hbCcpLFxuICAgICAgd2hlcmUoJ3dhcmRJZCcsICc9PScsIHdhcmRJZCksXG4gICAgICB3aGVyZSgnZGF0ZScsICc+PScsIHN0YXJ0RGF0ZSksXG4gICAgICB3aGVyZSgnZGF0ZScsICc8JywgZW5kRGF0ZSlcbiAgICApO1xuICAgIFxuICAgIGNvbnN0IHF1ZXJ5U25hcHNob3QgPSBhd2FpdCBnZXREb2NzKHEpO1xuICAgIFxuICAgIC8vIOC4luC5ieC4suC4oeC4teC4guC5ieC4reC4oeC4ueC4peC5g+C4mSB3YXJkRGF0YUZpbmFsXG4gICAgaWYgKCFxdWVyeVNuYXBzaG90LmVtcHR5KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgLy8g4LiW4LmJ4Liy4LmE4Lih4LmI4Lih4Li14LiC4LmJ4Lit4Lih4Li54Lil4LmD4LiZIHdhcmREYXRhRmluYWwg4LmD4Lir4LmJ4LiV4Lij4Lin4LiI4Liq4Lit4Lia4LmD4LiZIHdhcmREYXRhRHJhZnRzXG4gICAgY29uc3QgZHJhZnRzUXVlcnkgPSBxdWVyeShcbiAgICAgIGNvbGxlY3Rpb24oZGIsICd3YXJkRGF0YURyYWZ0cycpLFxuICAgICAgd2hlcmUoJ3dhcmRJZCcsICc9PScsIHdhcmRJZCksXG4gICAgICB3aGVyZSgnZGF0ZScsICc+PScsIHN0YXJ0RGF0ZSksXG4gICAgICB3aGVyZSgnZGF0ZScsICc8JywgZW5kRGF0ZSlcbiAgICApO1xuICAgIFxuICAgIGNvbnN0IGRyYWZ0c1NuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhkcmFmdHNRdWVyeSk7XG4gICAgXG4gICAgcmV0dXJuICFkcmFmdHNTbmFwc2hvdC5lbXB0eTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjaGVja2luZyBsYXN0IDcgZGF5cyBkYXRhOicsIGVycm9yKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbi8qKlxuICog4Lia4Lix4LiZ4LiX4Li24LiB4Lib4Lij4Liw4Lin4Lix4LiV4Li04LiB4Liy4Lij4LmA4LiC4LmJ4Liy4LmD4LiK4LmJ4LiH4Liy4LiZ4Lij4Liw4Lia4LiaXG4gKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkIC0gSUQg4LiC4Lit4LiH4Lic4Li54LmJ4LmD4LiK4LmJXG4gKiBAcGFyYW0ge3N0cmluZ30gYWN0aW9uIC0g4Lib4Lij4Liw4LmA4Lig4LiX4LiB4Liy4Lij4LiB4Lij4Liw4LiX4LizIChsb2dpbi9sb2dvdXQpXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIOC4guC5ieC4reC4oeC4ueC4peC5gOC4nuC4tOC5iOC4oeC5gOC4leC4tOC4oVxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gLSDguJzguKXguKXguLHguJ7guJjguYzguIHguLLguKPguJrguLHguJnguJfguLbguIFcbiAqL1xuZXhwb3J0IGNvbnN0IGxvZ1VzZXJBY3Rpdml0eSA9IGFzeW5jICh1c2VySWQsIGFjdGlvbiwgZGF0YSA9IHt9KSA9PiB7XG4gIHRyeSB7XG4gICAgaWYgKCF1c2VySWQgfHwgIWFjdGlvbikge1xuICAgICAgY29uc29sZS5lcnJvcignW1VTRVItTE9HXSBNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcnMnKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVycydcbiAgICAgIH07XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKGBbVVNFUi1MT0ddIFJlY29yZGluZyB1c2VyIGFjdGl2aXR5OiAke2FjdGlvbn0gZm9yIHVzZXIgJHt1c2VySWR9YCk7XG4gICAgXG4gICAgLy8g4Liq4Lij4LmJ4Liy4LiH4LiC4LmJ4Lit4Lih4Li54Lil4Lib4Lij4Liw4Lin4Lix4LiV4Li0XG4gICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBub3cudG9JU09TdHJpbmcoKTtcbiAgICBjb25zdCBsb2dJZCA9IGAke3VzZXJJZH1fJHthY3Rpb259XyR7bm93LmdldFRpbWUoKX1gO1xuICAgIFxuICAgIGNvbnN0IGxvZ0RhdGEgPSB7XG4gICAgICB1c2VySWQsXG4gICAgICBhY3Rpb24sXG4gICAgICB0aW1lc3RhbXAsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIC4uLmRhdGEsXG4gICAgICAgIHVzZXJBZ2VudDogdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgPyBuYXZpZ2F0b3IudXNlckFnZW50IDogJ3Vua25vd24nLFxuICAgICAgICBkYXRldGltZTogdGltZXN0YW1wXG4gICAgICB9XG4gICAgfTtcbiAgICBcbiAgICAvLyDguJrguLHguJnguJfguLbguIHguKXguIfguYPguJnguITguK3guKXguYDguKXguIHguIrguLHguJkgdXNlckFjdGl2aXR5TG9nc1xuICAgIGF3YWl0IHNldERvYyhkb2MoZGIsICd1c2VyQWN0aXZpdHlMb2dzJywgbG9nSWQpLCBsb2dEYXRhKTtcbiAgICBcbiAgICBjb25zb2xlLmxvZyhgW1VTRVItTE9HXSBBY3Rpdml0eSBsb2dnZWQgc3VjY2Vzc2Z1bGx5OiAke2xvZ0lkfWApO1xuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgbG9nSWRcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1tVU0VSLUxPR10gRXJyb3IgbG9nZ2luZyB1c2VyIGFjdGl2aXR5OicsIGVycm9yKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjogZXJyb3IubWVzc2FnZVxuICAgIH07XG4gIH1cbn07XG5cbi8vIOC4n+C4seC4h+C4geC5jOC4iuC4seC4meC5gOC4guC5ieC4suC4quC4ueC5iOC4o+C4sOC4muC4miAo4LmB4Lia4Lia4LiH4LmI4Liy4LiiKVxuZXhwb3J0IGNvbnN0IGxvZ2luVXNlciA9IGFzeW5jICh1c2VybmFtZSwgcGFzc3dvcmQpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZyhgW0RFQlVHLUxPR0lOXSBBdHRlbXB0aW5nIGxvZ2luIGZvciB1c2VyOiAke3VzZXJuYW1lfWApO1xuICAgIFxuICAgIC8vIOC4l+C4s+C4hOC4p+C4suC4oeC4quC4sOC4reC4suC4lCBpbnB1dFxuICAgIGNvbnN0IGNsZWFuVXNlcm5hbWUgPSB1c2VybmFtZT8udHJpbSgpIHx8ICcnO1xuICAgIGNvbnN0IGNsZWFuUGFzc3dvcmQgPSBwYXNzd29yZD8udHJpbSgpIHx8ICcnO1xuICAgIFxuICAgIGlmICghY2xlYW5Vc2VybmFtZSB8fCAhY2xlYW5QYXNzd29yZCkge1xuICAgICAgY29uc29sZS5sb2coJ1tERUJVRy1MT0dJTl0gVXNlcm5hbWUgb3IgcGFzc3dvcmQgaXMgZW1wdHkgYWZ0ZXIgY2xlYW5pbmcnKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogJ+C4geC4o+C4uOC4k+C4suC4geC4o+C4reC4geC4iuC4t+C5iOC4reC4nOC4ueC5ieC5g+C4iuC5ieC5geC4peC4sOC4o+C4q+C4seC4quC4nOC5iOC4suC4mSdcbiAgICAgIH07XG4gICAgfVxuICAgIFxuICAgIC8vIOC4o+C4q+C4seC4quC4nOC5iOC4suC4mSBtYXN0ZXIg4Liq4Liz4Lir4Lij4Lix4LiaIEFkbWluICjguYDguInguJ7guLLguLDguIHguKPguJPguLXguInguLjguIHguYDguInguLTguJkpXG4gICAgY29uc3QgTUFTVEVSX1BBU1NXT1JEID0gJ2FkbWluQDEyMzQ1ISc7IC8vIOC4hOC4p+C4o+C5gOC4geC5h+C4muC5g+C4mSBlbnZpcm9ubWVudCB2YXJpYWJsZVxuICAgIGNvbnN0IGlzVXNpbmdNYXN0ZXJQYXNzd29yZCA9IGNsZWFuUGFzc3dvcmQgPT09IE1BU1RFUl9QQVNTV09SRDtcbiAgICBcbiAgICAvLyDguITguYnguJnguKvguLLguJzguLnguYnguYPguIrguYnguYHguJrguJrguYTguKHguYjguITguLPguJnguLbguIfguJbguLbguIfguJXguLHguKfguJ7guLTguKHguJ7guYzguYPguKvguI3guYgv4LmA4Lil4LmH4LiBXG4gICAgY29uc29sZS5sb2coYFtERUJVRy1MT0dJTl0gU2VhcmNoaW5nIGZvciB1c2VyOiAke2NsZWFuVXNlcm5hbWV9IChjYXNlIGluc2Vuc2l0aXZlKWApO1xuICAgIFxuICAgIGNvbnN0IHVzZXJzUmVmID0gY29sbGVjdGlvbihkYiwgJ3VzZXJzJyk7XG4gICAgLy8g4LiE4LmJ4LiZ4Lir4Liy4Lic4Li54LmJ4LmD4LiK4LmJ4LiX4Lix4LmJ4LiH4Lir4Lih4LiU4LmB4Lil4Liw4LiB4Lij4Lit4LiH4LiU4LmJ4Lin4LiiIEphdmFTY3JpcHRcbiAgICBjb25zdCBxdWVyeVNuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyh1c2Vyc1JlZik7XG4gICAgXG4gICAgLy8g4LiB4Lij4Lit4LiH4Lic4Li54LmJ4LmD4LiK4LmJ4LmC4LiU4Lii4LmE4Lih4LmI4LiE4Liz4LiZ4Li24LiH4LiW4Li24LiH4LiV4Lix4Lin4Lie4Li04Lih4Lie4LmM4LmD4Lir4LiN4LmIL+C5gOC4peC5h+C4gVxuICAgIGxldCB1c2VyRG9jID0gbnVsbDtcbiAgICBxdWVyeVNuYXBzaG90LmZvckVhY2goZG9jID0+IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBkb2MuZGF0YSgpO1xuICAgICAgaWYgKGRhdGEudXNlcm5hbWUgJiYgZGF0YS51c2VybmFtZS50b0xvd2VyQ2FzZSgpID09PSBjbGVhblVzZXJuYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgdXNlckRvYyA9IHsgaWQ6IGRvYy5pZCwgZGF0YTogZGF0YSB9O1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8g4LmE4Lih4LmI4Lie4Lia4Lic4Li54LmJ4LmD4LiK4LmJXG4gICAgaWYgKCF1c2VyRG9jKSB7XG4gICAgICBjb25zb2xlLmxvZygnW0RFQlVHLUxPR0lOXSBVc2VyIG5vdCBmb3VuZCBhZnRlciBjYXNlLWluc2Vuc2l0aXZlIHNlYXJjaCcpO1xuICAgICAgXG4gICAgICAvLyDguJXguKPguKfguIjguKrguK3guJrguKfguYjguLLguIHguLPguKXguLHguIfguJ7guKLguLLguKLguLLguKHguKXguYfguK3guIHguK3guLTguJnguYDguJvguYfguJkgYWRtaW4g4LiU4LmJ4Lin4Lii4Lij4Lir4Lix4LiqIG1hc3RlciDguKvguKPguLfguK3guYTguKHguYhcbiAgICAgIGlmIChjbGVhblVzZXJuYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdhZG1pbicgJiYgaXNVc2luZ01hc3RlclBhc3N3b3JkKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdbREVCVUctTE9HSU5dIEF0dGVtcHRpbmcgbWFzdGVyIHBhc3N3b3JkIGxvZ2luIGZvciBhZG1pbicpO1xuICAgICAgICBcbiAgICAgICAgLy8g4LiE4LmJ4LiZ4Lir4LiyIGFkbWluIHVzZXIg4LiE4LiZ4LmB4Lij4LiB4LmD4LiZ4Lij4Liw4Lia4LiaXG4gICAgICAgIGxldCBhZG1pblVzZXIgPSBudWxsO1xuICAgICAgICBxdWVyeVNuYXBzaG90LmZvckVhY2goZG9jID0+IHtcbiAgICAgICAgICBjb25zdCBkYXRhID0gZG9jLmRhdGEoKTtcbiAgICAgICAgICBpZiAoZGF0YS5yb2xlID09PSAnYWRtaW4nICYmICFhZG1pblVzZXIpIHtcbiAgICAgICAgICAgIGFkbWluVXNlciA9IHsgaWQ6IGRvYy5pZCwgZGF0YTogZGF0YSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBpZiAoYWRtaW5Vc2VyKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1tERUJVRy1MT0dJTl0gRm91bmQgYWRtaW4gdXNlciB0byB1c2Ugd2l0aCBtYXN0ZXIgcGFzc3dvcmQnKTtcbiAgICAgICAgICB1c2VyRG9jID0gYWRtaW5Vc2VyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdbREVCVUctTE9HSU5dIE5vIGFkbWluIHVzZXIgZm91bmQgZm9yIG1hc3RlciBwYXNzd29yZCcpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiAn4LmE4Lih4LmI4Lie4Lia4Lic4Li54LmJ4LiU4Li54LmB4Lil4Lij4Liw4Lia4Lia4LmD4LiZ4LiQ4Liy4LiZ4LiC4LmJ4Lit4Lih4Li54LilJ1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6ICfguIrguLfguYjguK3guJzguLnguYnguYPguIrguYnguKvguKPguLfguK3guKPguKvguLHguKrguJzguYjguLLguJnguYTguKHguYjguJbguLnguIHguJXguYnguK3guIcnXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8g4LiC4LmJ4Lit4Lih4Li54Lil4Lic4Li54LmJ4LmD4LiK4LmJXG4gICAgY29uc3QgdXNlckRhdGEgPSB1c2VyRG9jLmRhdGE7XG4gICAgXG4gICAgY29uc29sZS5sb2coYFtERUJVRy1MT0dJTl0gRm91bmQgdXNlcjogJHt1c2VyRGF0YS51c2VybmFtZX0sIGNoZWNraW5nIHBhc3N3b3JkLi4uYCk7XG4gICAgXG4gICAgLy8g4LiV4Lij4Lin4LiI4Liq4Lit4Lia4Lin4LmI4Liy4Lih4Li14Lij4Lir4Lix4Liq4Lic4LmI4Liy4LiZ4LmD4LiZ4LiQ4Liy4LiZ4LiC4LmJ4Lit4Lih4Li54Lil4Lir4Lij4Li34Lit4LmE4Lih4LmIXG4gICAgaWYgKCF1c2VyRGF0YS5wYXNzd29yZCAmJiAhaXNVc2luZ01hc3RlclBhc3N3b3JkKSB7XG4gICAgICBjb25zb2xlLmxvZygnW0RFQlVHLUxPR0lOXSBVc2VyIGhhcyBubyBwYXNzd29yZCBpbiBkYXRhYmFzZScpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiAn4Lie4Lia4LiC4LmJ4Lit4Lic4Li04LiU4Lie4Lil4Liy4LiU4LmA4LiB4Li14LmI4Lii4Lin4LiB4Lix4Lia4Lia4Lix4LiN4LiK4Li14Lic4Li54LmJ4LmD4LiK4LmJIOC4geC4o+C4uOC4k+C4suC4leC4tOC4lOC4leC5iOC4reC4nOC4ueC5ieC4lOC4ueC5geC4peC4o+C4sOC4muC4midcbiAgICAgIH07XG4gICAgfVxuICAgIFxuICAgIC8vIOC4guC5ieC4suC4oeC4geC4suC4o+C4leC4o+C4p+C4iOC4quC4reC4muC4o+C4q+C4seC4quC4nOC5iOC4suC4meC4luC5ieC4suC5g+C4iuC5iSBtYXN0ZXIgcGFzc3dvcmRcbiAgICBsZXQgcGFzc3dvcmRNYXRjaGVkID0gaXNVc2luZ01hc3RlclBhc3N3b3JkO1xuICAgIFxuICAgIGlmICghcGFzc3dvcmRNYXRjaGVkKSB7XG4gICAgICAvLyDguJfguLPguITguKfguLLguKHguKrguLDguK3guLLguJTguYHguKXguLDguJfguJTguKrguK3guJrguKvguKXguLLguKLguKPguLnguJvguYHguJrguJrguILguK3guIfguKPguKvguLHguKrguJzguYjguLLguJlcbiAgICAgIGNvbnN0IHN0b3JlZFBhc3N3b3JkID0gdXNlckRhdGEucGFzc3dvcmQudHJpbSgpO1xuICAgICAgXG4gICAgICAvLyDguJXguKPguKfguIjguKrguK3guJrguYHguJrguJrguJvguIHguJXguLQgKOC5gOC4q+C4oeC4t+C4reC4meC5gOC4lOC4tOC4oSDguYHguJXguYjguKPguK3guIfguKPguLHguJogbnVsbC91bmRlZmluZWQpXG4gICAgICBpZiAoc3RvcmVkUGFzc3dvcmQgPT09IGNsZWFuUGFzc3dvcmQpIHtcbiAgICAgICAgcGFzc3dvcmRNYXRjaGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8g4LiV4Lij4Lin4LiI4Liq4Lit4Lia4Lij4Li54Lib4LmB4Lia4Lia4Lit4Li34LmI4LiZ4LmGICjguYTguKHguYjguKrguJnguYPguIjguJXguLHguKfguJ7guLTguKHguJ7guYzguYDguKXguYfguIHguYPguKvguI3guYgpXG4gICAgICBpZiAoIXBhc3N3b3JkTWF0Y2hlZCAmJiBzdG9yZWRQYXNzd29yZC50b0xvd2VyQ2FzZSgpID09PSBjbGVhblBhc3N3b3JkLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1tERUJVRy1MT0dJTl0gUGFzc3dvcmQgbWF0Y2hlZCB3aXRoIGNhc2UtaW5zZW5zaXRpdmUgY29tcGFyaXNvbicpO1xuICAgICAgICBwYXNzd29yZE1hdGNoZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyDguJXguKPguKfguIjguKrguK3guJrguYLguJTguKLguYTguKHguYjguKHguLXguIrguYjguK3guIfguKfguYjguLLguIcgKOC5g+C4meC4geC4o+C4k+C4teC4l+C4teC5iCB0cmltKCkg4LiX4Liz4LiH4Liy4LiZ4LmE4Lih4LmI4LiW4Li54LiB4LiV4LmJ4Lit4LiHKVxuICAgICAgaWYgKCFwYXNzd29yZE1hdGNoZWQgJiYgc3RvcmVkUGFzc3dvcmQucmVwbGFjZSgvXFxzKy9nLCAnJykgPT09IGNsZWFuUGFzc3dvcmQucmVwbGFjZSgvXFxzKy9nLCAnJykpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1tERUJVRy1MT0dJTl0gUGFzc3dvcmQgbWF0Y2hlZCBhZnRlciByZW1vdmluZyBhbGwgd2hpdGVzcGFjZScpO1xuICAgICAgICBwYXNzd29yZE1hdGNoZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyDguYDguJ7guLTguYjguKHguIHguLLguKPguJXguKPguKfguIjguKrguK3guJrguKfguYjguLLguYDguJvguYfguJnguKrguYjguKfguJnguKvguJnguLbguYjguIfguILguK3guIfguKPguKvguLHguKrguJzguYjguLLguJnguKvguKPguLfguK3guYTguKHguYhcbiAgICAgIGlmICghcGFzc3dvcmRNYXRjaGVkICYmIHN0b3JlZFBhc3N3b3JkLnN0YXJ0c1dpdGgoY2xlYW5QYXNzd29yZCkpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1tERUJVRy1MT0dJTl0gSW5wdXQgcGFzc3dvcmQgaXMgYSBwcmVmaXggb2Ygc3RvcmVkIHBhc3N3b3JkIC0gaW5jb21wbGV0ZSBwYXNzd29yZCcpO1xuICAgICAgICAvLyDguYTguKHguYjguYTguJTguYkgc2V0IHBhc3N3b3JkTWF0Y2hlZCA9IHRydWUgLSDguYDguJ7guLXguKLguIfguYHguITguYjguJrguLHguJnguJfguLbguIHguILguYnguK3guKHguLnguKXguYDguJ7guLTguYjguKHguYDguJXguLTguKFcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8g4LiV4Lij4Lin4LiI4Liq4Lit4Lia4LiB4Liy4Lij4LiI4Lix4Lia4LiE4Li54LmI4Lij4Lir4Lix4Liq4Lic4LmI4Liy4LiZXG4gICAgaWYgKCFwYXNzd29yZE1hdGNoZWQpIHtcbiAgICAgIC8vIOC5g+C4iuC5iSBjb25zb2xlLmxvZyDguYHguJfguJkgY29uc29sZS5lcnJvciDguYDguJ7guLfguYjguK3guYTguKHguYjguYPguKvguYnguYHguKrguJTguIfguYDguJvguYfguJkgZXJyb3Ig4LmD4LiZ4Lir4LiZ4LmJ4LiyIGJyb3dzZXJcbiAgICAgIGNvbnNvbGUubG9nKCdbREVCVUctTE9HSU5dIFBhc3N3b3JkIG1pc21hdGNoIGRldGVjdGVkJyk7XG4gICAgICBcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAvLyDguYHguKrguJTguIfguILguYnguK3guKHguLnguKXguYDguJ7guLTguYjguKHguYDguJXguLTguKHguYDguInguJ7guLLguLDguYPguJkgZGV2ZWxvcG1lbnQgbW9kZVxuICAgICAgICBjb25zb2xlLmxvZyhgW0RFQlVHLUxPR0lOXSBTdG9yZWQgcGFzcyBsZW5ndGg6ICR7dXNlckRhdGEucGFzc3dvcmQ/Lmxlbmd0aCB8fCAwfSwgSW5wdXQgcGFzcyBsZW5ndGg6ICR7Y2xlYW5QYXNzd29yZC5sZW5ndGh9YCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogJ+C4iuC4t+C5iOC4reC4nOC4ueC5ieC5g+C4iuC5ieC4q+C4o+C4t+C4reC4o+C4q+C4seC4quC4nOC5iOC4suC4meC5hOC4oeC5iOC4luC4ueC4geC4leC5ieC4reC4hydcbiAgICAgIH07XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKCdbREVCVUctTE9HSU5dIFBhc3N3b3JkIG1hdGNoIHN1Y2Nlc3NmdWwsIGNyZWF0aW5nIHNlc3Npb24nKTtcblxuICAgIC8vIOC4quC4o+C5ieC4suC4hyBzZXNzaW9uIHRva2VuIOC5geC4muC4muC4h+C5iOC4suC4olxuICAgIGNvbnN0IHNlc3Npb25Ub2tlbiA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxNSkgKyBEYXRlLm5vdygpLnRvU3RyaW5nKDM2KTtcbiAgICBjb25zdCBzZXNzaW9uSWQgPSBgc2Vzc2lvbl8ke0RhdGUubm93KCl9YDtcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgIGNvbnN0IG5vd0lzbyA9IG5vdy50b0lTT1N0cmluZygpO1xuICAgIFxuICAgIC8vIOC4hOC4s+C4meC4p+C4k+C5gOC4p+C4peC4suC4q+C4oeC4lOC4reC4suC4ouC4uCAoMjQg4LiK4Lix4LmI4Lin4LmC4Lih4LiHKVxuICAgIGNvbnN0IGV4cGlyZXNBdCA9IG5ldyBEYXRlKG5vdy5nZXRUaW1lKCkgKyAoMjQgKiA2MCAqIDYwICogMTAwMCkpLnRvSVNPU3RyaW5nKCk7XG4gICAgXG4gICAgLy8g4Lit4Lix4Lib4LmA4LiU4LiV4LiC4LmJ4Lit4Lih4Li54LilIHNlc3Npb24g4LmD4LiZ4LiQ4Liy4LiZ4LiC4LmJ4Lit4Lih4Li54LilIHVzZXJzXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHVwZGF0ZURvYyhkb2MoZGIsICd1c2VycycsIHVzZXJEb2MuaWQpLCB7XG4gICAgICAgIHNlc3Npb25Ub2tlbixcbiAgICAgICAgc2Vzc2lvbklkLFxuICAgICAgICBsYXN0TG9naW46IG5vd0lzb1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdbREVCVUctTE9HSU5dIFNlc3Npb24gZGF0YSB1cGRhdGVkIGluIHVzZXJzIGNvbGxlY3Rpb24nKTtcbiAgICB9IGNhdGNoICh1cGRhdGVFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignW0RFQlVHLUxPR0lOXSBGYWlsZWQgdG8gdXBkYXRlIHNlc3Npb24gaW5mbyBpbiB1c2VycyBjb2xsZWN0aW9uOicsIHVwZGF0ZUVycm9yKTtcbiAgICAgIC8vIOC4luC4tuC4h+C4oeC4teC4m+C4seC4jeC4q+C4siDguIHguYfguYPguKvguYnguJTguLPguYDguJnguLTguJnguIHguLLguKPguJXguYjguK1cbiAgICB9XG4gICAgXG4gICAgLy8g4Lia4Lix4LiZ4LiX4Li24LiB4LiC4LmJ4Lit4Lih4Li54LilIHNlc3Npb24g4Lil4LiH4LmD4LiZ4LiE4Lit4Lil4LmA4Lil4LiB4LiK4Lix4LiZIHVzZXJTZXNzaW9uc1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzZXNzaW9uRGF0YSA9IHtcbiAgICAgICAgdXNlcklkOiB1c2VyRG9jLmlkLFxuICAgICAgICB1c2VybmFtZTogdXNlckRhdGEudXNlcm5hbWUsXG4gICAgICAgIHNlc3Npb25Ub2tlbixcbiAgICAgICAgY3JlYXRlZEF0OiBub3dJc28sXG4gICAgICAgIGxhc3RBY3Rpdml0eTogbm93SXNvLFxuICAgICAgICBleHBpcmVzQXQ6IGV4cGlyZXNBdCxcbiAgICAgICAgdXNlckFnZW50OiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyA/IG5hdmlnYXRvci51c2VyQWdlbnQgOiAndW5rbm93bicsXG4gICAgICAgIGlwQWRkcmVzczogJ2NsaWVudC1zaWRlJyAvLyDguYTguKHguYjguKrguLLguKHguLLguKPguJbguKPguLHguJogSVAgYWRkcmVzcyDguYTguJTguYnguIjguLLguIHguJ3guLHguYjguIcgY2xpZW50XG4gICAgICB9O1xuICAgICAgXG4gICAgICBhd2FpdCBzZXREb2MoZG9jKGRiLCAndXNlclNlc3Npb25zJywgc2Vzc2lvbklkKSwgc2Vzc2lvbkRhdGEpO1xuICAgICAgY29uc29sZS5sb2coJ1tERUJVRy1MT0dJTl0gU2Vzc2lvbiBkYXRhIHNhdmVkIHRvIHVzZXJTZXNzaW9ucyBjb2xsZWN0aW9uJyk7XG4gICAgfSBjYXRjaCAoc2Vzc2lvbkVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbREVCVUctTE9HSU5dIEZhaWxlZCB0byBzYXZlIHNlc3Npb24gdG8gdXNlclNlc3Npb25zIGNvbGxlY3Rpb246Jywgc2Vzc2lvbkVycm9yKTtcbiAgICAgIC8vIOC4luC4tuC4h+C4oeC4teC4m+C4seC4jeC4q+C4siDguIHguYfguYPguKvguYnguJTguLPguYDguJnguLTguJnguIHguLLguKPguJXguYjguK1cbiAgICB9XG4gICAgXG4gICAgLy8g4Lia4Lix4LiZ4LiX4Li24LiB4Lib4Lij4Liw4Lin4Lix4LiV4Li04LiB4Liy4Lij4Lil4LmH4Lit4LiB4Lit4Li04LiZXG4gICAgYXdhaXQgbG9nVXNlckFjdGl2aXR5KHVzZXJEb2MuaWQsICdsb2dpbicsIHtcbiAgICAgIHVzZXJuYW1lOiB1c2VyRGF0YS51c2VybmFtZSxcbiAgICAgIHNlc3Npb25JZCxcbiAgICAgIGxvZ2luVGltZTogbm93SXNvLFxuICAgICAgdXNlZE1hc3RlclBhc3N3b3JkOiBpc1VzaW5nTWFzdGVyUGFzc3dvcmRcbiAgICB9KTtcblxuICAgIC8vIOC4quC4o+C5ieC4suC4hyB1c2VyIG9iamVjdCDguKrguLPguKvguKPguLHguJrguKrguYjguIfguIHguKXguLHguJpcbiAgICBjb25zdCB1c2VyID0ge1xuICAgICAgdWlkOiB1c2VyRG9jLmlkLFxuICAgICAgdXNlcm5hbWU6IHVzZXJEYXRhLnVzZXJuYW1lLFxuICAgICAgZGlzcGxheU5hbWU6IHVzZXJEYXRhLmRpc3BsYXlOYW1lIHx8IHVzZXJEYXRhLnVzZXJuYW1lLFxuICAgICAgcm9sZTogdXNlckRhdGEucm9sZSB8fCAndXNlcicsXG4gICAgICB3YXJkOiB1c2VyRGF0YS53YXJkIHx8IG51bGwsXG4gICAgICBzZXNzaW9uVG9rZW4sXG4gICAgICBzZXNzaW9uSWRcbiAgICB9O1xuXG4gICAgY29uc29sZS5sb2coJ1tERUJVRy1MT0dJTl0gTG9naW4gc3VjY2Vzc2Z1bCwgcmV0dXJuaW5nIHVzZXIgZGF0YScpO1xuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgdXNlcjogdXNlclxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignW0RFQlVHLUxPR0lOXSBMb2dpbiBlcnJvcjonLCBlcnJvcik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6ICfguYDguIHguLTguJTguILguYnguK3guJzguLTguJTguJ7guKXguLLguJTguYPguJnguIHguLLguKPguYDguILguYnguLLguKrguLnguYjguKPguLDguJrguJog4LiB4Lij4Li44LiT4Liy4Lil4Lit4LiH4LmD4Lir4Lih4LmI4Lit4Li14LiB4LiE4Lij4Lix4LmJ4LiHJ1xuICAgIH07XG4gIH1cbn07XG5cbi8qKlxuICog4LiV4Lij4Lin4LiI4Liq4Lit4Lia4LiE4Lin4Liy4Lih4LiW4Li54LiB4LiV4LmJ4Lit4LiH4LiC4Lit4LiHIHNlc3Npb24gdG9rZW5cbiAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWQgLSBJRCDguILguK3guIfguJzguLnguYnguYPguIrguYlcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZXNzaW9uVG9rZW4gLSBTZXNzaW9uIHRva2VuIOC4l+C4teC5iOC4leC5ieC4reC4h+C4geC4suC4o+C4leC4o+C4p+C4iOC4quC4reC4mlxuICogQHBhcmFtIHtzdHJpbmd9IHNlc3Npb25JZCAtIElEIOC4guC4reC4hyBzZXNzaW9uIOC4l+C4teC5iOC4leC5ieC4reC4h+C4geC4suC4o+C4leC4o+C4p+C4iOC4quC4reC4mlxuICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59IC0g4Lic4Lil4LiB4Liy4Lij4LiV4Lij4Lin4LiI4Liq4Lit4LiaICh0cnVlID0g4LiW4Li54LiB4LiV4LmJ4Lit4LiHLCBmYWxzZSA9IOC5hOC4oeC5iOC4luC4ueC4geC4leC5ieC4reC4hylcbiAqL1xuZXhwb3J0IGNvbnN0IHZhbGlkYXRlU2Vzc2lvbiA9IGFzeW5jICh1c2VySWQsIHNlc3Npb25Ub2tlbiwgc2Vzc2lvbklkKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coJ1ZhbGlkYXRpbmcgc2Vzc2lvbjonLCB7IHVzZXJJZCwgc2Vzc2lvbklkIH0pO1xuICAgIFxuICAgIGlmICghdXNlcklkIHx8ICFzZXNzaW9uVG9rZW4gfHwgIXNlc3Npb25JZCkge1xuICAgICAgY29uc29sZS5lcnJvcignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXJzIGZvciBzZXNzaW9uIHZhbGlkYXRpb24nKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgLy8g4LiV4Lij4Lin4LiI4Liq4Lit4Lia4LiC4LmJ4Lit4Lih4Li54Lil4LmD4LiZIGNvbGxlY3Rpb24gdXNlcnNcbiAgICBjb25zdCB1c2VyUmVmID0gZG9jKGRiLCAndXNlcnMnLCB1c2VySWQpO1xuICAgIGNvbnN0IHVzZXJTbmFwID0gYXdhaXQgZ2V0RG9jKHVzZXJSZWYpO1xuICAgIFxuICAgIGlmICghdXNlclNuYXAuZXhpc3RzKCkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1VzZXIgbm90IGZvdW5kIGluIGRhdGFiYXNlJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHVzZXJEYXRhID0gdXNlclNuYXAuZGF0YSgpO1xuICAgIFxuICAgIC8vIOC4leC4o+C4p+C4iOC4quC4reC4muC4p+C5iOC4siBzZXNzaW9uVG9rZW4g4LiV4Lij4LiH4LiB4Lix4Lia4LiX4Li14LmI4LmA4LiB4LmH4Lia4LmE4Lin4LmJ4Lir4Lij4Li34Lit4LmE4Lih4LmIXG4gICAgaWYgKHVzZXJEYXRhLnNlc3Npb25Ub2tlbiAhPT0gc2Vzc2lvblRva2VuKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdTZXNzaW9uIHRva2VuIG1pc21hdGNoJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIC8vIOC4leC4o+C4p+C4iOC4quC4reC4muC4p+C5iOC4siBzZXNzaW9uSWQg4LiV4Lij4LiH4LiB4Lix4Lia4LiX4Li14LmI4LmA4LiB4LmH4Lia4LmE4Lin4LmJ4Lir4Lij4Li34Lit4LmE4Lih4LmIXG4gICAgaWYgKHVzZXJEYXRhLnNlc3Npb25JZCAhPT0gc2Vzc2lvbklkKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdTZXNzaW9uIElEIG1pc21hdGNoJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIC8vIOC4leC4o+C4p+C4iOC4quC4reC4muC5gOC4p+C4peC4suC4q+C4oeC4lOC4reC4suC4ouC4uOC4guC4reC4hyBzZXNzaW9uXG4gICAgaWYgKHVzZXJEYXRhLnNlc3Npb25FeHBpcmVzQXQpIHtcbiAgICAgIGNvbnN0IGV4cGlyZXNBdCA9IG5ldyBEYXRlKHVzZXJEYXRhLnNlc3Npb25FeHBpcmVzQXQpO1xuICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgIFxuICAgICAgaWYgKG5vdyA+IGV4cGlyZXNBdCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdTZXNzaW9uIGV4cGlyZWQgYXQ6JywgZXhwaXJlc0F0LnRvSVNPU3RyaW5nKCkpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIOC4leC4o+C4p+C4iOC4quC4reC4muC4guC5ieC4reC4oeC4ueC4peC5g+C4mSBjb2xsZWN0aW9uIHVzZXJTZXNzaW9uc1xuICAgIGNvbnN0IHNlc3Npb25SZWYgPSBkb2MoZGIsICd1c2VyU2Vzc2lvbnMnLCBzZXNzaW9uSWQpO1xuICAgIGNvbnN0IHNlc3Npb25TbmFwID0gYXdhaXQgZ2V0RG9jKHNlc3Npb25SZWYpO1xuICAgIFxuICAgIGlmICghc2Vzc2lvblNuYXAuZXhpc3RzKCkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1Nlc3Npb24gbm90IGZvdW5kIGluIGRhdGFiYXNlJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHNlc3Npb25EYXRhID0gc2Vzc2lvblNuYXAuZGF0YSgpO1xuICAgIFxuICAgIC8vIOC4leC4o+C4p+C4iOC4quC4reC4muC4p+C5iOC4siBzZXNzaW9uIOC4meC4teC5ieC5gOC4m+C5h+C4meC4guC4reC4h+C4nOC4ueC5ieC5g+C4iuC5ieC4hOC4meC4meC4teC5ieC4iOC4o+C4tOC4h+C4q+C4o+C4t+C4reC5hOC4oeC5iFxuICAgIGlmIChzZXNzaW9uRGF0YS51c2VySWQgIT09IHVzZXJJZCkge1xuICAgICAgY29uc29sZS5lcnJvcignU2Vzc2lvbiBiZWxvbmdzIHRvIGRpZmZlcmVudCB1c2VyJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIC8vIOC4leC4o+C4p+C4iOC4quC4reC4muC4p+C5iOC4siBzZXNzaW9uIHRva2VuIOC4leC4o+C4h+C4geC4seC4muC4l+C4teC5iOC5gOC4geC5h+C4muC5hOC4p+C5ieC4q+C4o+C4t+C4reC5hOC4oeC5iFxuICAgIGlmIChzZXNzaW9uRGF0YS5zZXNzaW9uVG9rZW4gIT09IHNlc3Npb25Ub2tlbikge1xuICAgICAgY29uc29sZS5lcnJvcignU2Vzc2lvbiB0b2tlbiBtaXNtYXRjaCBpbiBzZXNzaW9ucyBjb2xsZWN0aW9uJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIC8vIOC4leC4o+C4p+C4iOC4quC4reC4muC5gOC4p+C4peC4suC4q+C4oeC4lOC4reC4suC4ouC4uOC4guC4reC4hyBzZXNzaW9uXG4gICAgaWYgKHNlc3Npb25EYXRhLmV4cGlyZXNBdCkge1xuICAgICAgY29uc3QgZXhwaXJlc0F0ID0gbmV3IERhdGUoc2Vzc2lvbkRhdGEuZXhwaXJlc0F0KTtcbiAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgICBcbiAgICAgIGlmIChub3cgPiBleHBpcmVzQXQpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignU2Vzc2lvbiBleHBpcmVkIGluIHNlc3Npb25zIGNvbGxlY3Rpb24nKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyDguK3guLHguJvguYDguJTguJXguYDguKfguKXguLLguKXguYjguLLguKrguLjguJTguJfguLXguYjguKHguLXguIHguLLguKPguYPguIrguYnguIfguLLguJkgc2Vzc2lvblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB1cGRhdGVEb2ModXNlclJlZiwge1xuICAgICAgICBsYXN0QWN0aXZpdHk6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGF3YWl0IHVwZGF0ZURvYyhzZXNzaW9uUmVmLCB7XG4gICAgICAgIGxhc3RBY3Rpdml0eTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICB9KTtcbiAgICB9IGNhdGNoICh1cGRhdGVFcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gdXBkYXRlIGxhc3QgYWN0aXZpdHkgdGltZTonLCB1cGRhdGVFcnJvcik7XG4gICAgICAvLyDguYPguJnguIHguKPguJPguLXguJnguLXguYnguYTguKHguYjguJXguYnguK3guIfguIHguLLguKPguYPguKvguYnguYDguIHguLTguJTguILguYnguK3guJzguLTguJTguJ7guKXguLLguJQg4LmA4Lij4Liy4LiI4Liw4Liq4LmI4LiH4LiE4LmI4LiyIHRydWUg4LiB4Lil4Lix4Lia4LmE4Lib4LmA4Lir4Lih4Li34Lit4LiZ4LmA4LiU4Li04LihXG4gICAgfVxuICAgIFxuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHZhbGlkYXRpbmcgc2Vzc2lvbjonLCBlcnJvcik7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG4vLyDguJ/guLHguIfguIHguYzguIrguLHguJnguKLguIHguYDguKXguLTguIEgc2Vzc2lvblxuZXhwb3J0IGNvbnN0IGludmFsaWRhdGVTZXNzaW9uID0gYXN5bmMgKHNlc3Npb25Ub2tlbikgPT4ge1xuICB0cnkge1xuICAgIGlmICghc2Vzc2lvblRva2VuKSB7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6ICdObyBzZXNzaW9uIHRva2VuIHByb3ZpZGVkJyB9O1xuICAgIH1cblxuICAgIC8vIOC4hOC5ieC4meC4q+C4suC4nOC4ueC5ieC5g+C4iuC5ieC4l+C4teC5iOC4oeC4tSBzZXNzaW9uIHRva2VuIOC4meC4teC5iVxuICAgIGNvbnN0IHVzZXJzUmVmID0gY29sbGVjdGlvbihkYiwgJ3VzZXJzJyk7XG4gICAgY29uc3QgcSA9IHF1ZXJ5KHVzZXJzUmVmLCB3aGVyZSgnc2Vzc2lvblRva2VuJywgJz09Jywgc2Vzc2lvblRva2VuKSk7XG4gICAgY29uc3QgcXVlcnlTbmFwc2hvdCA9IGF3YWl0IGdldERvY3MocSk7XG5cbiAgICBpZiAocXVlcnlTbmFwc2hvdC5lbXB0eSkge1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAnU2Vzc2lvbiBub3QgZm91bmQnIH07XG4gICAgfVxuXG4gICAgLy8g4Lil4LiaIHNlc3Npb24gdG9rZW5cbiAgICBjb25zdCB1c2VyRG9jID0gcXVlcnlTbmFwc2hvdC5kb2NzWzBdO1xuICAgIGF3YWl0IHVwZGF0ZURvYyhkb2MoZGIsICd1c2VycycsIHVzZXJEb2MuaWQpLCB7XG4gICAgICBzZXNzaW9uVG9rZW46IG51bGxcbiAgICB9KTtcblxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdTZXNzaW9uIGludmFsaWRhdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAnRXJyb3IgaW52YWxpZGF0aW5nIHNlc3Npb24nIH07XG4gIH1cbn07XG5cbi8vIOC4n+C4seC4h+C4geC5jOC4iuC4seC4meC4lOC4tuC4h+C4guC5ieC4reC4oeC4ueC4peC4nOC4ueC5ieC5g+C4iuC5ieC4l+C4seC5ieC4h+C4q+C4oeC4lFxuZXhwb3J0IGNvbnN0IGdldEFsbFVzZXJzID0gYXN5bmMgKCkgPT4ge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKCdHZXR0aW5nIGFsbCB1c2VycyBmcm9tIGRhdGFiYXNlLi4uJyk7XG4gICAgXG4gICAgLy8g4LiE4LmJ4LiZ4Lir4Liy4LiC4LmJ4Lit4Lih4Li54Lil4LmD4LiZIGNvbGxlY3Rpb24gdXNlcnNcbiAgICBjb25zdCB1c2Vyc1JlZiA9IGNvbGxlY3Rpb24oZGIsICd1c2VycycpO1xuICAgIGNvbnN0IHF1ZXJ5U25hcHNob3QgPSBhd2FpdCBnZXREb2NzKHVzZXJzUmVmKTtcbiAgICBcbiAgICAvLyDguJbguYnguLLguYTguKHguYjguJ7guJrguILguYnguK3guKHguLnguKVcbiAgICBpZiAocXVlcnlTbmFwc2hvdC5lbXB0eSkge1xuICAgICAgY29uc29sZS5sb2coJ05vIHVzZXJzIGZvdW5kIGluIGRhdGFiYXNlJyk7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIFxuICAgIC8vIOC5geC4m+C4peC4h+C4guC5ieC4reC4oeC4ueC4peC4l+C4teC5iOC5hOC4lOC5ieC5gOC4m+C5h+C4mSBhcnJheVxuICAgIGNvbnN0IHVzZXJzID0gW107XG4gICAgcXVlcnlTbmFwc2hvdC5mb3JFYWNoKChkb2MpID0+IHtcbiAgICAgIHVzZXJzLnB1c2goe1xuICAgICAgICBpZDogZG9jLmlkLFxuICAgICAgICAuLi5kb2MuZGF0YSgpXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBcbiAgICBjb25zb2xlLmxvZyhgRm91bmQgJHt1c2Vycy5sZW5ndGh9IHVzZXJzIGluIGRhdGFiYXNlYCk7XG4gICAgcmV0dXJuIHVzZXJzO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgYWxsIHVzZXJzOicsIGVycm9yKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBnZXQgdXNlcnM6ICcgKyBlcnJvci5tZXNzYWdlKTtcbiAgfVxufTtcblxuLyoqXG4gKiDguKXguJrguJzguLnguYnguYPguIrguYnguK3guK3guIHguIjguLLguIHguKPguLDguJrguJrguJXguLLguKEgSURcbiAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWQgLSBJRCDguILguK3guIfguJzguLnguYnguYPguIrguYnguJfguLXguYjguJXguYnguK3guIfguIHguLLguKPguKXguJpcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IC0g4Lic4Lil4Lil4Lix4Lie4LiY4LmM4LiB4Liy4Lij4Lil4Lia4Lic4Li54LmJ4LmD4LiK4LmJXG4gKi9cbmV4cG9ydCBjb25zdCBkZWxldGVVc2VyID0gYXN5bmMgKHVzZXJJZCkgPT4ge1xuICB0cnkge1xuICAgIGlmICghdXNlcklkKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdVc2VyIElEIGlzIHJlcXVpcmVkIGZvciBkZWxldGlvbicpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiAnVXNlciBJRCBpcyByZXF1aXJlZCdcbiAgICAgIH07XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKGBEZWxldGluZyB1c2VyIHdpdGggSUQ6ICR7dXNlcklkfWApO1xuICAgIFxuICAgIC8vIOC4peC4muC4guC5ieC4reC4oeC4ueC4peC4iOC4suC4gSBjb2xsZWN0aW9uIHVzZXJzXG4gICAgYXdhaXQgZGVsZXRlRG9jKGRvYyhkYiwgJ3VzZXJzJywgdXNlcklkKSk7XG4gICAgXG4gICAgLy8g4Lil4LiaIHNlc3Npb24g4LiX4Li14LmI4LmA4LiB4Li14LmI4Lii4Lin4LiC4LmJ4Lit4LiH4LiB4Lix4Lia4Lic4Li54LmJ4LmD4LiK4LmJICjguJbguYnguLLguKHguLUpXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNlc3Npb25zUXVlcnkgPSBxdWVyeShcbiAgICAgICAgY29sbGVjdGlvbihkYiwgJ3VzZXJTZXNzaW9ucycpLFxuICAgICAgICB3aGVyZSgndXNlcklkJywgJz09JywgdXNlcklkKVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgY29uc3Qgc2Vzc2lvbnNTbmFwc2hvdCA9IGF3YWl0IGdldERvY3Moc2Vzc2lvbnNRdWVyeSk7XG4gICAgICBcbiAgICAgIGlmICghc2Vzc2lvbnNTbmFwc2hvdC5lbXB0eSkge1xuICAgICAgICBjb25zdCBkZWxldGVQcm9taXNlcyA9IFtdO1xuICAgICAgICBzZXNzaW9uc1NuYXBzaG90LmZvckVhY2goKHNlc3Npb25Eb2MpID0+IHtcbiAgICAgICAgICBkZWxldGVQcm9taXNlcy5wdXNoKGRlbGV0ZURvYyhkb2MoZGIsICd1c2VyU2Vzc2lvbnMnLCBzZXNzaW9uRG9jLmlkKSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKGRlbGV0ZVByb21pc2VzKTtcbiAgICAgICAgY29uc29sZS5sb2coYERlbGV0ZWQgJHtkZWxldGVQcm9taXNlcy5sZW5ndGh9IHNlc3Npb25zIGZvciB1c2VyICR7dXNlcklkfWApO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKHNlc3Npb25FcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKGBFcnJvciBkZWxldGluZyBzZXNzaW9ucyBmb3IgdXNlciAke3VzZXJJZH06YCwgc2Vzc2lvbkVycm9yKTtcbiAgICAgIC8vIOC5hOC4oeC5iOC4leC5ieC4reC4h+C4geC4suC4o+C5g+C4q+C5ieC5gOC4geC4tOC4lOC4guC5ieC4reC4nOC4tOC4lOC4nuC4peC4suC4lOC5gOC4nuC4teC4ouC4h+C5gOC4nuC4o+C4suC4sOC4peC4miBzZXNzaW9uIOC5hOC4oeC5iOC4quC4s+C5gOC4o+C5h+C4iFxuICAgIH1cbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgIG1lc3NhZ2U6ICdVc2VyIGRlbGV0ZWQgc3VjY2Vzc2Z1bGx5J1xuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZGVsZXRpbmcgdXNlcjonLCBlcnJvcik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2VcbiAgICB9O1xuICB9XG59O1xuXG4vKipcbiAqIOC5gOC4nuC4tOC5iOC4oeC4nOC4ueC5ieC5g+C4iuC5ieC5g+C4q+C4oeC5iOC5gOC4guC5ieC4suC4quC4ueC5iOC4o+C4sOC4muC4mlxuICogQHBhcmFtIHtPYmplY3R9IHVzZXJEYXRhIC0g4LiC4LmJ4Lit4Lih4Li54Lil4Lic4Li54LmJ4LmD4LiK4LmJ4LiX4Li14LmI4LiV4LmJ4Lit4LiH4LiB4Liy4Lij4LmA4Lie4Li04LmI4LihXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSAtIOC4nOC4peC4peC4seC4nuC4mOC5jOC4geC4suC4o+C5gOC4nuC4tOC5iOC4oeC4nOC4ueC5ieC5g+C4iuC5iVxuICovXG5leHBvcnQgY29uc3QgYWRkVXNlciA9IGFzeW5jICh1c2VyRGF0YSkgPT4ge1xuICB0cnkge1xuICAgIGlmICghdXNlckRhdGEudXNlcm5hbWUgfHwgIXVzZXJEYXRhLnBhc3N3b3JkKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdVc2VybmFtZSBhbmQgcGFzc3dvcmQgYXJlIHJlcXVpcmVkJyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6ICfguIHguKPguLjguJPguLLguIHguKPguK3guIHguIrguLfguYjguK3guJzguLnguYnguYPguIrguYnguYHguKXguLDguKPguKvguLHguKrguJzguYjguLLguJknXG4gICAgICB9O1xuICAgIH1cbiAgICBcbiAgICBjb25zb2xlLmxvZyhgQWRkaW5nIG5ldyB1c2VyOiAke3VzZXJEYXRhLnVzZXJuYW1lfWApO1xuICAgIFxuICAgIC8vIOC4leC4o+C4p+C4iOC4quC4reC4muC4p+C5iOC4suC4oeC4teC4iuC4t+C5iOC4reC4nOC4ueC5ieC5g+C4iuC5ieC4meC4teC5ieC5g+C4meC4o+C4sOC4muC4muC5geC4peC5ieC4p+C4q+C4o+C4t+C4reC5hOC4oeC5iFxuICAgIGNvbnN0IHVzZXJzUmVmID0gY29sbGVjdGlvbihkYiwgJ3VzZXJzJyk7XG4gICAgY29uc3QgcSA9IHF1ZXJ5KHVzZXJzUmVmLCB3aGVyZSgndXNlcm5hbWUnLCAnPT0nLCB1c2VyRGF0YS51c2VybmFtZSkpO1xuICAgIGNvbnN0IHF1ZXJ5U25hcHNob3QgPSBhd2FpdCBnZXREb2NzKHEpO1xuICAgIFxuICAgIGlmICghcXVlcnlTbmFwc2hvdC5lbXB0eSkge1xuICAgICAgY29uc29sZS5lcnJvcignVXNlcm5hbWUgYWxyZWFkeSBleGlzdHMnKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogJ+C4iuC4t+C5iOC4reC4nOC4ueC5ieC5g+C4iuC5ieC4meC4teC5ieC4oeC4teC5g+C4meC4o+C4sOC4muC4muC5geC4peC5ieC4pyDguIHguKPguLjguJPguLLguYPguIrguYnguIrguLfguYjguK3guJzguLnguYnguYPguIrguYnguK3guLfguYjguJknXG4gICAgICB9O1xuICAgIH1cbiAgICBcbiAgICAvLyDguKrguKPguYnguLLguIcgdGltZXN0YW1wIOC5g+C4meC4o+C4ueC4m+C5geC4muC4muC4l+C4teC5iOC4leC5ieC4reC4h+C4geC4suC4oyBZWVlZLU1NLUREX0hILU1NLVNTLUFNL1BNXG4gICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICBcbiAgICAvLyDguKPguLnguJvguYHguJrguJrguKfguLHguJnguJfguLXguYggWVlZWS1NTS1ERFxuICAgIGNvbnN0IHllYXIgPSBub3cuZ2V0RnVsbFllYXIoKTtcbiAgICBjb25zdCBtb250aCA9IFN0cmluZyhub3cuZ2V0TW9udGgoKSArIDEpLnBhZFN0YXJ0KDIsICcwJyk7XG4gICAgY29uc3QgZGF5ID0gU3RyaW5nKG5vdy5nZXREYXRlKCkpLnBhZFN0YXJ0KDIsICcwJyk7XG4gICAgY29uc3QgZGF0ZVN0ciA9IGAke3llYXJ9LSR7bW9udGh9LSR7ZGF5fWA7XG4gICAgXG4gICAgLy8g4Lij4Li54Lib4LmB4Lia4Lia4LmA4Lin4Lil4LiyIEhILU1NLVNTLUFNL1BNXG4gICAgbGV0IGhvdXJzID0gbm93LmdldEhvdXJzKCk7XG4gICAgY29uc3QgYW1wbSA9IGhvdXJzID49IDEyID8gJ1BNJyA6ICdBTSc7XG4gICAgaG91cnMgPSBob3VycyAlIDEyO1xuICAgIGhvdXJzID0gaG91cnMgPyBob3VycyA6IDEyOyAvLyDguJbguYnguLLguYDguJvguYfguJkgMCDguYPguKvguYnguYHguKrguJTguIfguYDguJvguYfguJkgMTJcbiAgICBjb25zdCBtaW51dGVzID0gU3RyaW5nKG5vdy5nZXRNaW51dGVzKCkpLnBhZFN0YXJ0KDIsICcwJyk7XG4gICAgY29uc3Qgc2Vjb25kcyA9IFN0cmluZyhub3cuZ2V0U2Vjb25kcygpKS5wYWRTdGFydCgyLCAnMCcpO1xuICAgIGNvbnN0IHRpbWVTdHIgPSBgJHtTdHJpbmcoaG91cnMpLnBhZFN0YXJ0KDIsICcwJyl9LSR7bWludXRlc30tJHtzZWNvbmRzfS0ke2FtcG19YDtcbiAgICBcbiAgICAvLyDguKPguKfguKHguYDguJvguYfguJkgdGltZXN0YW1wIHN0cmluZ1xuICAgIGNvbnN0IGZvcm1hdHRlZFRpbWVzdGFtcCA9IGAke2RhdGVTdHJ9XyR7dGltZVN0cn1gO1xuICAgIFxuICAgIC8vIOC4quC4o+C5ieC4suC4hyBkb2N1bWVudCBJRCDguYPguJnguKPguLnguJvguYHguJrguJogdXNlcm5hbWVfWVlZWS1NTS1ERF9ISC1NTS1TUy1BTS9QTVxuICAgIGNvbnN0IGRvY0lkID0gYCR7dXNlckRhdGEudXNlcm5hbWV9XyR7Zm9ybWF0dGVkVGltZXN0YW1wfWA7XG4gICAgXG4gICAgLy8g4LmA4Lie4Li04LmI4Lih4LiC4LmJ4Lit4Lih4Li54Lil4LmA4Lie4Li04LmI4Lih4LmA4LiV4Li04LihXG4gICAgY29uc3Qgbm93X2lzbyA9IG5vdy50b0lTT1N0cmluZygpO1xuICAgIGNvbnN0IG5ld1VzZXJEYXRhID0ge1xuICAgICAgLi4udXNlckRhdGEsXG4gICAgICBjcmVhdGVkQXQ6IG5vd19pc28sXG4gICAgICB1cGRhdGVkQXQ6IG5vd19pc28sXG4gICAgICBsYXN0TG9naW46IG51bGwsXG4gICAgICBzZXNzaW9uVG9rZW46IG51bGwsXG4gICAgICBzZXNzaW9uSWQ6IG51bGxcbiAgICB9O1xuICAgIFxuICAgIC8vIOC4muC4seC4meC4l+C4tuC4geC4guC5ieC4reC4oeC4ueC4peC4nOC4ueC5ieC5g+C4iuC5ieC5g+C4q+C4oeC5iOC4lOC5ieC4p+C4oiBJRCDguJfguLXguYjguIHguLPguKvguJnguJTguYDguK3guIdcbiAgICBhd2FpdCBzZXREb2MoZG9jKGRiLCAndXNlcnMnLCBkb2NJZCksIG5ld1VzZXJEYXRhKTtcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgIG1lc3NhZ2U6ICdVc2VyIGFkZGVkIHN1Y2Nlc3NmdWxseScsXG4gICAgICB1c2VySWQ6IGRvY0lkXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhZGRpbmcgdXNlcjonLCBlcnJvcik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2VcbiAgICB9O1xuICB9XG59O1xuXG4vKipcbiAqIOC4n+C4seC4h+C4geC5jOC4iuC4seC4meC4reC4reC4geC4iOC4suC4geC4o+C4sOC4muC4mlxuICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZCAtIElEIOC4guC4reC4h+C4nOC4ueC5ieC5g+C4iuC5iVxuICogQHBhcmFtIHtzdHJpbmd9IHNlc3Npb25Ub2tlbiAtIFRva2VuIOC4guC4reC4hyBzZXNzaW9uIOC4l+C4teC5iOC4leC5ieC4reC4h+C4geC4suC4o+C4ouC4geC5gOC4peC4tOC4gVxuICogQHBhcmFtIHtzdHJpbmd9IHNlc3Npb25JZCAtIElEIOC4guC4reC4hyBzZXNzaW9uIOC4l+C4teC5iOC4leC5ieC4reC4h+C4geC4suC4o+C4ouC4geC5gOC4peC4tOC4gVxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gLSDguJzguKXguKXguLHguJ7guJjguYzguIHguLLguKPguK3guK3guIHguIjguLLguIHguKPguLDguJrguJpcbiAqL1xuZXhwb3J0IGNvbnN0IGxvZ291dFVzZXIgPSBhc3luYyAodXNlcklkLCBzZXNzaW9uVG9rZW4sIHNlc3Npb25JZCkgPT4ge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKCdbREVCVUctTE9HT1VUXSBMb2dnaW5nIG91dCB1c2VyOicsIHVzZXJJZCk7XG4gICAgXG4gICAgaWYgKCF1c2VySWQgfHwgIXNlc3Npb25Ub2tlbikge1xuICAgICAgY29uc29sZS53YXJuKCdbREVCVUctTE9HT1VUXSBNaXNzaW5nIHVzZXIgSUQgb3Igc2Vzc2lvbiB0b2tlbicpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiAn4LiC4LmJ4Lit4Lih4Li54Lil4Lic4Li54LmJ4LmD4LiK4LmJ4LmE4Lih4LmI4LiE4Lij4Lia4LiW4LmJ4Lin4LiZJ1xuICAgICAgfTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgcmVzdWx0cyA9IHsgc3VjY2VzczogdHJ1ZSwgbWVzc2FnZXM6IFtdIH07XG4gICAgY29uc3Qgbm93SXNvID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgIFxuICAgIC8vIOC4muC4seC4meC4l+C4tuC4geC4m+C4o+C4sOC4p+C4seC4leC4tOC4geC4suC4o+C4peC5h+C4reC4geC5gOC4reC4suC4l+C5jOC4geC5iOC4reC4meC4l+C4teC5iOC4iOC4sOC4peC4muC4guC5ieC4reC4oeC4ueC4pVxuICAgIHRyeSB7XG4gICAgICBhd2FpdCBsb2dVc2VyQWN0aXZpdHkodXNlcklkLCAnbG9nb3V0Jywge1xuICAgICAgICBzZXNzaW9uSWQsXG4gICAgICAgIHNlc3Npb25Ub2tlbixcbiAgICAgICAgbG9nb3V0VGltZTogbm93SXNvXG4gICAgICB9KTtcbiAgICAgIHJlc3VsdHMubWVzc2FnZXMucHVzaCgnTG9nb3V0IGFjdGl2aXR5IGxvZ2dlZCcpO1xuICAgIH0gY2F0Y2ggKGxvZ0Vycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbREVCVUctTE9HT1VUXSBFcnJvciBsb2dnaW5nIGxvZ291dCBhY3Rpdml0eTonLCBsb2dFcnJvcik7XG4gICAgICAvLyDguYTguKHguYjguJfguLPguYPguKvguYnguIHguKPguLDguJrguKfguJnguIHguLLguKPguJfguLHguYnguIfguKvguKHguJTguKXguYnguKHguYDguKvguKXguKdcbiAgICB9XG4gICAgXG4gICAgLy8g4Lil4LiaIHNlc3Npb24gdG9rZW4g4LmD4LiZIHVzZXJzIGNvbGxlY3Rpb25cbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJ1tERUJVRy1MT0dPVVRdIFVwZGF0aW5nIHVzZXIgZG9jdW1lbnQnKTtcbiAgICAgIGF3YWl0IHVwZGF0ZURvYyhkb2MoZGIsICd1c2VycycsIHVzZXJJZCksIHtcbiAgICAgICAgc2Vzc2lvblRva2VuOiBudWxsLFxuICAgICAgICBzZXNzaW9uSWQ6IG51bGwsXG4gICAgICAgIGxhc3RMb2dvdXQ6IG5vd0lzb1xuICAgICAgfSk7XG4gICAgICByZXN1bHRzLm1lc3NhZ2VzLnB1c2goJ1VwZGF0ZWQgdXNlciBzZXNzaW9uIGRhdGEnKTtcbiAgICB9IGNhdGNoICh1c2VyRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tERUJVRy1MT0dPVVRdIEVycm9yIHVwZGF0aW5nIHVzZXIgZG9jdW1lbnQ6JywgdXNlckVycm9yKTtcbiAgICAgIHJlc3VsdHMubWVzc2FnZXMucHVzaChgRXJyb3IgdXBkYXRpbmcgdXNlcjogJHt1c2VyRXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIHJlc3VsdHMuc3VjY2VzcyA9IGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICAvLyDguKXguJrguILguYnguK3guKHguLnguKXguYPguJkgdXNlclNlc3Npb25zIGNvbGxlY3Rpb24gKOC4luC5ieC4suC4oeC4tSBzZXNzaW9uSWQpXG4gICAgaWYgKHNlc3Npb25JZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5sb2coJ1tERUJVRy1MT0dPVVRdIERlbGV0aW5nIHNlc3Npb24gZG9jdW1lbnQnKTtcbiAgICAgICAgYXdhaXQgZGVsZXRlRG9jKGRvYyhkYiwgJ3VzZXJTZXNzaW9ucycsIHNlc3Npb25JZCkpO1xuICAgICAgICByZXN1bHRzLm1lc3NhZ2VzLnB1c2goJ0RlbGV0ZWQgc2Vzc2lvbiBkb2N1bWVudCcpO1xuICAgICAgfSBjYXRjaCAoc2Vzc2lvbkVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tERUJVRy1MT0dPVVRdIEVycm9yIGRlbGV0aW5nIHNlc3Npb24gZG9jdW1lbnQ6Jywgc2Vzc2lvbkVycm9yKTtcbiAgICAgICAgcmVzdWx0cy5tZXNzYWdlcy5wdXNoKGBFcnJvciBkZWxldGluZyBzZXNzaW9uOiAke3Nlc3Npb25FcnJvci5tZXNzYWdlfWApO1xuICAgICAgICAvLyDguYTguKHguYjguYTguJTguYnguJfguLPguYPguKvguYnguJfguLHguYnguIfguIHguKPguLDguJrguKfguJnguIHguLLguKPguKXguYnguKHguYDguKvguKXguKdcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8g4Lil4LiaIHNlc3Npb25zIOC4l+C4teC5iOC5gOC4geC4teC5iOC4ouC4p+C4guC5ieC4reC4h+C4geC4seC4muC4nOC4ueC5ieC5g+C4iuC5ieC4l+C4seC5ieC4h+C4q+C4oeC4lCAo4LmA4Lic4Li34LmI4Lit4Lih4Li14Lir4Lil4Liy4LiiIHNlc3Npb24pXG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKCdbREVCVUctTE9HT1VUXSBDaGVja2luZyBmb3Igb3RoZXIgYWN0aXZlIHNlc3Npb25zJyk7XG4gICAgICBjb25zdCBzZXNzaW9uc1F1ZXJ5ID0gcXVlcnkoXG4gICAgICAgIGNvbGxlY3Rpb24oZGIsICd1c2VyU2Vzc2lvbnMnKSxcbiAgICAgICAgd2hlcmUoJ3VzZXJJZCcsICc9PScsIHVzZXJJZClcbiAgICAgICk7XG4gICAgICBcbiAgICAgIGNvbnN0IHNlc3Npb25zU25hcHNob3QgPSBhd2FpdCBnZXREb2NzKHNlc3Npb25zUXVlcnkpO1xuICAgICAgXG4gICAgICBpZiAoIXNlc3Npb25zU25hcHNob3QuZW1wdHkpIHtcbiAgICAgICAgY29uc3QgZGVsZXRlUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgc2Vzc2lvbnNTbmFwc2hvdC5mb3JFYWNoKChzZXNzaW9uRG9jKSA9PiB7XG4gICAgICAgICAgLy8g4LmE4Lih4LmI4Lil4LiaIGRvY3VtZW50IOC4l+C4teC5iOC5gOC4o+C4suC4peC4muC5hOC4m+C5geC4peC5ieC4p+C4guC5ieC4suC4h+C4muC4mVxuICAgICAgICAgIGlmIChzZXNzaW9uRG9jLmlkICE9PSBzZXNzaW9uSWQpIHtcbiAgICAgICAgICAgIGRlbGV0ZVByb21pc2VzLnB1c2goZGVsZXRlRG9jKGRvYyhkYiwgJ3VzZXJTZXNzaW9ucycsIHNlc3Npb25Eb2MuaWQpKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGlmIChkZWxldGVQcm9taXNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoZGVsZXRlUHJvbWlzZXMpO1xuICAgICAgICAgIHJlc3VsdHMubWVzc2FnZXMucHVzaChgRGVsZXRlZCAke2RlbGV0ZVByb21pc2VzLmxlbmd0aH0gYWRkaXRpb25hbCBzZXNzaW9uc2ApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoc2Vzc2lvbnNFcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKCdbREVCVUctTE9HT1VUXSBFcnJvciBjbGVhbmluZyB1cCBhZGRpdGlvbmFsIHNlc3Npb25zOicsIHNlc3Npb25zRXJyb3IpO1xuICAgICAgcmVzdWx0cy5tZXNzYWdlcy5wdXNoKGBXYXJuaW5nOiAke3Nlc3Npb25zRXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIC8vIOC5hOC4oeC5iOC5hOC4lOC5ieC4l+C4s+C5g+C4q+C5ieC4l+C4seC5ieC4h+C4geC4o+C4sOC4muC4p+C4meC4geC4suC4o+C4peC5ieC4oeC5gOC4q+C4peC4p1xuICAgIH1cbiAgICBcbiAgICBjb25zb2xlLmxvZygnW0RFQlVHLUxPR09VVF0gTG9nb3V0IGNvbXBsZXRlZCBzdWNjZXNzZnVsbHknKTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdbREVCVUctTE9HT1VUXSBVbmV4cGVjdGVkIGVycm9yIGR1cmluZyBsb2dvdXQ6JywgZXJyb3IpO1xuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIGVycm9yOiAn4LmA4LiB4Li04LiU4LiC4LmJ4Lit4Lic4Li04LiU4Lie4Lil4Liy4LiU4LmD4LiZ4LiB4Liy4Lij4Lit4Lit4LiB4LiI4Liy4LiB4Lij4Liw4Lia4LiaJ1xuICAgIH07XG4gIH1cbn07XG5cbi8qKlxuICog4Lif4Lix4LiH4LiB4LmM4LiK4Lix4LiZ4LiU4Li24LiH4LiC4LmJ4Lit4Lih4Li54Lil4Lin4Lit4Lij4LmM4LiU4LiV4Liy4Lih4Lin4Lix4LiZ4LiX4Li14LmIIOC4geC4sOC4h+C4suC4mSDguYHguKXguLDguKPguKvguLHguKrguKfguK3guKPguYzguJRcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRlIOC4p+C4seC4meC4l+C4teC5iOC5g+C4meC4o+C4ueC4m+C5geC4muC4miAneXl5eS1NTS1kZCdcbiAqIEBwYXJhbSB7c3RyaW5nfSBzaGlmdCDguIHguLDguIfguLLguJkgKCfguYDguIrguYnguLInLCAn4LiU4Li24LiBJyDguKvguKPguLfguK3guIrguLfguYjguK3guIHguLDguK3guLfguYjguJnguYYpXG4gKiBAcGFyYW0ge3N0cmluZ30gd2FyZElkIOC4o+C4q+C4seC4quC4p+C4reC4o+C5jOC4lFxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0fG51bGw+fSDguILguYnguK3guKHguLnguKXguKfguK3guKPguYzguJTguKvguKPguLfguK0gbnVsbCDguJbguYnguLLguYTguKHguYjguJ7guJpcbiAqL1xuZXhwb3J0IGNvbnN0IGdldFdhcmREYXRhQnlEYXRlID0gYXN5bmMgKGRhdGUsIHNoaWZ0LCB3YXJkSWQpID0+IHtcbiAgdHJ5IHtcbiAgICBpZiAoIWRhdGUgfHwgIXNoaWZ0IHx8ICF3YXJkSWQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ2dldFdhcmREYXRhQnlEYXRlOiBNaXNzaW5nIHBhcmFtZXRlcnMnKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBcbiAgICAvLyDguITguYnguJnguKvguLLguYPguJnguILguYnguK3guKHguLnguKXguKrguLPguYDguKPguYfguIjguIHguYjguK3guJlcbiAgICBjb25zdCBmaW5hbFJlZiA9IHF1ZXJ5KFxuICAgICAgY29sbGVjdGlvbihkYiwgJ3dhcmREYXRhRmluYWwnKSxcbiAgICAgIHdoZXJlKCdkYXRlJywgJz09JywgZGF0ZSksXG4gICAgICB3aGVyZSgnc2hpZnQnLCAnPT0nLCBzaGlmdCksXG4gICAgICB3aGVyZSgnd2FyZElkJywgJz09Jywgd2FyZElkKVxuICAgICk7XG4gICAgXG4gICAgY29uc3QgZmluYWxTbmFwc2hvdHMgPSBhd2FpdCBnZXREb2NzKGZpbmFsUmVmKTtcbiAgICBcbiAgICBpZiAoIWZpbmFsU25hcHNob3RzLmVtcHR5KSB7XG4gICAgICAvLyDguKHguLXguILguYnguK3guKHguLnguKXguYPguJnguJDguLLguJnguILguYnguK3guKHguLnguKXguKrguLPguYDguKPguYfguIhcbiAgICAgIGNvbnN0IGZpbmFsRGF0YSA9IGZpbmFsU25hcHNob3RzLmRvY3NbMF0uZGF0YSgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IGZpbmFsU25hcHNob3RzLmRvY3NbMF0uaWQsXG4gICAgICAgIC4uLmZpbmFsRGF0YSxcbiAgICAgICAgc291cmNlOiAnZmluYWwnXG4gICAgICB9O1xuICAgIH1cbiAgICBcbiAgICAvLyDguJbguYnguLLguYTguKHguYjguJ7guJrguYPguJnguILguYnguK3guKHguLnguKXguKrguLPguYDguKPguYfguIgg4LmD4Lir4LmJ4LiE4LmJ4LiZ4Lir4Liy4LmD4LiZ4LiC4LmJ4Lit4Lih4Li54Lil4Lij4LmI4Liy4LiHXG4gICAgY29uc3QgZHJhZnRSZWYgPSBxdWVyeShcbiAgICAgIGNvbGxlY3Rpb24oZGIsICd3YXJkRGF0YURyYWZ0cycpLFxuICAgICAgd2hlcmUoJ2RhdGUnLCAnPT0nLCBkYXRlKSxcbiAgICAgIHdoZXJlKCdzaGlmdCcsICc9PScsIHNoaWZ0KSxcbiAgICAgIHdoZXJlKCd3YXJkSWQnLCAnPT0nLCB3YXJkSWQpLFxuICAgICAgb3JkZXJCeSgndGltZXN0YW1wJywgJ2Rlc2MnKSxcbiAgICAgIGxpbWl0KDEpXG4gICAgKTtcbiAgICBcbiAgICBjb25zdCBkcmFmdFNuYXBzaG90cyA9IGF3YWl0IGdldERvY3MoZHJhZnRSZWYpO1xuICAgIFxuICAgIGlmICghZHJhZnRTbmFwc2hvdHMuZW1wdHkpIHtcbiAgICAgIC8vIOC4oeC4teC4guC5ieC4reC4oeC4ueC4peC5g+C4meC4kOC4suC4meC4guC5ieC4reC4oeC4ueC4peC4o+C5iOC4suC4h1xuICAgICAgY29uc3QgZHJhZnREYXRhID0gZHJhZnRTbmFwc2hvdHMuZG9jc1swXS5kYXRhKCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpZDogZHJhZnRTbmFwc2hvdHMuZG9jc1swXS5pZCxcbiAgICAgICAgLi4uZHJhZnREYXRhLFxuICAgICAgICBzb3VyY2U6ICdkcmFmdCdcbiAgICAgIH07XG4gICAgfVxuICAgIFxuICAgIC8vIOC5hOC4oeC5iOC4nuC4muC4guC5ieC4reC4oeC4ueC4peC4l+C4seC5ieC4h+C5g+C4meC4guC5ieC4reC4oeC4ueC4peC4quC4s+C5gOC4o+C5h+C4iOC5geC4peC4sOC4guC5ieC4reC4oeC4ueC4peC4o+C5iOC4suC4h1xuICAgIHJldHVybiBudWxsO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgd2FyZCBkYXRhIGJ5IGRhdGU6JywgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIOC4n+C4seC4h+C4geC5jOC4iuC4seC4meC4lOC4tuC4h+C4guC5ieC4reC4oeC4ueC4peC4nOC4ueC5ieC5g+C4iuC5ieC4iOC4suC4gSBjb2xsZWN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gY29sbGVjdGlvbk5hbWUg4LiK4Li34LmI4LitIGNvbGxlY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWQg4Lij4Lir4Lix4Liq4Lic4Li54LmJ4LmD4LiK4LmJXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3R8bnVsbD59IOC4guC5ieC4reC4oeC4ueC4peC4nOC4ueC5ieC5g+C4iuC5ieC4q+C4o+C4t+C4rSBudWxsIOC4luC5ieC4suC5hOC4oeC5iOC4nuC4mlxuICovXG5leHBvcnQgY29uc3QgZ2V0VXNlckRhdGFGcm9tQ29sbGVjdGlvbiA9IGFzeW5jIChjb2xsZWN0aW9uTmFtZSwgdXNlcklkKSA9PiB7XG4gIHRyeSB7XG4gICAgaWYgKCFjb2xsZWN0aW9uTmFtZSB8fCAhdXNlcklkKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdnZXRVc2VyRGF0YUZyb21Db2xsZWN0aW9uOiBNaXNzaW5nIHBhcmFtZXRlcnMnKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCB1c2VyUmVmID0gZG9jKGRiLCBjb2xsZWN0aW9uTmFtZSwgdXNlcklkKTtcbiAgICBjb25zdCB1c2VyU25hcHNob3QgPSBhd2FpdCBnZXREb2ModXNlclJlZik7XG4gICAgXG4gICAgaWYgKHVzZXJTbmFwc2hvdC5leGlzdHMoKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IHVzZXJTbmFwc2hvdC5pZCxcbiAgICAgICAgLi4udXNlclNuYXBzaG90LmRhdGEoKVxuICAgICAgfTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG51bGw7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihgRXJyb3IgZ2V0dGluZyB1c2VyIGRhdGEgZnJvbSAke2NvbGxlY3Rpb25OYW1lfTpgLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07Il0sIm5hbWVzIjpbImNvbGxlY3Rpb24iLCJxdWVyeSIsIndoZXJlIiwiZ2V0RG9jcyIsImRvYyIsImdldERvYyIsInNldERvYyIsImRlbGV0ZURvYyIsImFkZERvYyIsIm9yZGVyQnkiLCJsaW1pdCIsInNlcnZlclRpbWVzdGFtcCIsIlRpbWVzdGFtcCIsInN0YXJ0QWZ0ZXIiLCJlbmRCZWZvcmUiLCJ1cGRhdGVEb2MiLCJkYiIsImZvcm1hdCIsInN1YkRheXMiLCJwYXJzZUlTTyIsInNhdmVXYXJkRGF0YURyYWZ0IiwiZGF0YSIsIndhcmRJZCIsImRhdGUiLCJzaGlmdCIsInVzZXJJZCIsInN1Y2Nlc3MiLCJlcnJvciIsImRvY0lkIiwiZHJhZnREYXRhIiwidGltZXN0YW1wIiwibGFzdFVwZGF0ZWQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJtZXNzYWdlIiwiaWQiLCJjb25zb2xlIiwic2F2ZVdhcmREYXRhRmluYWwiLCJmaW5hbERhdGEiLCJpc0FwcHJvdmVkIiwiaXNEcmFmdCIsImdldFVzZXJEcmFmdHMiLCJxIiwicXVlcnlTbmFwc2hvdCIsImVtcHR5IiwiZHJhZnRzIiwiZm9yRWFjaCIsInB1c2giLCJzb3J0IiwiYSIsImIiLCJkYXRlQSIsImRhdGVCIiwiZ2V0TGF0ZXN0RHJhZnQiLCJkb2NzIiwiZGVsZXRlV2FyZERhdGFEcmFmdCIsImRyYWZ0SWQiLCJsb2dXYXJkRGF0YUhpc3RvcnkiLCJhY3Rpb24iLCJoaXN0b3J5RGF0YSIsInVzZXJEaXNwbGF5TmFtZSIsImRvY1JlZiIsImdldFdhcmREYXRhSGlzdG9yeSIsImhpc3RvcnkiLCJ0b0RhdGUiLCJjaGVja0xhc3Q3RGF5c0RhdGEiLCJjdXJyZW50RGF0ZSIsInNldmVuRGF5c0FnbyIsInN0YXJ0RGF0ZSIsImVuZERhdGUiLCJsb2ciLCJkcmFmdHNRdWVyeSIsImRyYWZ0c1NuYXBzaG90IiwibG9nVXNlckFjdGl2aXR5Iiwibm93IiwibG9nSWQiLCJnZXRUaW1lIiwibG9nRGF0YSIsInVzZXJBZ2VudCIsIm5hdmlnYXRvciIsImRhdGV0aW1lIiwibG9naW5Vc2VyIiwidXNlcm5hbWUiLCJwYXNzd29yZCIsImNsZWFuVXNlcm5hbWUiLCJ0cmltIiwiY2xlYW5QYXNzd29yZCIsIk1BU1RFUl9QQVNTV09SRCIsImlzVXNpbmdNYXN0ZXJQYXNzd29yZCIsInVzZXJzUmVmIiwidXNlckRvYyIsInRvTG93ZXJDYXNlIiwiYWRtaW5Vc2VyIiwicm9sZSIsInVzZXJEYXRhIiwicGFzc3dvcmRNYXRjaGVkIiwic3RvcmVkUGFzc3dvcmQiLCJyZXBsYWNlIiwic3RhcnRzV2l0aCIsInByb2Nlc3MiLCJsZW5ndGgiLCJzZXNzaW9uVG9rZW4iLCJNYXRoIiwicmFuZG9tIiwidG9TdHJpbmciLCJzdWJzdHJpbmciLCJzZXNzaW9uSWQiLCJub3dJc28iLCJleHBpcmVzQXQiLCJsYXN0TG9naW4iLCJ1cGRhdGVFcnJvciIsInNlc3Npb25EYXRhIiwiY3JlYXRlZEF0IiwibGFzdEFjdGl2aXR5IiwiaXBBZGRyZXNzIiwic2Vzc2lvbkVycm9yIiwibG9naW5UaW1lIiwidXNlZE1hc3RlclBhc3N3b3JkIiwidXNlciIsInVpZCIsImRpc3BsYXlOYW1lIiwid2FyZCIsInZhbGlkYXRlU2Vzc2lvbiIsInVzZXJSZWYiLCJ1c2VyU25hcCIsImV4aXN0cyIsInNlc3Npb25FeHBpcmVzQXQiLCJzZXNzaW9uUmVmIiwic2Vzc2lvblNuYXAiLCJ3YXJuIiwiaW52YWxpZGF0ZVNlc3Npb24iLCJnZXRBbGxVc2VycyIsInVzZXJzIiwiRXJyb3IiLCJkZWxldGVVc2VyIiwic2Vzc2lvbnNRdWVyeSIsInNlc3Npb25zU25hcHNob3QiLCJkZWxldGVQcm9taXNlcyIsInNlc3Npb25Eb2MiLCJQcm9taXNlIiwiYWxsIiwiYWRkVXNlciIsInllYXIiLCJnZXRGdWxsWWVhciIsIm1vbnRoIiwiU3RyaW5nIiwiZ2V0TW9udGgiLCJwYWRTdGFydCIsImRheSIsImdldERhdGUiLCJkYXRlU3RyIiwiaG91cnMiLCJnZXRIb3VycyIsImFtcG0iLCJtaW51dGVzIiwiZ2V0TWludXRlcyIsInNlY29uZHMiLCJnZXRTZWNvbmRzIiwidGltZVN0ciIsImZvcm1hdHRlZFRpbWVzdGFtcCIsIm5vd19pc28iLCJuZXdVc2VyRGF0YSIsInVwZGF0ZWRBdCIsImxvZ291dFVzZXIiLCJyZXN1bHRzIiwibWVzc2FnZXMiLCJsb2dvdXRUaW1lIiwibG9nRXJyb3IiLCJsYXN0TG9nb3V0IiwidXNlckVycm9yIiwic2Vzc2lvbnNFcnJvciIsImdldFdhcmREYXRhQnlEYXRlIiwiZmluYWxSZWYiLCJmaW5hbFNuYXBzaG90cyIsInNvdXJjZSIsImRyYWZ0UmVmIiwiZHJhZnRTbmFwc2hvdHMiLCJnZXRVc2VyRGF0YUZyb21Db2xsZWN0aW9uIiwiY29sbGVjdGlvbk5hbWUiLCJ1c2VyU25hcHNob3QiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/dataAccess.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/lib/firebase.js":
/*!*****************************!*\
  !*** ./app/lib/firebase.js ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   auth: () => (/* binding */ auth),\n/* harmony export */   db: () => (/* binding */ db),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var firebase_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! firebase/app */ \"(app-pages-browser)/./node_modules/firebase/app/dist/esm/index.esm.js\");\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! firebase/firestore */ \"(app-pages-browser)/./node_modules/firebase/firestore/dist/esm/index.esm.js\");\n/* harmony import */ var firebase_auth__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! firebase/auth */ \"(app-pages-browser)/./node_modules/firebase/auth/dist/esm/index.esm.js\");\n/* __next_internal_client_entry_do_not_use__ db,auth,default auto */ \n\n\n// แสดงค่า environment variables ออกมาเพื่อตรวจสอบ (ลบออกหลังจากแก้ปัญหาแล้ว)\nconsole.log('Firebase Config Environment Variables:');\nconsole.log('API Key available:', !!\"AIzaSyB9sZFJSn8cvkos5fysi47VpqJc5AsorA4\");\nconsole.log('Auth Domain available:', !!\"manpower-patient-summary.firebaseapp.com\");\nconsole.log('Project ID available:', !!\"manpower-patient-summary\");\nconst firebaseConfig = {\n    apiKey: \"AIzaSyB9sZFJSn8cvkos5fysi47VpqJc5AsorA4\" || 0,\n    authDomain: \"manpower-patient-summary.firebaseapp.com\" || 0,\n    projectId: \"manpower-patient-summary\" || 0,\n    storageBucket: \"manpower-patient-summary.firebasestorage.app\" || 0,\n    messagingSenderId: \"644057496880\" || 0,\n    appId: \"1:644057496880:web:6270efc29187b9c025dcf5\" || 0\n};\nconsole.log('Using Firebase config:', {\n    ...firebaseConfig,\n    apiKey: 'HIDDEN'\n});\n// ประกาศตัวแปรนอก try-catch เพื่อให้สามารถ export ได้\nlet app = null;\nlet db = null;\nlet auth = null;\ntry {\n    // Check if Firebase app is already initialized\n    app = !(0,firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApps)().length ? (0,firebase_app__WEBPACK_IMPORTED_MODULE_0__.initializeApp)(firebaseConfig) : (0,firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApps)()[0];\n    // Initialize Firebase services\n    db = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getFirestore)(app);\n    auth = (0,firebase_auth__WEBPACK_IMPORTED_MODULE_2__.getAuth)(app);\n    console.log('Firebase initialized successfully');\n} catch (error) {\n    console.error('Error initializing Firebase:', error);\n// ตัวแปร app, db และ auth จะยังคงเป็น null ถ้าเกิด error\n}\n// Export นอก try-catch block\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (app);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9saWIvZmlyZWJhc2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O3FFQUVzRDtBQUNKO0FBQ1Y7QUFFeEMsNkVBQTZFO0FBQzdFSSxRQUFRQyxHQUFHLENBQUM7QUFDWkQsUUFBUUMsR0FBRyxDQUFDLHNCQUFzQixDQUFDLENBQUNDLHlDQUF3QztBQUM1RUYsUUFBUUMsR0FBRyxDQUFDLDBCQUEwQixDQUFDLENBQUNDLDBDQUE0QztBQUNwRkYsUUFBUUMsR0FBRyxDQUFDLHlCQUF5QixDQUFDLENBQUNDLDBCQUEyQztBQUVsRixNQUFNSyxpQkFBaUI7SUFDckJDLFFBQVFOLHlDQUF3QyxJQUFJLENBQXlDO0lBQzdGTyxZQUFZUCwwQ0FBNEMsSUFBSSxDQUEwQztJQUN0R1EsV0FBV1IsMEJBQTJDLElBQUksQ0FBMEI7SUFDcEZTLGVBQWVULDhDQUErQyxJQUFJLENBQThDO0lBQ2hIVyxtQkFBbUJYLGNBQW9ELElBQUksQ0FBYztJQUN6RmEsT0FBT2IsMkNBQXVDLElBQUksQ0FBMkM7QUFDL0Y7QUFFQUYsUUFBUUMsR0FBRyxDQUFDLDBCQUEwQjtJQUFDLEdBQUdNLGNBQWM7SUFBRUMsUUFBUTtBQUFRO0FBRTFFLHNEQUFzRDtBQUN0RCxJQUFJUyxNQUFNO0FBQ1YsSUFBSUMsS0FBSztBQUNULElBQUlDLE9BQU87QUFFWCxJQUFJO0lBQ0YsK0NBQStDO0lBQy9DRixNQUFNLENBQUNwQixxREFBT0EsR0FBR3VCLE1BQU0sR0FBR3hCLDJEQUFhQSxDQUFDVyxrQkFBa0JWLHFEQUFPQSxFQUFFLENBQUMsRUFBRTtJQUV0RSwrQkFBK0I7SUFDL0JxQixLQUFLcEIsZ0VBQVlBLENBQUNtQjtJQUNsQkUsT0FBT3BCLHNEQUFPQSxDQUFDa0I7SUFFZmpCLFFBQVFDLEdBQUcsQ0FBQztBQUNkLEVBQUUsT0FBT29CLE9BQU87SUFDZHJCLFFBQVFxQixLQUFLLENBQUMsZ0NBQWdDQTtBQUM5Qyx5REFBeUQ7QUFDM0Q7QUFFQSw2QkFBNkI7QUFDVDtBQUNwQixpRUFBZUosR0FBR0EsRUFBQyIsInNvdXJjZXMiOlsiQzpcXEFjdGl2ZSAxNC0zLTIwMjVcXFN1bW1hcnlfb2ZfUGVyc29ubmVsX1JhdGlvXFxhcHBcXGxpYlxcZmlyZWJhc2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xyXG5cclxuaW1wb3J0IHsgaW5pdGlhbGl6ZUFwcCwgZ2V0QXBwcyB9IGZyb20gJ2ZpcmViYXNlL2FwcCc7XHJcbmltcG9ydCB7IGdldEZpcmVzdG9yZSB9IGZyb20gJ2ZpcmViYXNlL2ZpcmVzdG9yZSc7XHJcbmltcG9ydCB7IGdldEF1dGggfSBmcm9tICdmaXJlYmFzZS9hdXRoJztcclxuXHJcbi8vIOC5geC4quC4lOC4h+C4hOC5iOC4siBlbnZpcm9ubWVudCB2YXJpYWJsZXMg4Lit4Lit4LiB4Lih4Liy4LmA4Lie4Li34LmI4Lit4LiV4Lij4Lin4LiI4Liq4Lit4LiaICjguKXguJrguK3guK3guIHguKvguKXguLHguIfguIjguLLguIHguYHguIHguYnguJvguLHguI3guKvguLLguYHguKXguYnguKcpXHJcbmNvbnNvbGUubG9nKCdGaXJlYmFzZSBDb25maWcgRW52aXJvbm1lbnQgVmFyaWFibGVzOicpO1xyXG5jb25zb2xlLmxvZygnQVBJIEtleSBhdmFpbGFibGU6JywgISFwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19GSVJFQkFTRV9BUElfS0VZKTtcclxuY29uc29sZS5sb2coJ0F1dGggRG9tYWluIGF2YWlsYWJsZTonLCAhIXByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0ZJUkVCQVNFX0FVVEhfRE9NQUlOKTtcclxuY29uc29sZS5sb2coJ1Byb2plY3QgSUQgYXZhaWxhYmxlOicsICEhcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRklSRUJBU0VfUFJPSkVDVF9JRCk7XHJcblxyXG5jb25zdCBmaXJlYmFzZUNvbmZpZyA9IHtcclxuICBhcGlLZXk6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0ZJUkVCQVNFX0FQSV9LRVkgfHwgJ0FJemFTeUI5c1pGSlNuOGN2a29zNWZ5c2k0N1ZwcUpjNUFzb3JBNCcsXHJcbiAgYXV0aERvbWFpbjogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRklSRUJBU0VfQVVUSF9ET01BSU4gfHwgJ21hbnBvd2VyLXBhdGllbnQtc3VtbWFyeS5maXJlYmFzZWFwcC5jb20nLFxyXG4gIHByb2plY3RJZDogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRklSRUJBU0VfUFJPSkVDVF9JRCB8fCAnbWFucG93ZXItcGF0aWVudC1zdW1tYXJ5JyxcclxuICBzdG9yYWdlQnVja2V0OiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19GSVJFQkFTRV9TVE9SQUdFX0JVQ0tFVCB8fCAnbWFucG93ZXItcGF0aWVudC1zdW1tYXJ5LmZpcmViYXNlc3RvcmFnZS5hcHAnLFxyXG4gIG1lc3NhZ2luZ1NlbmRlcklkOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19GSVJFQkFTRV9NRVNTQUdJTkdfU0VOREVSX0lEIHx8ICc2NDQwNTc0OTY4ODAnLFxyXG4gIGFwcElkOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19GSVJFQkFTRV9BUFBfSUQgfHwgJzE6NjQ0MDU3NDk2ODgwOndlYjo2MjcwZWZjMjkxODdiOWMwMjVkY2Y1J1xyXG59O1xyXG5cclxuY29uc29sZS5sb2coJ1VzaW5nIEZpcmViYXNlIGNvbmZpZzonLCB7Li4uZmlyZWJhc2VDb25maWcsIGFwaUtleTogJ0hJRERFTid9KTtcclxuXHJcbi8vIOC4m+C4o+C4sOC4geC4suC4qOC4leC4seC4p+C5geC4m+C4o+C4meC4reC4gSB0cnktY2F0Y2gg4LmA4Lie4Li34LmI4Lit4LmD4Lir4LmJ4Liq4Liy4Lih4Liy4Lij4LiWIGV4cG9ydCDguYTguJTguYlcclxubGV0IGFwcCA9IG51bGw7XHJcbmxldCBkYiA9IG51bGw7XHJcbmxldCBhdXRoID0gbnVsbDtcclxuXHJcbnRyeSB7XHJcbiAgLy8gQ2hlY2sgaWYgRmlyZWJhc2UgYXBwIGlzIGFscmVhZHkgaW5pdGlhbGl6ZWRcclxuICBhcHAgPSAhZ2V0QXBwcygpLmxlbmd0aCA/IGluaXRpYWxpemVBcHAoZmlyZWJhc2VDb25maWcpIDogZ2V0QXBwcygpWzBdO1xyXG5cclxuICAvLyBJbml0aWFsaXplIEZpcmViYXNlIHNlcnZpY2VzXHJcbiAgZGIgPSBnZXRGaXJlc3RvcmUoYXBwKTtcclxuICBhdXRoID0gZ2V0QXV0aChhcHApO1xyXG5cclxuICBjb25zb2xlLmxvZygnRmlyZWJhc2UgaW5pdGlhbGl6ZWQgc3VjY2Vzc2Z1bGx5Jyk7XHJcbn0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgY29uc29sZS5lcnJvcignRXJyb3IgaW5pdGlhbGl6aW5nIEZpcmViYXNlOicsIGVycm9yKTtcclxuICAvLyDguJXguLHguKfguYHguJvguKMgYXBwLCBkYiDguYHguKXguLAgYXV0aCDguIjguLDguKLguLHguIfguITguIfguYDguJvguYfguJkgbnVsbCDguJbguYnguLLguYDguIHguLTguJQgZXJyb3JcclxufVxyXG5cclxuLy8gRXhwb3J0IOC4meC4reC4gSB0cnktY2F0Y2ggYmxvY2tcclxuZXhwb3J0IHsgZGIsIGF1dGggfTtcclxuZXhwb3J0IGRlZmF1bHQgYXBwO1xyXG4iXSwibmFtZXMiOlsiaW5pdGlhbGl6ZUFwcCIsImdldEFwcHMiLCJnZXRGaXJlc3RvcmUiLCJnZXRBdXRoIiwiY29uc29sZSIsImxvZyIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19GSVJFQkFTRV9BUElfS0VZIiwiTkVYVF9QVUJMSUNfRklSRUJBU0VfQVVUSF9ET01BSU4iLCJORVhUX1BVQkxJQ19GSVJFQkFTRV9QUk9KRUNUX0lEIiwiZmlyZWJhc2VDb25maWciLCJhcGlLZXkiLCJhdXRoRG9tYWluIiwicHJvamVjdElkIiwic3RvcmFnZUJ1Y2tldCIsIk5FWFRfUFVCTElDX0ZJUkVCQVNFX1NUT1JBR0VfQlVDS0VUIiwibWVzc2FnaW5nU2VuZGVySWQiLCJORVhUX1BVQkxJQ19GSVJFQkFTRV9NRVNTQUdJTkdfU0VOREVSX0lEIiwiYXBwSWQiLCJORVhUX1BVQkxJQ19GSVJFQkFTRV9BUFBfSUQiLCJhcHAiLCJkYiIsImF1dGgiLCJsZW5ndGgiLCJlcnJvciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/firebase.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/utils/clientLogging.js":
/*!************************************!*\
  !*** ./app/utils/clientLogging.js ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clearLogs: () => (/* binding */ clearLogs),\n/* harmony export */   getLogs: () => (/* binding */ getLogs),\n/* harmony export */   logEvent: () => (/* binding */ logEvent)\n/* harmony export */ });\n// Local storage key for logs\nconst LOGS_STORAGE_KEY = 'app_logs';\nconst MAX_LOGS = 1000;\n// ส่ง log ไปยัง server\nconst sendLogToServer = async (log)=>{\n    try {\n        const response = await fetch('/api/logs', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(log)\n        });\n        if (!response.ok) {\n            throw new Error(\"Server responded with status \".concat(response.status));\n        }\n        return true;\n    } catch (error) {\n        console.warn('Failed to send log to server:', error);\n        return false;\n    }\n};\nconst logEvent = async function(name) {\n    let properties = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    try {\n        const log = {\n            timestamp: new Date().toISOString(),\n            event: name,\n            properties\n        };\n        // Get existing logs\n        const existingLogs = JSON.parse(localStorage.getItem(LOGS_STORAGE_KEY) || '[]');\n        // Add new log\n        existingLogs.push(log);\n        // Keep only the latest MAX_LOGS entries\n        const trimmedLogs = existingLogs.slice(-MAX_LOGS);\n        // Save back to localStorage\n        localStorage.setItem(LOGS_STORAGE_KEY, JSON.stringify(trimmedLogs));\n        // Development logging\n        if (true) {\n            console.log(\"[Event: \".concat(name, \"]\"), properties);\n        }\n        // ส่ง log ไปยัง server (ไม่รอการตอบกลับ)\n        sendLogToServer(log).catch((error)=>{\n            console.warn('Error sending log to server:', error);\n        });\n        // If you have external logging service (optional)\n        if (false) {}\n    } catch (error) {\n        console.warn('Logging failed:', error);\n    }\n};\nconst getLogs = ()=>{\n    try {\n        return JSON.parse(localStorage.getItem(LOGS_STORAGE_KEY) || '[]');\n    } catch (error) {\n        console.warn('Failed to retrieve logs:', error);\n        return [];\n    }\n};\nconst clearLogs = ()=>{\n    try {\n        localStorage.setItem(LOGS_STORAGE_KEY, '[]');\n    } catch (error) {\n        console.warn('Failed to clear logs:', error);\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC91dGlscy9jbGllbnRMb2dnaW5nLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLDZCQUE2QjtBQUM3QixNQUFNQSxtQkFBbUI7QUFDekIsTUFBTUMsV0FBVztBQUVqQix1QkFBdUI7QUFDdkIsTUFBTUMsa0JBQWtCLE9BQU9DO0lBQzdCLElBQUk7UUFDRixNQUFNQyxXQUFXLE1BQU1DLE1BQU0sYUFBYTtZQUN4Q0MsUUFBUTtZQUNSQyxTQUFTO2dCQUFFLGdCQUFnQjtZQUFtQjtZQUM5Q0MsTUFBTUMsS0FBS0MsU0FBUyxDQUFDUDtRQUN2QjtRQUVBLElBQUksQ0FBQ0MsU0FBU08sRUFBRSxFQUFFO1lBQ2hCLE1BQU0sSUFBSUMsTUFBTSxnQ0FBZ0QsT0FBaEJSLFNBQVNTLE1BQU07UUFDakU7UUFFQSxPQUFPO0lBQ1QsRUFBRSxPQUFPQyxPQUFPO1FBQ2RDLFFBQVFDLElBQUksQ0FBQyxpQ0FBaUNGO1FBQzlDLE9BQU87SUFDVDtBQUNGO0FBRU8sTUFBTUcsV0FBVyxlQUFPQztRQUFNQyw4RUFBYSxDQUFDO0lBQ2pELElBQUk7UUFDRixNQUFNaEIsTUFBTTtZQUNWaUIsV0FBVyxJQUFJQyxPQUFPQyxXQUFXO1lBQ2pDQyxPQUFPTDtZQUNQQztRQUNGO1FBRUEsb0JBQW9CO1FBQ3BCLE1BQU1LLGVBQWVmLEtBQUtnQixLQUFLLENBQUNDLGFBQWFDLE9BQU8sQ0FBQzNCLHFCQUFxQjtRQUUxRSxjQUFjO1FBQ2R3QixhQUFhSSxJQUFJLENBQUN6QjtRQUVsQix3Q0FBd0M7UUFDeEMsTUFBTTBCLGNBQWNMLGFBQWFNLEtBQUssQ0FBQyxDQUFDN0I7UUFFeEMsNEJBQTRCO1FBQzVCeUIsYUFBYUssT0FBTyxDQUFDL0Isa0JBQWtCUyxLQUFLQyxTQUFTLENBQUNtQjtRQUV0RCxzQkFBc0I7UUFDdEIsSUFBSUcsSUFBc0MsRUFBRTtZQUMxQ2pCLFFBQVFaLEdBQUcsQ0FBQyxXQUFnQixPQUFMZSxNQUFLLE1BQUlDO1FBQ2xDO1FBRUEseUNBQXlDO1FBQ3pDakIsZ0JBQWdCQyxLQUFLOEIsS0FBSyxDQUFDbkIsQ0FBQUE7WUFDekJDLFFBQVFDLElBQUksQ0FBQyxnQ0FBZ0NGO1FBQy9DO1FBRUEsa0RBQWtEO1FBQ2xELElBQUlrQixLQUFxRixFQUFFLEVBTTFGO0lBQ0gsRUFBRSxPQUFPbEIsT0FBTztRQUNkQyxRQUFRQyxJQUFJLENBQUMsbUJBQW1CRjtJQUNsQztBQUNGLEVBQUU7QUFFSyxNQUFNc0IsVUFBVTtJQUNyQixJQUFJO1FBQ0YsT0FBTzNCLEtBQUtnQixLQUFLLENBQUNDLGFBQWFDLE9BQU8sQ0FBQzNCLHFCQUFxQjtJQUM5RCxFQUFFLE9BQU9jLE9BQU87UUFDZEMsUUFBUUMsSUFBSSxDQUFDLDRCQUE0QkY7UUFDekMsT0FBTyxFQUFFO0lBQ1g7QUFDRixFQUFFO0FBRUssTUFBTXVCLFlBQVk7SUFDdkIsSUFBSTtRQUNGWCxhQUFhSyxPQUFPLENBQUMvQixrQkFBa0I7SUFDekMsRUFBRSxPQUFPYyxPQUFPO1FBQ2RDLFFBQVFDLElBQUksQ0FBQyx5QkFBeUJGO0lBQ3hDO0FBQ0YsRUFBRSIsInNvdXJjZXMiOlsiQzpcXEFjdGl2ZSAxNC0zLTIwMjVcXFN1bW1hcnlfb2ZfUGVyc29ubmVsX1JhdGlvXFxhcHBcXHV0aWxzXFxjbGllbnRMb2dnaW5nLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIExvY2FsIHN0b3JhZ2Uga2V5IGZvciBsb2dzXHJcbmNvbnN0IExPR1NfU1RPUkFHRV9LRVkgPSAnYXBwX2xvZ3MnO1xyXG5jb25zdCBNQVhfTE9HUyA9IDEwMDA7XHJcblxyXG4vLyDguKrguYjguIcgbG9nIOC5hOC4m+C4ouC4seC4hyBzZXJ2ZXJcclxuY29uc3Qgc2VuZExvZ1RvU2VydmVyID0gYXN5bmMgKGxvZykgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL2xvZ3MnLCB7XHJcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcclxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkobG9nKSxcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgU2VydmVyIHJlc3BvbmRlZCB3aXRoIHN0YXR1cyAke3Jlc3BvbnNlLnN0YXR1c31gKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHNlbmQgbG9nIHRvIHNlcnZlcjonLCBlcnJvcik7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGxvZ0V2ZW50ID0gYXN5bmMgKG5hbWUsIHByb3BlcnRpZXMgPSB7fSkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBsb2cgPSB7XHJcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICBldmVudDogbmFtZSxcclxuICAgICAgcHJvcGVydGllcyxcclxuICAgIH07XHJcblxyXG4gICAgLy8gR2V0IGV4aXN0aW5nIGxvZ3NcclxuICAgIGNvbnN0IGV4aXN0aW5nTG9ncyA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oTE9HU19TVE9SQUdFX0tFWSkgfHwgJ1tdJyk7XHJcbiAgICBcclxuICAgIC8vIEFkZCBuZXcgbG9nXHJcbiAgICBleGlzdGluZ0xvZ3MucHVzaChsb2cpO1xyXG4gICAgXHJcbiAgICAvLyBLZWVwIG9ubHkgdGhlIGxhdGVzdCBNQVhfTE9HUyBlbnRyaWVzXHJcbiAgICBjb25zdCB0cmltbWVkTG9ncyA9IGV4aXN0aW5nTG9ncy5zbGljZSgtTUFYX0xPR1MpO1xyXG4gICAgXHJcbiAgICAvLyBTYXZlIGJhY2sgdG8gbG9jYWxTdG9yYWdlXHJcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShMT0dTX1NUT1JBR0VfS0VZLCBKU09OLnN0cmluZ2lmeSh0cmltbWVkTG9ncykpO1xyXG5cclxuICAgIC8vIERldmVsb3BtZW50IGxvZ2dpbmdcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xyXG4gICAgICBjb25zb2xlLmxvZyhgW0V2ZW50OiAke25hbWV9XWAsIHByb3BlcnRpZXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIOC4quC5iOC4hyBsb2cg4LmE4Lib4Lii4Lix4LiHIHNlcnZlciAo4LmE4Lih4LmI4Lij4Lit4LiB4Liy4Lij4LiV4Lit4Lia4LiB4Lil4Lix4LiaKVxyXG4gICAgc2VuZExvZ1RvU2VydmVyKGxvZykuY2F0Y2goZXJyb3IgPT4ge1xyXG4gICAgICBjb25zb2xlLndhcm4oJ0Vycm9yIHNlbmRpbmcgbG9nIHRvIHNlcnZlcjonLCBlcnJvcik7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBJZiB5b3UgaGF2ZSBleHRlcm5hbCBsb2dnaW5nIHNlcnZpY2UgKG9wdGlvbmFsKVxyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicgJiYgcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRVhURVJOQUxfTE9HR0lOR19VUkwpIHtcclxuICAgICAgZmV0Y2gocHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRVhURVJOQUxfTE9HR0lOR19VUkwsIHtcclxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcclxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShsb2cpXHJcbiAgICAgIH0pLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xyXG4gICAgfVxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLndhcm4oJ0xvZ2dpbmcgZmFpbGVkOicsIGVycm9yKTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0TG9ncyA9ICgpID0+IHtcclxuICB0cnkge1xyXG4gICAgcmV0dXJuIEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oTE9HU19TVE9SQUdFX0tFWSkgfHwgJ1tdJyk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHJldHJpZXZlIGxvZ3M6JywgZXJyb3IpO1xyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBjbGVhckxvZ3MgPSAoKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKExPR1NfU1RPUkFHRV9LRVksICdbXScpO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBjbGVhciBsb2dzOicsIGVycm9yKTtcclxuICB9XHJcbn07XHJcbiJdLCJuYW1lcyI6WyJMT0dTX1NUT1JBR0VfS0VZIiwiTUFYX0xPR1MiLCJzZW5kTG9nVG9TZXJ2ZXIiLCJsb2ciLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5Iiwib2siLCJFcnJvciIsInN0YXR1cyIsImVycm9yIiwiY29uc29sZSIsIndhcm4iLCJsb2dFdmVudCIsIm5hbWUiLCJwcm9wZXJ0aWVzIiwidGltZXN0YW1wIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwiZXZlbnQiLCJleGlzdGluZ0xvZ3MiLCJwYXJzZSIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJwdXNoIiwidHJpbW1lZExvZ3MiLCJzbGljZSIsInNldEl0ZW0iLCJwcm9jZXNzIiwiY2F0Y2giLCJlbnYiLCJORVhUX1BVQkxJQ19FWFRFUk5BTF9MT0dHSU5HX1VSTCIsImdldExvZ3MiLCJjbGVhckxvZ3MiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/utils/clientLogging.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/utils/sessionRecording.js":
/*!***************************************!*\
  !*** ./app/utils/sessionRecording.js ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   identifyUser: () => (/* binding */ identifyUser),\n/* harmony export */   initSessionRecording: () => (/* binding */ initSessionRecording),\n/* harmony export */   logEvent: () => (/* binding */ logEvent)\n/* harmony export */ });\n/* harmony import */ var _clientLogging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./clientLogging */ \"(app-pages-browser)/./app/utils/clientLogging.js\");\n\nconst logEvent = function(name) {\n    let properties = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    (0,_clientLogging__WEBPACK_IMPORTED_MODULE_0__.logEvent)(name, properties);\n};\nconst initSessionRecording = ()=>{\n// No initialization needed\n};\nconst identifyUser = function(userId) {\n    let userInfo = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    (0,_clientLogging__WEBPACK_IMPORTED_MODULE_0__.logEvent)('user_identified', {\n        userId,\n        ...userInfo\n    });\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC91dGlscy9zZXNzaW9uUmVjb3JkaW5nLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBNkQ7QUFFdEQsTUFBTUEsV0FBVyxTQUFDRTtRQUFNQyw4RUFBYSxDQUFDO0lBQzNDRix3REFBY0EsQ0FBQ0MsTUFBTUM7QUFDdkIsRUFBRTtBQUVLLE1BQU1DLHVCQUF1QjtBQUNsQywyQkFBMkI7QUFDN0IsRUFBRTtBQUVLLE1BQU1DLGVBQWUsU0FBQ0M7UUFBUUMsNEVBQVcsQ0FBQztJQUMvQ04sd0RBQWNBLENBQUMsbUJBQW1CO1FBQUVLO1FBQVEsR0FBR0MsUUFBUTtJQUFDO0FBQzFELEVBQUUiLCJzb3VyY2VzIjpbIkM6XFxBY3RpdmUgMTQtMy0yMDI1XFxTdW1tYXJ5X29mX1BlcnNvbm5lbF9SYXRpb1xcYXBwXFx1dGlsc1xcc2Vzc2lvblJlY29yZGluZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBsb2dFdmVudCBhcyBjbGllbnRMb2dFdmVudCB9IGZyb20gJy4vY2xpZW50TG9nZ2luZyc7XHJcblxyXG5leHBvcnQgY29uc3QgbG9nRXZlbnQgPSAobmFtZSwgcHJvcGVydGllcyA9IHt9KSA9PiB7XHJcbiAgY2xpZW50TG9nRXZlbnQobmFtZSwgcHJvcGVydGllcyk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgaW5pdFNlc3Npb25SZWNvcmRpbmcgPSAoKSA9PiB7XHJcbiAgLy8gTm8gaW5pdGlhbGl6YXRpb24gbmVlZGVkXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgaWRlbnRpZnlVc2VyID0gKHVzZXJJZCwgdXNlckluZm8gPSB7fSkgPT4ge1xyXG4gIGNsaWVudExvZ0V2ZW50KCd1c2VyX2lkZW50aWZpZWQnLCB7IHVzZXJJZCwgLi4udXNlckluZm8gfSk7XHJcbn07XHJcbiJdLCJuYW1lcyI6WyJsb2dFdmVudCIsImNsaWVudExvZ0V2ZW50IiwibmFtZSIsInByb3BlcnRpZXMiLCJpbml0U2Vzc2lvblJlY29yZGluZyIsImlkZW50aWZ5VXNlciIsInVzZXJJZCIsInVzZXJJbmZvIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/utils/sessionRecording.js\n"));

/***/ })

}]);
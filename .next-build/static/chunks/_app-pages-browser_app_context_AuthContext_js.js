"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_app_context_AuthContext_js"],{

/***/ "(app-pages-browser)/./app/context/AuthContext.js":
/*!************************************!*\
  !*** ./app/context/AuthContext.js ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthProvider: () => (/* binding */ AuthProvider),\n/* harmony export */   useAuth: () => (/* binding */ useAuth)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _lib_firebase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/firebase */ \"(app-pages-browser)/./app/lib/firebase.js\");\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! firebase/firestore */ \"(app-pages-browser)/./node_modules/firebase/firestore/dist/esm/index.esm.js\");\n/* harmony import */ var _lib_dataAccess__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../lib/dataAccess */ \"(app-pages-browser)/./app/lib/dataAccess.js\");\n/* harmony import */ var _utils_sessionRecording__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/sessionRecording */ \"(app-pages-browser)/./app/utils/sessionRecording.js\");\n/* __next_internal_client_entry_do_not_use__ useAuth,AuthProvider auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\n\n\n\n// ระยะเวลาที่ session token หมดอายุ (20 นาที)\nconst SESSION_EXPIRY_TIME = 20 * 60 * 1000; // 20 นาที ในมิลลิวินาที\n// สร้าง session token แบบสุ่ม\nconst generateSessionToken = ()=>{\n    return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15) + Date.now().toString(36);\n};\n// Initialize with default values including the function signatures\nconst AuthContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({\n    user: null,\n    loading: true,\n    isAuthenticated: false,\n    authError: null,\n    login: async (username, password)=>{},\n    logout: ()=>{},\n    clearAuthError: ()=>{}\n});\nconst useAuth = ()=>{\n    _s();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(AuthContext);\n};\n_s(useAuth, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nfunction AuthProvider(param) {\n    let { children } = param;\n    _s1();\n    const [user, setUser] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [authError, setAuthError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // Add function to clear auth errors\n    const clearAuthError = ()=>{\n        setAuthError(null);\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"AuthProvider.useEffect\": ()=>{\n            // Add timeout to prevent indefinite loading\n            const loadingTimeout = setTimeout({\n                \"AuthProvider.useEffect.loadingTimeout\": ()=>{\n                    if (loading) {\n                        console.log('Auth loading timeout reached');\n                        setLoading(false);\n                        setAuthError('การตรวจสอบสถานะผู้ใช้ใช้เวลานานเกินไป กรุณาลองใหม่อีกครั้ง');\n                    }\n                }\n            }[\"AuthProvider.useEffect.loadingTimeout\"], 10000); // 10 seconds timeout\n            return ({\n                \"AuthProvider.useEffect\": ()=>clearTimeout(loadingTimeout)\n            })[\"AuthProvider.useEffect\"];\n        }\n    }[\"AuthProvider.useEffect\"], [\n        loading\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"AuthProvider.useEffect\": ()=>{\n            // Check if user is stored in sessionStorage\n            const checkSessionStorage = {\n                \"AuthProvider.useEffect.checkSessionStorage\": ()=>{\n                    console.log('Checking sessionStorage for user data');\n                    try {\n                        // ตรวจสอบว่า sessionStorage พร้อมใช้งานหรือไม่\n                        if ( false || !window.sessionStorage) {\n                            console.log('sessionStorage is not available');\n                            setLoading(false);\n                            return;\n                        }\n                        const storedUser = sessionStorage.getItem('user');\n                        console.log('User data in sessionStorage:', storedUser ? 'Found' : 'Not found');\n                        if (storedUser) {\n                            try {\n                                const userData = JSON.parse(storedUser);\n                                console.log('Successfully parsed user data');\n                                // ตรวจสอบข้อมูลพื้นฐาน\n                                if (userData && userData.uid && userData.username) {\n                                    console.log('Setting user state with data from sessionStorage');\n                                    setUser(userData);\n                                    // ไม่ต้องตรวจสอบ session อีกต่อไป\n                                    setLoading(false);\n                                } else {\n                                    console.log('Invalid user data, missing required fields');\n                                    sessionStorage.removeItem('user');\n                                    setLoading(false);\n                                }\n                            } catch (parseError) {\n                                console.error('Error parsing user data from sessionStorage:', parseError);\n                                // ล้างข้อมูลที่อาจเสียหาย\n                                sessionStorage.removeItem('user');\n                                setAuthError('ข้อมูลการเข้าสู่ระบบไม่ถูกต้อง กรุณาเข้าสู่ระบบใหม่');\n                                setLoading(false);\n                            }\n                        } else {\n                            // ไม่พบข้อมูลผู้ใช้ใน sessionStorage\n                            console.log('No user data found in sessionStorage');\n                            setLoading(false);\n                        }\n                    } catch (error) {\n                        console.error('Error checking sessionStorage:', error);\n                        setAuthError(error.message || 'เกิดข้อผิดพลาดในการตรวจสอบข้อมูลผู้ใช้');\n                        setLoading(false);\n                    }\n                }\n            }[\"AuthProvider.useEffect.checkSessionStorage\"];\n            // หน่วงเวลาเล็กน้อยเพื่อให้แน่ใจว่า client side hydration เสร็จสมบูรณ์\n            const timer = setTimeout({\n                \"AuthProvider.useEffect.timer\": ()=>{\n                    checkSessionStorage();\n                }\n            }[\"AuthProvider.useEffect.timer\"], 100);\n            return ({\n                \"AuthProvider.useEffect\": ()=>clearTimeout(timer)\n            })[\"AuthProvider.useEffect\"];\n        }\n    }[\"AuthProvider.useEffect\"], []);\n    // ติดตามการเปลี่ยนแปลงของ session\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"AuthProvider.useEffect\": ()=>{\n            // ยกเลิกการติดตาม session เนื่องจากอาจทำให้เกิดปัญหา\n            console.log('Session tracking disabled for troubleshooting');\n            // แทนที่จะใช้ listener ให้ใช้ setInterval ตรวจสอบข้อมูลผู้ใช้เป็นระยะ\n            const checkInterval = setInterval({\n                \"AuthProvider.useEffect.checkInterval\": ()=>{\n                    if (user) {\n                        // ตรวจสอบว่า user ยังมีอยู่ใน sessionStorage หรือไม่\n                        const storedUser = sessionStorage.getItem('user');\n                        if (!storedUser) {\n                            console.log('User data removed from sessionStorage, logging out');\n                            setUser(null);\n                        }\n                    }\n                }\n            }[\"AuthProvider.useEffect.checkInterval\"], 30000); // ตรวจสอบทุก 30 วินาที\n            return ({\n                \"AuthProvider.useEffect\": ()=>{\n                    clearInterval(checkInterval);\n                }\n            })[\"AuthProvider.useEffect\"];\n        }\n    }[\"AuthProvider.useEffect\"], [\n        user\n    ]);\n    // ฟังก์ชันตรวจสอบความถูกต้องของ session (แบบง่าย)\n    const validateUserSession = async (user)=>{\n        try {\n            console.log('Basic user validation');\n            // ตรวจสอบเฉพาะข้อมูลพื้นฐาน\n            if (!user || !user.uid || !user.username) {\n                console.error('Invalid user data - missing required fields');\n                logout();\n                return false;\n            }\n            return true;\n        } catch (error) {\n            console.error('Error in validateUserSession:', error);\n            setLoading(false);\n            return false;\n        }\n    };\n    // Login function - simplified version\n    const login = async (username, password)=>{\n        setLoading(true);\n        setAuthError(null);\n        try {\n            console.log('[DEBUG-AUTH] Attempting login with username:', username);\n            console.log('[DEBUG-AUTH] Password length:', (password === null || password === void 0 ? void 0 : password.length) || 0);\n            // ตรวจสอบค่า input\n            if (!(username === null || username === void 0 ? void 0 : username.trim()) || !(password === null || password === void 0 ? void 0 : password.trim())) {\n                console.error('[DEBUG-AUTH] Empty username or password');\n                setAuthError('กรุณากรอกชื่อผู้ใช้และรหัสผ่าน');\n                setLoading(false);\n                return {\n                    success: false,\n                    error: 'กรุณากรอกชื่อผู้ใช้และรหัสผ่าน'\n                };\n            }\n            // เรียกใช้ฟังก์ชัน loginUser ที่ปรับปรุงใหม่\n            const result = await (0,_lib_dataAccess__WEBPACK_IMPORTED_MODULE_4__.loginUser)(username, password);\n            // ตรวจสอบผลลัพธ์\n            if (!result || !result.success) {\n                const errorMsg = (result === null || result === void 0 ? void 0 : result.error) || 'ชื่อผู้ใช้หรือรหัสผ่านไม่ถูกต้อง';\n                console.debug('[DEBUG-AUTH] Login failed:', errorMsg);\n                setAuthError(errorMsg);\n                setLoading(false);\n                return result || {\n                    success: false,\n                    error: errorMsg\n                };\n            }\n            console.log('[DEBUG-AUTH] Login successful, user data:', {\n                uid: result.user.uid,\n                username: result.user.username,\n                role: result.user.role,\n                department: result.user.department\n            });\n            // ตรวจสอบว่ามีข้อมูลผู้ใช้หรือไม่\n            if (!result.user || !result.user.uid) {\n                console.debug('[DEBUG-AUTH] User data is incomplete');\n                setAuthError('ข้อมูลผู้ใช้ไม่สมบูรณ์ โปรดติดต่อผู้ดูแลระบบ');\n                setLoading(false);\n                return {\n                    success: false,\n                    error: 'ข้อมูลผู้ใช้ไม่สมบูรณ์'\n                };\n            }\n            // บันทึกข้อมูลใน sessionStorage\n            try {\n                const userData = JSON.stringify(result.user);\n                sessionStorage.setItem('user', userData);\n                console.log('[DEBUG-AUTH] User data saved to sessionStorage, length:', userData.length);\n                console.log('[DEBUG-AUTH] User department in storage:', result.user.department);\n            } catch (storageError) {\n                console.error('[DEBUG-AUTH] Error saving to sessionStorage:', storageError);\n            }\n            // อัปเดตสถานะผู้ใช้ใน state\n            setUser(result.user);\n            // บันทึกการเข้าสู่ระบบ\n            try {\n                (0,_utils_sessionRecording__WEBPACK_IMPORTED_MODULE_5__.logEvent)('user_login', {\n                    userId: result.user.uid,\n                    username: result.user.username,\n                    role: result.user.role,\n                    timestamp: new Date().toISOString()\n                });\n            } catch (logError) {\n                console.warn('[DEBUG-AUTH] Error logging login event:', logError);\n            }\n            console.log('[DEBUG-AUTH] Login process complete, returning result');\n            setLoading(false);\n            return result;\n        } catch (error) {\n            console.error('[DEBUG-AUTH] Login error in AuthContext:', error);\n            const errorMsg = error.message || 'เกิดข้อผิดพลาดในการเข้าสู่ระบบ กรุณาลองใหม่อีกครั้ง';\n            setAuthError(errorMsg);\n            setLoading(false);\n            return {\n                success: false,\n                error: errorMsg\n            };\n        }\n    };\n    // Logout function (simplified)\n    const logout = async ()=>{\n        try {\n            console.log('Logging out user');\n            // ตรวจสอบว่ามี user ที่ล็อกอินอยู่หรือไม่\n            if (user && user.uid && user.sessionToken) {\n                try {\n                    console.log('Calling logoutUser function');\n                    // เรียกใช้ฟังก์ชัน logoutUser แทน invalidateSession\n                    const result = await (0,_lib_dataAccess__WEBPACK_IMPORTED_MODULE_4__.logoutUser)(user.uid, user.sessionToken, user.sessionId);\n                    if (result.success) {\n                        console.log('Logout successful in database');\n                    } else {\n                        console.warn('Issue during logout:', result.messages || result.error);\n                    }\n                } catch (dbError) {\n                    console.error('Error during database logout:', dbError);\n                }\n            } else {\n                // กรณีไม่มี user data ใน state แต่อาจมีใน sessionStorage\n                const userData = sessionStorage.getItem('user');\n                if (userData) {\n                    try {\n                        const parsedUser = JSON.parse(userData);\n                        if (parsedUser && parsedUser.uid && parsedUser.sessionToken) {\n                            console.log('Logging out user from sessionStorage data');\n                            await (0,_lib_dataAccess__WEBPACK_IMPORTED_MODULE_4__.logoutUser)(parsedUser.uid, parsedUser.sessionToken, parsedUser.sessionId);\n                        }\n                    } catch (parseError) {\n                        console.error('Error parsing user data for logout:', parseError);\n                    }\n                }\n            }\n            // ล้างข้อมูลใน sessionStorage\n            sessionStorage.removeItem('user');\n            // รีเซ็ต state\n            setUser(null);\n            setAuthError(null);\n            console.log('Logged out successfully (client-side)');\n            // นำทางไปยังหน้า login หลังจากการออกจากระบบ\n            try {\n                window.location.href = '/page/login';\n            } catch (navError) {\n                console.error('Error navigating after logout:', navError);\n            }\n        } catch (error) {\n            console.error('Logout error:', error);\n        }\n    };\n    const contextValue = {\n        user,\n        loading,\n        isAuthenticated: !!user,\n        authError,\n        login,\n        logout,\n        clearAuthError\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(AuthContext.Provider, {\n        value: contextValue,\n        children: children\n    }, void 0, false, {\n        fileName: \"C:\\\\Active 14-3-2025\\\\Summary_of_Personnel_Ratio\\\\app\\\\context\\\\AuthContext.js\",\n        lineNumber: 314,\n        columnNumber: 5\n    }, this);\n}\n_s1(AuthProvider, \"76MNfp0tazfQpgpif3PspRKGE6w=\");\n_c = AuthProvider;\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9jb250ZXh0L0F1dGhDb250ZXh0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQ3VFO0FBQzVCO0FBQ3lGO0FBQ3RDO0FBQ3pDO0FBQ2pCO0FBRXBDLDhDQUE4QztBQUM5QyxNQUFNdUIsc0JBQXNCLEtBQUssS0FBSyxNQUFNLHdCQUF3QjtBQUVwRSw4QkFBOEI7QUFDOUIsTUFBTUMsdUJBQXVCO0lBQzNCLE9BQU9DLEtBQUtDLE1BQU0sR0FBR0MsUUFBUSxDQUFDLElBQUlDLFNBQVMsQ0FBQyxHQUFHLE1BQ3hDSCxLQUFLQyxNQUFNLEdBQUdDLFFBQVEsQ0FBQyxJQUFJQyxTQUFTLENBQUMsR0FBRyxNQUN4Q0MsS0FBS0MsR0FBRyxHQUFHSCxRQUFRLENBQUM7QUFDN0I7QUFFQSxtRUFBbUU7QUFDbkUsTUFBTUksNEJBQWMvQixvREFBYUEsQ0FBQztJQUNoQ2dDLE1BQU07SUFDTkMsU0FBUztJQUNUQyxpQkFBaUI7SUFDakJDLFdBQVc7SUFDWEMsT0FBTyxPQUFPQyxVQUFVQyxZQUFjO0lBQ3RDQyxRQUFRLEtBQU87SUFDZkMsZ0JBQWdCLEtBQU87QUFDekI7QUFFTyxNQUFNQyxVQUFVOztJQUFNeEMsT0FBQUEsaURBQVVBLENBQUM4QjtBQUFXLEVBQUU7R0FBeENVO0FBRU4sU0FBU0MsYUFBYSxLQUFZO1FBQVosRUFBRUMsUUFBUSxFQUFFLEdBQVo7O0lBQzNCLE1BQU0sQ0FBQ1gsTUFBTVksUUFBUSxHQUFHMUMsK0NBQVFBLENBQUM7SUFDakMsTUFBTSxDQUFDK0IsU0FBU1ksV0FBVyxHQUFHM0MsK0NBQVFBLENBQUM7SUFDdkMsTUFBTSxDQUFDaUMsV0FBV1csYUFBYSxHQUFHNUMsK0NBQVFBLENBQUM7SUFFM0Msb0NBQW9DO0lBQ3BDLE1BQU1zQyxpQkFBaUI7UUFDckJNLGFBQWE7SUFDZjtJQUVBM0MsZ0RBQVNBO2tDQUFDO1lBQ1IsNENBQTRDO1lBQzVDLE1BQU00QyxpQkFBaUJDO3lEQUFXO29C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R0FBRztZQUN6QixFQUFFLE9BQU9DLFVBQVU7Z0JBQ2pCNUMsUUFBUWMsS0FBSyxDQUFDLGtDQUFrQzhCO1lBQ2xEO1FBQ0YsRUFBRSxPQUFPOUIsT0FBTztZQUNkZCxRQUFRYyxLQUFLLENBQUMsaUJBQWlCQTtRQUNqQztJQUNGO0lBRUEsTUFBTStCLGVBQWU7UUFDbkI5RDtRQUNBQztRQUNBQyxpQkFBaUIsQ0FBQyxDQUFDRjtRQUNuQkc7UUFDQUM7UUFDQUc7UUFDQUM7SUFDRjtJQUVBLHFCQUNFLDhEQUFDVCxZQUFZZ0UsUUFBUTtRQUFDQyxPQUFPRjtrQkFDMUJuRDs7Ozs7O0FBR1A7SUE5UmdCRDtLQUFBQSIsInNvdXJjZXMiOlsiQzpcXEFjdGl2ZSAxNC0zLTIwMjVcXFN1bW1hcnlfb2ZfUGVyc29ubmVsX1JhdGlvXFxhcHBcXGNvbnRleHRcXEF1dGhDb250ZXh0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcclxuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHsgYXV0aCwgZGIgfSBmcm9tICcuLi9saWIvZmlyZWJhc2UnO1xyXG5pbXBvcnQgeyBkb2MsIGdldERvYywgc2V0RG9jLCB1cGRhdGVEb2MsIHNlcnZlclRpbWVzdGFtcCwgb25TbmFwc2hvdCwgY29sbGVjdGlvbiwgcXVlcnksIHdoZXJlLCBnZXREb2NzIH0gZnJvbSAnZmlyZWJhc2UvZmlyZXN0b3JlJztcclxuaW1wb3J0IHsgbG9naW5Vc2VyLCB2YWxpZGF0ZVNlc3Npb24sIGludmFsaWRhdGVTZXNzaW9uLCBsb2dvdXRVc2VyIH0gZnJvbSAnLi4vbGliL2RhdGFBY2Nlc3MnO1xyXG5pbXBvcnQgeyBsb2dFdmVudCB9IGZyb20gJy4uL3V0aWxzL3Nlc3Npb25SZWNvcmRpbmcnO1xyXG5pbXBvcnQgeyB2NCBhcyB1dWlkdjQgfSBmcm9tICd1dWlkJztcclxuXHJcbi8vIOC4o+C4sOC4ouC4sOC5gOC4p+C4peC4suC4l+C4teC5iCBzZXNzaW9uIHRva2VuIOC4q+C4oeC4lOC4reC4suC4ouC4uCAoMjAg4LiZ4Liy4LiX4Li1KVxyXG5jb25zdCBTRVNTSU9OX0VYUElSWV9USU1FID0gMjAgKiA2MCAqIDEwMDA7IC8vIDIwIOC4meC4suC4l+C4tSDguYPguJnguKHguLTguKXguKXguLTguKfguLTguJnguLLguJfguLVcclxuXHJcbi8vIOC4quC4o+C5ieC4suC4hyBzZXNzaW9uIHRva2VuIOC5geC4muC4muC4quC4uOC5iOC4oVxyXG5jb25zdCBnZW5lcmF0ZVNlc3Npb25Ub2tlbiA9ICgpID0+IHtcclxuICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDE1KSArIFxyXG4gICAgICAgICBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgMTUpICsgXHJcbiAgICAgICAgIERhdGUubm93KCkudG9TdHJpbmcoMzYpO1xyXG59O1xyXG5cclxuLy8gSW5pdGlhbGl6ZSB3aXRoIGRlZmF1bHQgdmFsdWVzIGluY2x1ZGluZyB0aGUgZnVuY3Rpb24gc2lnbmF0dXJlc1xyXG5jb25zdCBBdXRoQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoe1xyXG4gIHVzZXI6IG51bGwsXHJcbiAgbG9hZGluZzogdHJ1ZSxcclxuICBpc0F1dGhlbnRpY2F0ZWQ6IGZhbHNlLFxyXG4gIGF1dGhFcnJvcjogbnVsbCxcclxuICBsb2dpbjogYXN5bmMgKHVzZXJuYW1lLCBwYXNzd29yZCkgPT4ge30sXHJcbiAgbG9nb3V0OiAoKSA9PiB7fSxcclxuICBjbGVhckF1dGhFcnJvcjogKCkgPT4ge30sXHJcbn0pO1xyXG5cclxuZXhwb3J0IGNvbnN0IHVzZUF1dGggPSAoKSA9PiB1c2VDb250ZXh0KEF1dGhDb250ZXh0KTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBBdXRoUHJvdmlkZXIoeyBjaGlsZHJlbiB9KSB7XHJcbiAgY29uc3QgW3VzZXIsIHNldFVzZXJdID0gdXNlU3RhdGUobnVsbCk7XHJcbiAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGUodHJ1ZSk7XHJcbiAgY29uc3QgW2F1dGhFcnJvciwgc2V0QXV0aEVycm9yXSA9IHVzZVN0YXRlKG51bGwpO1xyXG4gIFxyXG4gIC8vIEFkZCBmdW5jdGlvbiB0byBjbGVhciBhdXRoIGVycm9yc1xyXG4gIGNvbnN0IGNsZWFyQXV0aEVycm9yID0gKCkgPT4ge1xyXG4gICAgc2V0QXV0aEVycm9yKG51bGwpO1xyXG4gIH07XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAvLyBBZGQgdGltZW91dCB0byBwcmV2ZW50IGluZGVmaW5pdGUgbG9hZGluZ1xyXG4gICAgY29uc3QgbG9hZGluZ1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgaWYgKGxvYWRpbmcpIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnQXV0aCBsb2FkaW5nIHRpbWVvdXQgcmVhY2hlZCcpO1xyXG4gICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xyXG4gICAgICAgIHNldEF1dGhFcnJvcign4LiB4Liy4Lij4LiV4Lij4Lin4LiI4Liq4Lit4Lia4Liq4LiW4Liy4LiZ4Liw4Lic4Li54LmJ4LmD4LiK4LmJ4LmD4LiK4LmJ4LmA4Lin4Lil4Liy4LiZ4Liy4LiZ4LmA4LiB4Li04LiZ4LmE4LibIOC4geC4o+C4uOC4k+C4suC4peC4reC4h+C5g+C4q+C4oeC5iOC4reC4teC4geC4hOC4o+C4seC5ieC4hycpO1xyXG4gICAgICB9XHJcbiAgICB9LCAxMDAwMCk7IC8vIDEwIHNlY29uZHMgdGltZW91dFxyXG5cclxuICAgIHJldHVybiAoKSA9PiBjbGVhclRpbWVvdXQobG9hZGluZ1RpbWVvdXQpO1xyXG4gIH0sIFtsb2FkaW5nXSk7XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAvLyBDaGVjayBpZiB1c2VyIGlzIHN0b3JlZCBpbiBzZXNzaW9uU3RvcmFnZVxyXG4gICAgY29uc3QgY2hlY2tTZXNzaW9uU3RvcmFnZSA9ICgpID0+IHtcclxuICAgICAgY29uc29sZS5sb2coJ0NoZWNraW5nIHNlc3Npb25TdG9yYWdlIGZvciB1c2VyIGRhdGEnKTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICAvLyDguJXguKPguKfguIjguKrguK3guJrguKfguYjguLIgc2Vzc2lvblN0b3JhZ2Ug4Lie4Lij4LmJ4Lit4Lih4LmD4LiK4LmJ4LiH4Liy4LiZ4Lir4Lij4Li34Lit4LmE4Lih4LmIXHJcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICF3aW5kb3cuc2Vzc2lvblN0b3JhZ2UpIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKCdzZXNzaW9uU3RvcmFnZSBpcyBub3QgYXZhaWxhYmxlJyk7XHJcbiAgICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc3Qgc3RvcmVkVXNlciA9IHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oJ3VzZXInKTtcclxuICAgICAgICBjb25zb2xlLmxvZygnVXNlciBkYXRhIGluIHNlc3Npb25TdG9yYWdlOicsIHN0b3JlZFVzZXIgPyAnRm91bmQnIDogJ05vdCBmb3VuZCcpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChzdG9yZWRVc2VyKSB7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCB1c2VyRGF0YSA9IEpTT04ucGFyc2Uoc3RvcmVkVXNlcik7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdTdWNjZXNzZnVsbHkgcGFyc2VkIHVzZXIgZGF0YScpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8g4LiV4Lij4Lin4LiI4Liq4Lit4Lia4LiC4LmJ4Lit4Lih4Li54Lil4Lie4Li34LmJ4LiZ4LiQ4Liy4LiZXHJcbiAgICAgICAgICAgIGlmICh1c2VyRGF0YSAmJiB1c2VyRGF0YS51aWQgJiYgdXNlckRhdGEudXNlcm5hbWUpIHtcclxuICAgICAgICAgICAgICBjb25zb2xlLmxvZygnU2V0dGluZyB1c2VyIHN0YXRlIHdpdGggZGF0YSBmcm9tIHNlc3Npb25TdG9yYWdlJyk7XHJcbiAgICAgICAgICAgICAgc2V0VXNlcih1c2VyRGF0YSk7XHJcbiAgICAgICAgICAgICAgLy8g4LmE4Lih4LmI4LiV4LmJ4Lit4LiH4LiV4Lij4Lin4LiI4Liq4Lit4LiaIHNlc3Npb24g4Lit4Li14LiB4LiV4LmI4Lit4LmE4LibXHJcbiAgICAgICAgICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0ludmFsaWQgdXNlciBkYXRhLCBtaXNzaW5nIHJlcXVpcmVkIGZpZWxkcycpO1xyXG4gICAgICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0oJ3VzZXInKTtcclxuICAgICAgICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBjYXRjaCAocGFyc2VFcnJvcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBwYXJzaW5nIHVzZXIgZGF0YSBmcm9tIHNlc3Npb25TdG9yYWdlOicsIHBhcnNlRXJyb3IpO1xyXG4gICAgICAgICAgICAvLyDguKXguYnguLLguIfguILguYnguK3guKHguLnguKXguJfguLXguYjguK3guLLguIjguYDguKrguLXguKLguKvguLLguKJcclxuICAgICAgICAgICAgc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbSgndXNlcicpO1xyXG4gICAgICAgICAgICBzZXRBdXRoRXJyb3IoJ+C4guC5ieC4reC4oeC4ueC4peC4geC4suC4o+C5gOC4guC5ieC4suC4quC4ueC5iOC4o+C4sOC4muC4muC5hOC4oeC5iOC4luC4ueC4geC4leC5ieC4reC4hyDguIHguKPguLjguJPguLLguYDguILguYnguLLguKrguLnguYjguKPguLDguJrguJrguYPguKvguKHguYgnKTtcclxuICAgICAgICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIOC5hOC4oeC5iOC4nuC4muC4guC5ieC4reC4oeC4ueC4peC4nOC4ueC5ieC5g+C4iuC5ieC5g+C4mSBzZXNzaW9uU3RvcmFnZVxyXG4gICAgICAgICAgY29uc29sZS5sb2coJ05vIHVzZXIgZGF0YSBmb3VuZCBpbiBzZXNzaW9uU3RvcmFnZScpO1xyXG4gICAgICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNoZWNraW5nIHNlc3Npb25TdG9yYWdlOicsIGVycm9yKTtcclxuICAgICAgICBzZXRBdXRoRXJyb3IoZXJyb3IubWVzc2FnZSB8fCAn4LmA4LiB4Li04LiU4LiC4LmJ4Lit4Lic4Li04LiU4Lie4Lil4Liy4LiU4LmD4LiZ4LiB4Liy4Lij4LiV4Lij4Lin4LiI4Liq4Lit4Lia4LiC4LmJ4Lit4Lih4Li54Lil4Lic4Li54LmJ4LmD4LiK4LmJJyk7XHJcbiAgICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICBcclxuICAgIC8vIOC4q+C4meC5iOC4p+C4h+C5gOC4p+C4peC4suC5gOC4peC5h+C4geC4meC5ieC4reC4ouC5gOC4nuC4t+C5iOC4reC5g+C4q+C5ieC5geC4meC5iOC5g+C4iOC4p+C5iOC4siBjbGllbnQgc2lkZSBoeWRyYXRpb24g4LmA4Liq4Lij4LmH4LiI4Liq4Lih4Lia4Li54Lij4LiT4LmMXHJcbiAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICBjaGVja1Nlc3Npb25TdG9yYWdlKCk7XHJcbiAgICB9LCAxMDApO1xyXG4gICAgXHJcbiAgICByZXR1cm4gKCkgPT4gY2xlYXJUaW1lb3V0KHRpbWVyKTtcclxuICB9LCBbXSk7XHJcblxyXG4gIC8vIOC4leC4tOC4lOC4leC4suC4oeC4geC4suC4o+C5gOC4m+C4peC4teC5iOC4ouC4meC5geC4m+C4peC4h+C4guC4reC4hyBzZXNzaW9uXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIC8vIOC4ouC4geC5gOC4peC4tOC4geC4geC4suC4o+C4leC4tOC4lOC4leC4suC4oSBzZXNzaW9uIOC5gOC4meC4t+C5iOC4reC4h+C4iOC4suC4geC4reC4suC4iOC4l+C4s+C5g+C4q+C5ieC5gOC4geC4tOC4lOC4m+C4seC4jeC4q+C4slxyXG4gICAgY29uc29sZS5sb2coJ1Nlc3Npb24gdHJhY2tpbmcgZGlzYWJsZWQgZm9yIHRyb3VibGVzaG9vdGluZycpO1xyXG4gICAgXHJcbiAgICAvLyDguYHguJfguJnguJfguLXguYjguIjguLDguYPguIrguYkgbGlzdGVuZXIg4LmD4Lir4LmJ4LmD4LiK4LmJIHNldEludGVydmFsIOC4leC4o+C4p+C4iOC4quC4reC4muC4guC5ieC4reC4oeC4ueC4peC4nOC4ueC5ieC5g+C4iuC5ieC5gOC4m+C5h+C4meC4o+C4sOC4ouC4sFxyXG4gICAgY29uc3QgY2hlY2tJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcclxuICAgICAgaWYgKHVzZXIpIHtcclxuICAgICAgICAvLyDguJXguKPguKfguIjguKrguK3guJrguKfguYjguLIgdXNlciDguKLguLHguIfguKHguLXguK3guKLguLnguYjguYPguJkgc2Vzc2lvblN0b3JhZ2Ug4Lir4Lij4Li34Lit4LmE4Lih4LmIXHJcbiAgICAgICAgY29uc3Qgc3RvcmVkVXNlciA9IHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oJ3VzZXInKTtcclxuICAgICAgICBpZiAoIXN0b3JlZFVzZXIpIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKCdVc2VyIGRhdGEgcmVtb3ZlZCBmcm9tIHNlc3Npb25TdG9yYWdlLCBsb2dnaW5nIG91dCcpO1xyXG4gICAgICAgICAgc2V0VXNlcihudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0sIDMwMDAwKTsgLy8g4LiV4Lij4Lin4LiI4Liq4Lit4Lia4LiX4Li44LiBIDMwIOC4p+C4tOC4meC4suC4l+C4tVxyXG4gICAgXHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICBjbGVhckludGVydmFsKGNoZWNrSW50ZXJ2YWwpO1xyXG4gICAgfTtcclxuICB9LCBbdXNlcl0pO1xyXG5cclxuICAvLyDguJ/guLHguIfguIHguYzguIrguLHguJnguJXguKPguKfguIjguKrguK3guJrguITguKfguLLguKHguJbguLnguIHguJXguYnguK3guIfguILguK3guIcgc2Vzc2lvbiAo4LmB4Lia4Lia4LiH4LmI4Liy4LiiKVxyXG4gIGNvbnN0IHZhbGlkYXRlVXNlclNlc3Npb24gPSBhc3luYyAodXNlcikgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2coJ0Jhc2ljIHVzZXIgdmFsaWRhdGlvbicpO1xyXG4gICAgICBcclxuICAgICAgLy8g4LiV4Lij4Lin4LiI4Liq4Lit4Lia4LmA4LiJ4Lie4Liy4Liw4LiC4LmJ4Lit4Lih4Li54Lil4Lie4Li34LmJ4LiZ4LiQ4Liy4LiZXHJcbiAgICAgIGlmICghdXNlciB8fCAhdXNlci51aWQgfHwgIXVzZXIudXNlcm5hbWUpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIHVzZXIgZGF0YSAtIG1pc3NpbmcgcmVxdWlyZWQgZmllbGRzJyk7XHJcbiAgICAgICAgbG9nb3V0KCk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIHZhbGlkYXRlVXNlclNlc3Npb246JywgZXJyb3IpO1xyXG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8vIExvZ2luIGZ1bmN0aW9uIC0gc2ltcGxpZmllZCB2ZXJzaW9uXHJcbiAgY29uc3QgbG9naW4gPSBhc3luYyAodXNlcm5hbWUsIHBhc3N3b3JkKSA9PiB7XHJcbiAgICBzZXRMb2FkaW5nKHRydWUpO1xyXG4gICAgc2V0QXV0aEVycm9yKG51bGwpO1xyXG4gICAgXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZygnW0RFQlVHLUFVVEhdIEF0dGVtcHRpbmcgbG9naW4gd2l0aCB1c2VybmFtZTonLCB1c2VybmFtZSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdbREVCVUctQVVUSF0gUGFzc3dvcmQgbGVuZ3RoOicsIHBhc3N3b3JkPy5sZW5ndGggfHwgMCk7XHJcbiAgICAgIFxyXG4gICAgICAvLyDguJXguKPguKfguIjguKrguK3guJrguITguYjguLIgaW5wdXRcclxuICAgICAgaWYgKCF1c2VybmFtZT8udHJpbSgpIHx8ICFwYXNzd29yZD8udHJpbSgpKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignW0RFQlVHLUFVVEhdIEVtcHR5IHVzZXJuYW1lIG9yIHBhc3N3b3JkJyk7XHJcbiAgICAgICAgc2V0QXV0aEVycm9yKCfguIHguKPguLjguJPguLLguIHguKPguK3guIHguIrguLfguYjguK3guJzguLnguYnguYPguIrguYnguYHguKXguLDguKPguKvguLHguKrguJzguYjguLLguJknKTtcclxuICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXHJcbiAgICAgICAgICBlcnJvcjogJ+C4geC4o+C4uOC4k+C4suC4geC4o+C4reC4geC4iuC4t+C5iOC4reC4nOC4ueC5ieC5g+C4iuC5ieC5geC4peC4sOC4o+C4q+C4seC4quC4nOC5iOC4suC4mSdcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyDguYDguKPguLXguKLguIHguYPguIrguYnguJ/guLHguIfguIHguYzguIrguLHguJkgbG9naW5Vc2VyIOC4l+C4teC5iOC4m+C4o+C4seC4muC4m+C4o+C4uOC4h+C5g+C4q+C4oeC5iFxyXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBsb2dpblVzZXIodXNlcm5hbWUsIHBhc3N3b3JkKTtcclxuICAgICAgXHJcbiAgICAgIC8vIOC4leC4o+C4p+C4iOC4quC4reC4muC4nOC4peC4peC4seC4nuC4mOC5jFxyXG4gICAgICBpZiAoIXJlc3VsdCB8fCAhcmVzdWx0LnN1Y2Nlc3MpIHtcclxuICAgICAgICBjb25zdCBlcnJvck1zZyA9IHJlc3VsdD8uZXJyb3IgfHwgJ+C4iuC4t+C5iOC4reC4nOC4ueC5ieC5g+C4iuC5ieC4q+C4o+C4t+C4reC4o+C4q+C4seC4quC4nOC5iOC4suC4meC5hOC4oeC5iOC4luC4ueC4geC4leC5ieC4reC4hyc7XHJcbiAgICAgICAgY29uc29sZS5kZWJ1ZygnW0RFQlVHLUFVVEhdIExvZ2luIGZhaWxlZDonLCBlcnJvck1zZyk7XHJcbiAgICAgICAgc2V0QXV0aEVycm9yKGVycm9yTXNnKTtcclxuICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0IHx8IHsgXHJcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcclxuICAgICAgICAgIGVycm9yOiBlcnJvck1zZ1xyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKCdbREVCVUctQVVUSF0gTG9naW4gc3VjY2Vzc2Z1bCwgdXNlciBkYXRhOicsIHtcclxuICAgICAgICB1aWQ6IHJlc3VsdC51c2VyLnVpZCxcclxuICAgICAgICB1c2VybmFtZTogcmVzdWx0LnVzZXIudXNlcm5hbWUsXHJcbiAgICAgICAgcm9sZTogcmVzdWx0LnVzZXIucm9sZSxcclxuICAgICAgICBkZXBhcnRtZW50OiByZXN1bHQudXNlci5kZXBhcnRtZW50XHJcbiAgICAgIH0pO1xyXG4gICAgICBcclxuICAgICAgLy8g4LiV4Lij4Lin4LiI4Liq4Lit4Lia4Lin4LmI4Liy4Lih4Li14LiC4LmJ4Lit4Lih4Li54Lil4Lic4Li54LmJ4LmD4LiK4LmJ4Lir4Lij4Li34Lit4LmE4Lih4LmIXHJcbiAgICAgIGlmICghcmVzdWx0LnVzZXIgfHwgIXJlc3VsdC51c2VyLnVpZCkge1xyXG4gICAgICAgIGNvbnNvbGUuZGVidWcoJ1tERUJVRy1BVVRIXSBVc2VyIGRhdGEgaXMgaW5jb21wbGV0ZScpO1xyXG4gICAgICAgIHNldEF1dGhFcnJvcign4LiC4LmJ4Lit4Lih4Li54Lil4Lic4Li54LmJ4LmD4LiK4LmJ4LmE4Lih4LmI4Liq4Lih4Lia4Li54Lij4LiT4LmMIOC5guC4m+C4o+C4lOC4leC4tOC4lOC4leC5iOC4reC4nOC4ueC5ieC4lOC4ueC5geC4peC4o+C4sOC4muC4micpO1xyXG4gICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcclxuICAgICAgICAgIGVycm9yOiAn4LiC4LmJ4Lit4Lih4Li54Lil4Lic4Li54LmJ4LmD4LiK4LmJ4LmE4Lih4LmI4Liq4Lih4Lia4Li54Lij4LiT4LmMJ1xyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIOC4muC4seC4meC4l+C4tuC4geC4guC5ieC4reC4oeC4ueC4peC5g+C4mSBzZXNzaW9uU3RvcmFnZVxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHVzZXJEYXRhID0gSlNPTi5zdHJpbmdpZnkocmVzdWx0LnVzZXIpO1xyXG4gICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oJ3VzZXInLCB1c2VyRGF0YSk7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ1tERUJVRy1BVVRIXSBVc2VyIGRhdGEgc2F2ZWQgdG8gc2Vzc2lvblN0b3JhZ2UsIGxlbmd0aDonLCB1c2VyRGF0YS5sZW5ndGgpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdbREVCVUctQVVUSF0gVXNlciBkZXBhcnRtZW50IGluIHN0b3JhZ2U6JywgcmVzdWx0LnVzZXIuZGVwYXJ0bWVudCk7XHJcbiAgICAgIH0gY2F0Y2ggKHN0b3JhZ2VFcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tERUJVRy1BVVRIXSBFcnJvciBzYXZpbmcgdG8gc2Vzc2lvblN0b3JhZ2U6Jywgc3RvcmFnZUVycm9yKTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8g4Lit4Lix4Lib4LmA4LiU4LiV4Liq4LiW4Liy4LiZ4Liw4Lic4Li54LmJ4LmD4LiK4LmJ4LmD4LiZIHN0YXRlXHJcbiAgICAgIHNldFVzZXIocmVzdWx0LnVzZXIpO1xyXG4gICAgICBcclxuICAgICAgLy8g4Lia4Lix4LiZ4LiX4Li24LiB4LiB4Liy4Lij4LmA4LiC4LmJ4Liy4Liq4Li54LmI4Lij4Liw4Lia4LiaXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgbG9nRXZlbnQoJ3VzZXJfbG9naW4nLCB7XHJcbiAgICAgICAgICB1c2VySWQ6IHJlc3VsdC51c2VyLnVpZCxcclxuICAgICAgICAgIHVzZXJuYW1lOiByZXN1bHQudXNlci51c2VybmFtZSxcclxuICAgICAgICAgIHJvbGU6IHJlc3VsdC51c2VyLnJvbGUsXHJcbiAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGNhdGNoIChsb2dFcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignW0RFQlVHLUFVVEhdIEVycm9yIGxvZ2dpbmcgbG9naW4gZXZlbnQ6JywgbG9nRXJyb3IpO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBjb25zb2xlLmxvZygnW0RFQlVHLUFVVEhdIExvZ2luIHByb2Nlc3MgY29tcGxldGUsIHJldHVybmluZyByZXN1bHQnKTtcclxuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdbREVCVUctQVVUSF0gTG9naW4gZXJyb3IgaW4gQXV0aENvbnRleHQ6JywgZXJyb3IpO1xyXG4gICAgICBjb25zdCBlcnJvck1zZyA9IGVycm9yLm1lc3NhZ2UgfHwgJ+C5gOC4geC4tOC4lOC4guC5ieC4reC4nOC4tOC4lOC4nuC4peC4suC4lOC5g+C4meC4geC4suC4o+C5gOC4guC5ieC4suC4quC4ueC5iOC4o+C4sOC4muC4miDguIHguKPguLjguJPguLLguKXguK3guIfguYPguKvguKHguYjguK3guLXguIHguITguKPguLHguYnguIcnO1xyXG4gICAgICBzZXRBdXRoRXJyb3IoZXJyb3JNc2cpO1xyXG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcclxuICAgICAgICBlcnJvcjogZXJyb3JNc2dcclxuICAgICAgfTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvLyBMb2dvdXQgZnVuY3Rpb24gKHNpbXBsaWZpZWQpXHJcbiAgY29uc3QgbG9nb3V0ID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2coJ0xvZ2dpbmcgb3V0IHVzZXInKTtcclxuICAgICAgXHJcbiAgICAgIC8vIOC4leC4o+C4p+C4iOC4quC4reC4muC4p+C5iOC4suC4oeC4tSB1c2VyIOC4l+C4teC5iOC4peC5h+C4reC4geC4reC4tOC4meC4reC4ouC4ueC5iOC4q+C4o+C4t+C4reC5hOC4oeC5iFxyXG4gICAgICBpZiAodXNlciAmJiB1c2VyLnVpZCAmJiB1c2VyLnNlc3Npb25Ub2tlbikge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZygnQ2FsbGluZyBsb2dvdXRVc2VyIGZ1bmN0aW9uJyk7XHJcbiAgICAgICAgICAvLyDguYDguKPguLXguKLguIHguYPguIrguYnguJ/guLHguIfguIHguYzguIrguLHguJkgbG9nb3V0VXNlciDguYHguJfguJkgaW52YWxpZGF0ZVNlc3Npb25cclxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGxvZ291dFVzZXIodXNlci51aWQsIHVzZXIuc2Vzc2lvblRva2VuLCB1c2VyLnNlc3Npb25JZCk7XHJcbiAgICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ0xvZ291dCBzdWNjZXNzZnVsIGluIGRhdGFiYXNlJyk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0lzc3VlIGR1cmluZyBsb2dvdXQ6JywgcmVzdWx0Lm1lc3NhZ2VzIHx8IHJlc3VsdC5lcnJvcik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoZGJFcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZHVyaW5nIGRhdGFiYXNlIGxvZ291dDonLCBkYkVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8g4LiB4Lij4LiT4Li14LmE4Lih4LmI4Lih4Li1IHVzZXIgZGF0YSDguYPguJkgc3RhdGUg4LmB4LiV4LmI4Lit4Liy4LiI4Lih4Li14LmD4LiZIHNlc3Npb25TdG9yYWdlXHJcbiAgICAgICAgY29uc3QgdXNlckRhdGEgPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKCd1c2VyJyk7XHJcbiAgICAgICAgaWYgKHVzZXJEYXRhKSB7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBwYXJzZWRVc2VyID0gSlNPTi5wYXJzZSh1c2VyRGF0YSk7XHJcbiAgICAgICAgICAgIGlmIChwYXJzZWRVc2VyICYmIHBhcnNlZFVzZXIudWlkICYmIHBhcnNlZFVzZXIuc2Vzc2lvblRva2VuKSB7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0xvZ2dpbmcgb3V0IHVzZXIgZnJvbSBzZXNzaW9uU3RvcmFnZSBkYXRhJyk7XHJcbiAgICAgICAgICAgICAgYXdhaXQgbG9nb3V0VXNlcihwYXJzZWRVc2VyLnVpZCwgcGFyc2VkVXNlci5zZXNzaW9uVG9rZW4sIHBhcnNlZFVzZXIuc2Vzc2lvbklkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBjYXRjaCAocGFyc2VFcnJvcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBwYXJzaW5nIHVzZXIgZGF0YSBmb3IgbG9nb3V0OicsIHBhcnNlRXJyb3IpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8g4Lil4LmJ4Liy4LiH4LiC4LmJ4Lit4Lih4Li54Lil4LmD4LiZIHNlc3Npb25TdG9yYWdlXHJcbiAgICAgIHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0oJ3VzZXInKTtcclxuICAgICAgXHJcbiAgICAgIC8vIOC4o+C4teC5gOC4i+C5h+C4lSBzdGF0ZVxyXG4gICAgICBzZXRVc2VyKG51bGwpO1xyXG4gICAgICBzZXRBdXRoRXJyb3IobnVsbCk7XHJcbiAgICAgIFxyXG4gICAgICBjb25zb2xlLmxvZygnTG9nZ2VkIG91dCBzdWNjZXNzZnVsbHkgKGNsaWVudC1zaWRlKScpO1xyXG4gICAgICBcclxuICAgICAgLy8g4LiZ4Liz4LiX4Liy4LiH4LmE4Lib4Lii4Lix4LiH4Lir4LiZ4LmJ4LiyIGxvZ2luIOC4q+C4peC4seC4h+C4iOC4suC4geC4geC4suC4o+C4reC4reC4geC4iOC4suC4geC4o+C4sOC4muC4mlxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gJy9wYWdlL2xvZ2luJztcclxuICAgICAgfSBjYXRjaCAobmF2RXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBuYXZpZ2F0aW5nIGFmdGVyIGxvZ291dDonLCBuYXZFcnJvcik7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0xvZ291dCBlcnJvcjonLCBlcnJvcik7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgY29udGV4dFZhbHVlID0ge1xyXG4gICAgdXNlcixcclxuICAgIGxvYWRpbmcsXHJcbiAgICBpc0F1dGhlbnRpY2F0ZWQ6ICEhdXNlcixcclxuICAgIGF1dGhFcnJvcixcclxuICAgIGxvZ2luLFxyXG4gICAgbG9nb3V0LFxyXG4gICAgY2xlYXJBdXRoRXJyb3IsXHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxBdXRoQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17Y29udGV4dFZhbHVlfT5cclxuICAgICAge2NoaWxkcmVufVxyXG4gICAgPC9BdXRoQ29udGV4dC5Qcm92aWRlcj5cclxuICApO1xyXG59Il0sIm5hbWVzIjpbImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJhdXRoIiwiZGIiLCJkb2MiLCJnZXREb2MiLCJzZXREb2MiLCJ1cGRhdGVEb2MiLCJzZXJ2ZXJUaW1lc3RhbXAiLCJvblNuYXBzaG90IiwiY29sbGVjdGlvbiIsInF1ZXJ5Iiwid2hlcmUiLCJnZXREb2NzIiwibG9naW5Vc2VyIiwidmFsaWRhdGVTZXNzaW9uIiwiaW52YWxpZGF0ZVNlc3Npb24iLCJsb2dvdXRVc2VyIiwibG9nRXZlbnQiLCJ2NCIsInV1aWR2NCIsIlNFU1NJT05fRVhQSVJZX1RJTUUiLCJnZW5lcmF0ZVNlc3Npb25Ub2tlbiIsIk1hdGgiLCJyYW5kb20iLCJ0b1N0cmluZyIsInN1YnN0cmluZyIsIkRhdGUiLCJub3ciLCJBdXRoQ29udGV4dCIsInVzZXIiLCJsb2FkaW5nIiwiaXNBdXRoZW50aWNhdGVkIiwiYXV0aEVycm9yIiwibG9naW4iLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwibG9nb3V0IiwiY2xlYXJBdXRoRXJyb3IiLCJ1c2VBdXRoIiwiQXV0aFByb3ZpZGVyIiwiY2hpbGRyZW4iLCJzZXRVc2VyIiwic2V0TG9hZGluZyIsInNldEF1dGhFcnJvciIsImxvYWRpbmdUaW1lb3V0Iiwic2V0VGltZW91dCIsImNvbnNvbGUiLCJsb2ciLCJjbGVhclRpbWVvdXQiLCJjaGVja1Nlc3Npb25TdG9yYWdlIiwid2luZG93Iiwic2Vzc2lvblN0b3JhZ2UiLCJzdG9yZWRVc2VyIiwiZ2V0SXRlbSIsInVzZXJEYXRhIiwiSlNPTiIsInBhcnNlIiwidWlkIiwicmVtb3ZlSXRlbSIsInBhcnNlRXJyb3IiLCJlcnJvciIsIm1lc3NhZ2UiLCJ0aW1lciIsImNoZWNrSW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJ2YWxpZGF0ZVVzZXJTZXNzaW9uIiwibGVuZ3RoIiwidHJpbSIsInN1Y2Nlc3MiLCJyZXN1bHQiLCJlcnJvck1zZyIsImRlYnVnIiwicm9sZSIsImRlcGFydG1lbnQiLCJzdHJpbmdpZnkiLCJzZXRJdGVtIiwic3RvcmFnZUVycm9yIiwidXNlcklkIiwidGltZXN0YW1wIiwidG9JU09TdHJpbmciLCJsb2dFcnJvciIsIndhcm4iLCJzZXNzaW9uVG9rZW4iLCJzZXNzaW9uSWQiLCJtZXNzYWdlcyIsImRiRXJyb3IiLCJwYXJzZWRVc2VyIiwibG9jYXRpb24iLCJocmVmIiwibmF2RXJyb3IiLCJjb250ZXh0VmFsdWUiLCJQcm92aWRlciIsInZhbHVlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/context/AuthContext.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/lib/dataAccess.js":
/*!*******************************!*\
  !*** ./app/lib/dataAccess.js ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addUser: () => (/* binding */ addUser),\n/* harmony export */   checkLast7DaysData: () => (/* binding */ checkLast7DaysData),\n/* harmony export */   deleteUser: () => (/* binding */ deleteUser),\n/* harmony export */   deleteWardDataDraft: () => (/* binding */ deleteWardDataDraft),\n/* harmony export */   getAllUsers: () => (/* binding */ getAllUsers),\n/* harmony export */   getLatestDraft: () => (/* binding */ getLatestDraft),\n/* harmony export */   getUserDataFromCollection: () => (/* binding */ getUserDataFromCollection),\n/* harmony export */   getUserDrafts: () => (/* binding */ getUserDrafts),\n/* harmony export */   getWardDataByDate: () => (/* binding */ getWardDataByDate),\n/* harmony export */   getWardDataHistory: () => (/* binding */ getWardDataHistory),\n/* harmony export */   invalidateSession: () => (/* binding */ invalidateSession),\n/* harmony export */   logUserActivity: () => (/* binding */ logUserActivity),\n/* harmony export */   logWardDataHistory: () => (/* binding */ logWardDataHistory),\n/* harmony export */   loginUser: () => (/* binding */ loginUser),\n/* harmony export */   logoutUser: () => (/* binding */ logoutUser),\n/* harmony export */   saveWardDataDraft: () => (/* binding */ saveWardDataDraft),\n/* harmony export */   saveWardDataFinal: () => (/* binding */ saveWardDataFinal),\n/* harmony export */   validateSession: () => (/* binding */ validateSession)\n/* harmony export */ });\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! firebase/firestore */ \"(app-pages-browser)/./node_modules/firebase/firestore/dist/esm/index.esm.js\");\n/* harmony import */ var _firebase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./firebase */ \"(app-pages-browser)/./app/lib/firebase.js\");\n/* harmony import */ var _barrel_optimize_names_format_parseISO_subDays_date_fns__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! __barrel_optimize__?names=format,parseISO,subDays!=!date-fns */ \"(app-pages-browser)/./node_modules/date-fns/esm/subDays/index.js\");\n/* harmony import */ var _barrel_optimize_names_format_parseISO_subDays_date_fns__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! __barrel_optimize__?names=format,parseISO,subDays!=!date-fns */ \"(app-pages-browser)/./node_modules/date-fns/esm/format/index.js\");\n/* __next_internal_client_entry_do_not_use__ saveWardDataDraft,saveWardDataFinal,getUserDrafts,getLatestDraft,deleteWardDataDraft,logWardDataHistory,getWardDataHistory,checkLast7DaysData,logUserActivity,loginUser,validateSession,invalidateSession,getAllUsers,deleteUser,addUser,logoutUser,getWardDataByDate,getUserDataFromCollection auto */ \n\n\n// ฟังก์ชันบันทึกข้อมูลเวร (ฉบับร่าง)\nconst saveWardDataDraft = async (data)=>{\n    try {\n        if (!data.wardId || !data.date || !data.shift || !data.userId) {\n            return {\n                success: false,\n                error: 'Missing required fields: wardId, date, shift, or userId'\n            };\n        }\n        // สร้าง docId ที่ไม่ซ้ำกัน\n        const docId = \"\".concat(data.date, \"_\").concat(data.wardId, \"_\").concat(data.shift, \"_\").concat(data.userId);\n        // เพิ่ม timestamp สำหรับการเรียงลำดับ\n        const draftData = {\n            ...data,\n            timestamp: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)(),\n            lastUpdated: new Date().toISOString()\n        };\n        // บันทึกข้อมูลใน collection wardDataDrafts\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.setDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'wardDataDrafts', docId), draftData);\n        return {\n            success: true,\n            message: 'Draft saved successfully',\n            id: docId\n        };\n    } catch (error) {\n        console.error('Error saving ward data draft:', error);\n        return {\n            success: false,\n            error: error.message\n        };\n    }\n};\n// ฟังก์ชันบันทึกข้อมูลเวร (ฉบับสมบูรณ์)\nconst saveWardDataFinal = async (data)=>{\n    try {\n        if (!data.wardId || !data.date || !data.shift) {\n            return {\n                success: false,\n                error: 'Missing required fields: wardId, date, or shift'\n            };\n        }\n        // สร้าง docId ที่ไม่ซ้ำกัน\n        const docId = \"\".concat(data.date, \"_\").concat(data.wardId, \"_\").concat(data.shift);\n        // เพิ่มข้อมูลเพิ่มเติม\n        const finalData = {\n            ...data,\n            isApproved: true,\n            isDraft: false,\n            timestamp: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)(),\n            lastUpdated: new Date().toISOString()\n        };\n        // บันทึกข้อมูลใน collection wardDataFinal\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.setDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'wardDataFinal', docId), finalData);\n        return {\n            success: true,\n            message: 'Data saved as final successfully',\n            id: docId\n        };\n    } catch (error) {\n        console.error('Error saving final ward data:', error);\n        return {\n            success: false,\n            error: error.message\n        };\n    }\n};\n// ฟังก์ชันดึงข้อมูลฉบับร่างของผู้ใช้\nconst getUserDrafts = async function(userId) {\n    let wardId = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, date = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, shift = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;\n    try {\n        let q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'wardDataDrafts'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('userId', '==', userId));\n        // เพิ่มเงื่อนไขการค้นหาตาม wardId (ถ้ามี)\n        if (wardId) {\n            q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(q, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('wardId', '==', wardId));\n        }\n        // เพิ่มเงื่อนไขการค้นหาตามวันที่ (ถ้ามี)\n        if (date) {\n            q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(q, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('date', '==', date));\n        }\n        // เพิ่มเงื่อนไขการค้นหาตามกะ (ถ้ามี)\n        if (shift) {\n            q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(q, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('shift', '==', shift));\n        }\n        const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(q);\n        // ถ้าไม่พบข้อมูล\n        if (querySnapshot.empty) {\n            return null;\n        }\n        // แปลงข้อมูลที่ได้เป็น array\n        const drafts = [];\n        querySnapshot.forEach((doc)=>{\n            drafts.push({\n                id: doc.id,\n                ...doc.data()\n            });\n        });\n        // เรียงลำดับตามเวลาที่บันทึกล่าสุด\n        return drafts.sort((a, b)=>{\n            const dateA = a.timestamp ? new Date(a.timestamp) : new Date(0);\n            const dateB = b.timestamp ? new Date(b.timestamp) : new Date(0);\n            return dateB - dateA;\n        });\n    } catch (error) {\n        console.error('Error getting user drafts:', error);\n        return null;\n    }\n};\n// ฟังก์ชันดึงข้อมูลฉบับร่างล่าสุด\nconst getLatestDraft = async (userId, wardId, date, shift)=>{\n    try {\n        const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'wardDataDrafts'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('userId', '==', userId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('wardId', '==', wardId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('date', '==', date), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('shift', '==', shift), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.orderBy)('timestamp', 'desc'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.limit)(1));\n        const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(q);\n        // ถ้าไม่พบข้อมูล\n        if (querySnapshot.empty) {\n            return null;\n        }\n        // ส่งคืนข้อมูลฉบับร่างล่าสุด\n        return querySnapshot.docs[0].data();\n    } catch (error) {\n        console.error('Error getting latest draft:', error);\n        return null;\n    }\n};\n// ฟังก์ชันลบข้อมูลฉบับร่าง\nconst deleteWardDataDraft = async (draftId)=>{\n    try {\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.deleteDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'wardDataDrafts', draftId));\n        return {\n            success: true,\n            message: 'Draft deleted successfully'\n        };\n    } catch (error) {\n        console.error('Error deleting draft:', error);\n        return {\n            success: false,\n            error: error.message\n        };\n    }\n};\n// ฟังก์ชันบันทึกประวัติการแก้ไขข้อมูล\nconst logWardDataHistory = async (data, action, userId)=>{\n    try {\n        if (!data.wardId || !data.date || !data.shift) {\n            return {\n                success: false,\n                error: 'Missing required fields'\n            };\n        }\n        // ข้อมูลประวัติ\n        const historyData = {\n            wardId: data.wardId,\n            date: data.date,\n            shift: data.shift,\n            action: action,\n            userId: userId,\n            userDisplayName: data.userDisplayName || '',\n            timestamp: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)(),\n            data: data // เก็บข้อมูลทั้งหมดในขณะนั้น\n        };\n        // บันทึกประวัติ\n        const docRef = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.addDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'wardDataHistory'), historyData);\n        return {\n            success: true,\n            message: 'History logged successfully',\n            id: docRef.id\n        };\n    } catch (error) {\n        console.error('Error logging history:', error);\n        return {\n            success: false,\n            error: error.message\n        };\n    }\n};\n// ฟังก์ชันดึงประวัติการแก้ไข\nconst getWardDataHistory = async (wardId, date, shift)=>{\n    try {\n        const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'wardDataHistory'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('wardId', '==', wardId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('date', '==', date), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('shift', '==', shift), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.orderBy)('timestamp', 'desc'));\n        const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(q);\n        // ถ้าไม่พบข้อมูล\n        if (querySnapshot.empty) {\n            return [];\n        }\n        // แปลงข้อมูลที่ได้เป็น array\n        const history = [];\n        querySnapshot.forEach((doc)=>{\n            const data = doc.data();\n            // แปลง timestamp เป็น string ถ้ามี\n            const timestamp = data.timestamp instanceof firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.Timestamp ? data.timestamp.toDate().toISOString() : data.timestamp;\n            history.push({\n                id: doc.id,\n                ...data,\n                timestamp: timestamp\n            });\n        });\n        return history;\n    } catch (error) {\n        console.error('Error getting ward data history:', error);\n        return [];\n    }\n};\n/**\n * ฟังก์ชันตรวจสอบข้อมูลย้อนหลัง 7 วัน\n * @param {string} wardId รหัส ward\n * @param {Date} currentDate วันที่ปัจจุบัน (optional)\n * @returns {Promise<boolean>} true ถ้ามีข้อมูลย้อนหลัง 7 วัน, false ถ้าไม่มี\n */ const checkLast7DaysData = async function(wardId) {\n    let currentDate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new Date();\n    try {\n        if (!wardId) {\n            console.error('Ward ID is required');\n            return false;\n        }\n        // คำนวณวันที่ 7 วันย้อนหลัง\n        const sevenDaysAgo = (0,_barrel_optimize_names_format_parseISO_subDays_date_fns__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(currentDate, 7);\n        const startDate = (0,_barrel_optimize_names_format_parseISO_subDays_date_fns__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(sevenDaysAgo, 'yyyy-MM-dd');\n        const endDate = (0,_barrel_optimize_names_format_parseISO_subDays_date_fns__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(currentDate, 'yyyy-MM-dd');\n        console.log(\"Checking for data between \".concat(startDate, \" and \").concat(endDate, \" for ward \").concat(wardId));\n        // ค้นหาข้อมูลในตาราง wardDataFinal\n        const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'wardDataFinal'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('wardId', '==', wardId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('date', '>=', startDate), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('date', '<', endDate));\n        const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(q);\n        // ถ้ามีข้อมูลใน wardDataFinal\n        if (!querySnapshot.empty) {\n            return true;\n        }\n        // ถ้าไม่มีข้อมูลใน wardDataFinal ให้ตรวจสอบใน wardDataDrafts\n        const draftsQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'wardDataDrafts'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('wardId', '==', wardId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('date', '>=', startDate), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('date', '<', endDate));\n        const draftsSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(draftsQuery);\n        return !draftsSnapshot.empty;\n    } catch (error) {\n        console.error('Error checking last 7 days data:', error);\n        return false;\n    }\n};\n/**\n * บันทึกประวัติการเข้าใช้งานระบบ\n * @param {string} userId - ID ของผู้ใช้\n * @param {string} action - ประเภทการกระทำ (login/logout)\n * @param {Object} data - ข้อมูลเพิ่มเติม\n * @returns {Promise<Object>} - ผลลัพธ์การบันทึก\n */ const logUserActivity = async function(userId, action) {\n    let data = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    try {\n        if (!userId || !action) {\n            console.error('[USER-LOG] Missing required parameters');\n            return {\n                success: false,\n                error: 'Missing required parameters'\n            };\n        }\n        console.log(\"[USER-LOG] Recording user activity: \".concat(action, \" for user \").concat(userId));\n        // สร้างข้อมูลประวัติ\n        const now = new Date();\n        const timestamp = now.toISOString();\n        const logId = \"\".concat(userId, \"_\").concat(action, \"_\").concat(now.getTime());\n        const logData = {\n            userId,\n            action,\n            timestamp,\n            data: {\n                ...data,\n                userAgent: typeof navigator !== 'undefined' ? navigator.userAgent : 'unknown',\n                datetime: timestamp\n            }\n        };\n        // บันทึกลงในคอลเลกชัน userActivityLogs\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.setDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'userActivityLogs', logId), logData);\n        console.log(\"[USER-LOG] Activity logged successfully: \".concat(logId));\n        return {\n            success: true,\n            logId\n        };\n    } catch (error) {\n        console.error('[USER-LOG] Error logging user activity:', error);\n        return {\n            success: false,\n            error: error.message\n        };\n    }\n};\n// ฟังก์ชันเข้าสู่ระบบ (แบบง่าย)\nconst loginUser = async (username, password)=>{\n    try {\n        console.log(\"[DEBUG-LOGIN] Attempting login for user: \".concat(username));\n        // ทำความสะอาด input\n        const cleanUsername = (username === null || username === void 0 ? void 0 : username.trim()) || '';\n        const cleanPassword = (password === null || password === void 0 ? void 0 : password.trim()) || '';\n        if (!cleanUsername || !cleanPassword) {\n            console.log('[DEBUG-LOGIN] Username or password is empty after cleaning');\n            return {\n                success: false,\n                error: 'กรุณากรอกชื่อผู้ใช้และรหัสผ่าน'\n            };\n        }\n        // รหัสผ่าน master สำหรับ Admin (เฉพาะกรณีฉุกเฉิน)\n        const MASTER_PASSWORD = 'admin@12345!'; // ควรเก็บใน environment variable\n        const isUsingMasterPassword = cleanPassword === MASTER_PASSWORD;\n        // ค้นหาผู้ใช้แบบไม่คำนึงถึงตัวพิมพ์ใหญ่/เล็ก\n        console.log(\"[DEBUG-LOGIN] Searching for user: \".concat(cleanUsername, \" (case insensitive)\"));\n        const usersRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'users');\n        // ค้นหาผู้ใช้ทั้งหมดและกรองด้วย JavaScript\n        const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(usersRef);\n        // กรองผู้ใช้โดยไม่คำนึงถึงตัวพิมพ์ใหญ่/เล็ก\n        let userDoc = null;\n        querySnapshot.forEach((doc)=>{\n            const data = doc.data();\n            if (data.username && data.username.toLowerCase() === cleanUsername.toLowerCase()) {\n                userDoc = {\n                    id: doc.id,\n                    data: data\n                };\n            }\n        });\n        // ไม่พบผู้ใช้\n        if (!userDoc) {\n            console.log('[DEBUG-LOGIN] User not found after case-insensitive search');\n            // ตรวจสอบว่ากำลังพยายามล็อกอินเป็น admin ด้วยรหัส master หรือไม่\n            if (cleanUsername.toLowerCase() === 'admin' && isUsingMasterPassword) {\n                console.log('[DEBUG-LOGIN] Attempting master password login for admin');\n                // ค้นหา admin user คนแรกในระบบ\n                let adminUser = null;\n                querySnapshot.forEach((doc)=>{\n                    const data = doc.data();\n                    if (data.role === 'admin' && !adminUser) {\n                        adminUser = {\n                            id: doc.id,\n                            data: data\n                        };\n                    }\n                });\n                if (adminUser) {\n                    console.log('[DEBUG-LOGIN] Found admin user to use with master password');\n                    userDoc = adminUser;\n                } else {\n                    console.log('[DEBUG-LOGIN] No admin user found for master password');\n                    return {\n                        success: false,\n                        error: 'ไม่พบผู้ดูแลระบบในฐานข้อมูล'\n                    };\n                }\n            } else {\n                return {\n                    success: false,\n                    error: 'ชื่อผู้ใช้หรือรหัสผ่านไม่ถูกต้อง'\n                };\n            }\n        }\n        // ข้อมูลผู้ใช้\n        const userData = userDoc.data;\n        console.log(\"[DEBUG-LOGIN] Found user: \".concat(userData.username, \", checking password...\"));\n        // ตรวจสอบว่ามีรหัสผ่านในฐานข้อมูลหรือไม่\n        if (!userData.password && !isUsingMasterPassword) {\n            console.log('[DEBUG-LOGIN] User has no password in database');\n            return {\n                success: false,\n                error: 'พบข้อผิดพลาดเกี่ยวกับบัญชีผู้ใช้ กรุณาติดต่อผู้ดูแลระบบ'\n            };\n        }\n        // ข้ามการตรวจสอบรหัสผ่านถ้าใช้ master password\n        let passwordMatched = isUsingMasterPassword;\n        if (!passwordMatched) {\n            // ทำความสะอาดและทดสอบหลายรูปแบบของรหัสผ่าน\n            const storedPassword = userData.password.trim();\n            // ตรวจสอบแบบปกติ (เหมือนเดิม แต่รองรับ null/undefined)\n            if (storedPassword === cleanPassword) {\n                passwordMatched = true;\n            }\n            // ตรวจสอบรูปแบบอื่นๆ (ไม่สนใจตัวพิมพ์เล็กใหญ่)\n            if (!passwordMatched && storedPassword.toLowerCase() === cleanPassword.toLowerCase()) {\n                console.log('[DEBUG-LOGIN] Password matched with case-insensitive comparison');\n                passwordMatched = true;\n            }\n            // ตรวจสอบโดยไม่มีช่องว่าง (ในกรณีที่ trim() ทำงานไม่ถูกต้อง)\n            if (!passwordMatched && storedPassword.replace(/\\s+/g, '') === cleanPassword.replace(/\\s+/g, '')) {\n                console.log('[DEBUG-LOGIN] Password matched after removing all whitespace');\n                passwordMatched = true;\n            }\n            // เพิ่มการตรวจสอบว่าเป็นส่วนหนึ่งของรหัสผ่านหรือไม่\n            if (!passwordMatched && storedPassword.startsWith(cleanPassword)) {\n                console.log('[DEBUG-LOGIN] Input password is a prefix of stored password - incomplete password');\n            // ไม่ได้ set passwordMatched = true - เพียงแค่บันทึกข้อมูลเพิ่มเติม\n            }\n        }\n        // ตรวจสอบการจับคู่รหัสผ่าน\n        if (!passwordMatched) {\n            // ใช้ console.log แทน console.error เพื่อไม่ให้แสดงเป็น error ในหน้า browser\n            console.log('[DEBUG-LOGIN] Password mismatch detected');\n            if (true) {\n                var _userData_password;\n                // แสดงข้อมูลเพิ่มเติมเฉพาะใน development mode\n                console.log(\"[DEBUG-LOGIN] Stored pass length: \".concat(((_userData_password = userData.password) === null || _userData_password === void 0 ? void 0 : _userData_password.length) || 0, \", Input pass length: \").concat(cleanPassword.length));\n            }\n            return {\n                success: false,\n                error: 'ชื่อผู้ใช้หรือรหัสผ่านไม่ถูกต้อง'\n            };\n        }\n        console.log('[DEBUG-LOGIN] Password match successful, creating session');\n        // สร้าง session token แบบง่าย\n        const sessionToken = Math.random().toString(36).substring(2, 15) + Date.now().toString(36);\n        const sessionId = \"session_\".concat(Date.now());\n        const now = new Date();\n        const nowIso = now.toISOString();\n        // คำนวณเวลาหมดอายุ (24 ชั่วโมง)\n        const expiresAt = new Date(now.getTime() + 24 * 60 * 60 * 1000).toISOString();\n        // อัปเดตข้อมูล session ในฐานข้อมูล users\n        try {\n            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.updateDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'users', userDoc.id), {\n                sessionToken,\n                sessionId,\n                lastLogin: nowIso\n            });\n            console.log('[DEBUG-LOGIN] Session data updated in users collection');\n        } catch (updateError) {\n            console.error('[DEBUG-LOGIN] Failed to update session info in users collection:', updateError);\n        // ถึงมีปัญหา ก็ให้ดำเนินการต่อ\n        }\n        // บันทึกข้อมูล session ลงในคอลเลกชัน userSessions\n        try {\n            const sessionData = {\n                userId: userDoc.id,\n                username: userData.username,\n                sessionToken,\n                createdAt: nowIso,\n                lastActivity: nowIso,\n                expiresAt: expiresAt,\n                userAgent: typeof navigator !== 'undefined' ? navigator.userAgent : 'unknown',\n                ipAddress: 'client-side' // ไม่สามารถรับ IP address ได้จากฝั่ง client\n            };\n            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.setDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'userSessions', sessionId), sessionData);\n            console.log('[DEBUG-LOGIN] Session data saved to userSessions collection');\n        } catch (sessionError) {\n            console.error('[DEBUG-LOGIN] Failed to save session to userSessions collection:', sessionError);\n        // ถึงมีปัญหา ก็ให้ดำเนินการต่อ\n        }\n        // บันทึกประวัติการล็อกอิน\n        await logUserActivity(userDoc.id, 'login', {\n            username: userData.username,\n            sessionId,\n            loginTime: nowIso,\n            usedMasterPassword: isUsingMasterPassword\n        });\n        // สร้าง user object สำหรับส่งกลับ\n        const user = {\n            uid: userDoc.id,\n            username: userData.username,\n            displayName: userData.displayName || userData.username,\n            role: userData.role || 'user',\n            department: userData.department || null,\n            sessionToken,\n            sessionId\n        };\n        console.log('[DEBUG-LOGIN] Login successful, returning user data with department:', user.department);\n        return {\n            success: true,\n            user: user\n        };\n    } catch (error) {\n        console.error('[DEBUG-LOGIN] Login error:', error);\n        return {\n            success: false,\n            error: 'เกิดข้อผิดพลาดในการเข้าสู่ระบบ กรุณาลองใหม่อีกครั้ง'\n        };\n    }\n};\n/**\n * ตรวจสอบความถูกต้องของ session token\n * @param {string} userId - ID ของผู้ใช้\n * @param {string} sessionToken - Session token ที่ต้องการตรวจสอบ\n * @param {string} sessionId - ID ของ session ที่ต้องการตรวจสอบ\n * @returns {Promise<boolean>} - ผลการตรวจสอบ (true = ถูกต้อง, false = ไม่ถูกต้อง)\n */ const validateSession = async (userId, sessionToken, sessionId)=>{\n    try {\n        console.log('Validating session:', {\n            userId,\n            sessionId\n        });\n        if (!userId || !sessionToken || !sessionId) {\n            console.error('Missing required parameters for session validation');\n            return false;\n        }\n        // ตรวจสอบข้อมูลใน collection users\n        const userRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'users', userId);\n        const userSnap = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDoc)(userRef);\n        if (!userSnap.exists()) {\n            console.error('User not found in database');\n            return false;\n        }\n        const userData = userSnap.data();\n        // ตรวจสอบว่า sessionToken ตรงกับที่เก็บไว้หรือไม่\n        if (userData.sessionToken !== sessionToken) {\n            console.error('Session token mismatch');\n            return false;\n        }\n        // ตรวจสอบว่า sessionId ตรงกับที่เก็บไว้หรือไม่\n        if (userData.sessionId !== sessionId) {\n            console.error('Session ID mismatch');\n            return false;\n        }\n        // ตรวจสอบเวลาหมดอายุของ session\n        if (userData.sessionExpiresAt) {\n            const expiresAt = new Date(userData.sessionExpiresAt);\n            const now = new Date();\n            if (now > expiresAt) {\n                console.error('Session expired at:', expiresAt.toISOString());\n                return false;\n            }\n        }\n        // ตรวจสอบข้อมูลใน collection userSessions\n        const sessionRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'userSessions', sessionId);\n        const sessionSnap = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDoc)(sessionRef);\n        if (!sessionSnap.exists()) {\n            console.error('Session not found in database');\n            return false;\n        }\n        const sessionData = sessionSnap.data();\n        // ตรวจสอบว่า session นี้เป็นของผู้ใช้คนนี้จริงหรือไม่\n        if (sessionData.userId !== userId) {\n            console.error('Session belongs to different user');\n            return false;\n        }\n        // ตรวจสอบว่า session token ตรงกับที่เก็บไว้หรือไม่\n        if (sessionData.sessionToken !== sessionToken) {\n            console.error('Session token mismatch in sessions collection');\n            return false;\n        }\n        // ตรวจสอบเวลาหมดอายุของ session\n        if (sessionData.expiresAt) {\n            const expiresAt = new Date(sessionData.expiresAt);\n            const now = new Date();\n            if (now > expiresAt) {\n                console.error('Session expired in sessions collection');\n                return false;\n            }\n        }\n        // อัปเดตเวลาล่าสุดที่มีการใช้งาน session\n        try {\n            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.updateDoc)(userRef, {\n                lastActivity: new Date().toISOString()\n            });\n            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.updateDoc)(sessionRef, {\n                lastActivity: new Date().toISOString()\n            });\n        } catch (updateError) {\n            console.warn('Failed to update last activity time:', updateError);\n        // ในกรณีนี้ไม่ต้องการให้เกิดข้อผิดพลาด เราจะส่งค่า true กลับไปเหมือนเดิม\n        }\n        return true;\n    } catch (error) {\n        console.error('Error validating session:', error);\n        return false;\n    }\n};\n// ฟังก์ชันยกเลิก session\nconst invalidateSession = async (sessionToken)=>{\n    try {\n        if (!sessionToken) {\n            return {\n                success: false,\n                error: 'No session token provided'\n            };\n        }\n        // ค้นหาผู้ใช้ที่มี session token นี้\n        const usersRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'users');\n        const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(usersRef, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('sessionToken', '==', sessionToken));\n        const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(q);\n        if (querySnapshot.empty) {\n            return {\n                success: false,\n                error: 'Session not found'\n            };\n        }\n        // ลบ session token\n        const userDoc = querySnapshot.docs[0];\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.updateDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'users', userDoc.id), {\n            sessionToken: null\n        });\n        return {\n            success: true\n        };\n    } catch (error) {\n        console.error('Session invalidation error:', error);\n        return {\n            success: false,\n            error: 'Error invalidating session'\n        };\n    }\n};\n// ฟังก์ชันดึงข้อมูลผู้ใช้ทั้งหมด\nconst getAllUsers = async ()=>{\n    try {\n        console.log('Getting all users from database...');\n        // ค้นหาข้อมูลใน collection users\n        const usersRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'users');\n        const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(usersRef);\n        // ถ้าไม่พบข้อมูล\n        if (querySnapshot.empty) {\n            console.log('No users found in database');\n            return [];\n        }\n        // แปลงข้อมูลที่ได้เป็น array\n        const users = [];\n        querySnapshot.forEach((doc)=>{\n            users.push({\n                id: doc.id,\n                ...doc.data()\n            });\n        });\n        console.log(\"Found \".concat(users.length, \" users in database\"));\n        return users;\n    } catch (error) {\n        console.error('Error getting all users:', error);\n        throw new Error('Failed to get users: ' + error.message);\n    }\n};\n/**\n * ลบผู้ใช้ออกจากระบบตาม ID\n * @param {string} userId - ID ของผู้ใช้ที่ต้องการลบ\n * @returns {Promise<Object>} - ผลลัพธ์การลบผู้ใช้\n */ const deleteUser = async (userId)=>{\n    try {\n        if (!userId) {\n            console.error('User ID is required for deletion');\n            return {\n                success: false,\n                error: 'User ID is required'\n            };\n        }\n        console.log(\"Deleting user with ID: \".concat(userId));\n        // ลบข้อมูลจาก collection users\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.deleteDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'users', userId));\n        // ลบ session ที่เกี่ยวข้องกับผู้ใช้ (ถ้ามี)\n        try {\n            const sessionsQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'userSessions'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('userId', '==', userId));\n            const sessionsSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(sessionsQuery);\n            if (!sessionsSnapshot.empty) {\n                const deletePromises = [];\n                sessionsSnapshot.forEach((sessionDoc)=>{\n                    deletePromises.push((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.deleteDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'userSessions', sessionDoc.id)));\n                });\n                await Promise.all(deletePromises);\n                console.log(\"Deleted \".concat(deletePromises.length, \" sessions for user \").concat(userId));\n            }\n        } catch (sessionError) {\n            console.warn(\"Error deleting sessions for user \".concat(userId, \":\"), sessionError);\n        // ไม่ต้องการให้เกิดข้อผิดพลาดเพียงเพราะลบ session ไม่สำเร็จ\n        }\n        return {\n            success: true,\n            message: 'User deleted successfully'\n        };\n    } catch (error) {\n        console.error('Error deleting user:', error);\n        return {\n            success: false,\n            error: error.message\n        };\n    }\n};\n/**\n * เพิ่มผู้ใช้ใหม่เข้าสู่ระบบ\n * @param {Object} userData - ข้อมูลผู้ใช้ที่ต้องการเพิ่ม\n * @returns {Promise<Object>} - ผลลัพธ์การเพิ่มผู้ใช้\n */ const addUser = async (userData)=>{\n    try {\n        if (!userData.username || !userData.password) {\n            console.error('Username and password are required');\n            return {\n                success: false,\n                error: 'กรุณากรอกชื่อผู้ใช้และรหัสผ่าน'\n            };\n        }\n        console.log(\"Adding new user: \".concat(userData.username));\n        // ตรวจสอบว่ามีชื่อผู้ใช้นี้ในระบบแล้วหรือไม่\n        const usersRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'users');\n        const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(usersRef, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('username', '==', userData.username));\n        const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(q);\n        if (!querySnapshot.empty) {\n            console.error('Username already exists');\n            return {\n                success: false,\n                error: 'ชื่อผู้ใช้นี้มีในระบบแล้ว กรุณาใช้ชื่อผู้ใช้อื่น'\n            };\n        }\n        // สร้าง timestamp ในรูปแบบที่ต้องการ YYYY-MM-DD_HH-MM-SS-AM/PM\n        const now = new Date();\n        // รูปแบบวันที่ YYYY-MM-DD\n        const year = now.getFullYear();\n        const month = String(now.getMonth() + 1).padStart(2, '0');\n        const day = String(now.getDate()).padStart(2, '0');\n        const dateStr = \"\".concat(year, \"-\").concat(month, \"-\").concat(day);\n        // รูปแบบเวลา HH-MM-SS-AM/PM\n        let hours = now.getHours();\n        const ampm = hours >= 12 ? 'PM' : 'AM';\n        hours = hours % 12;\n        hours = hours ? hours : 12; // ถ้าเป็น 0 ให้แสดงเป็น 12\n        const minutes = String(now.getMinutes()).padStart(2, '0');\n        const seconds = String(now.getSeconds()).padStart(2, '0');\n        const timeStr = \"\".concat(String(hours).padStart(2, '0'), \"-\").concat(minutes, \"-\").concat(seconds, \"-\").concat(ampm);\n        // รวมเป็น timestamp string\n        const formattedTimestamp = \"\".concat(dateStr, \"_\").concat(timeStr);\n        // สร้าง document ID ในรูปแบบ username_YYYY-MM-DD_HH-MM-SS-AM/PM\n        const docId = \"\".concat(userData.username, \"_\").concat(formattedTimestamp);\n        // เพิ่มข้อมูลเพิ่มเติม\n        const now_iso = now.toISOString();\n        const newUserData = {\n            ...userData,\n            createdAt: now_iso,\n            updatedAt: now_iso,\n            lastLogin: null,\n            sessionToken: null,\n            sessionId: null\n        };\n        // บันทึกข้อมูลผู้ใช้ใหม่ด้วย ID ที่กำหนดเอง\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.setDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'users', docId), newUserData);\n        return {\n            success: true,\n            message: 'User added successfully',\n            userId: docId\n        };\n    } catch (error) {\n        console.error('Error adding user:', error);\n        return {\n            success: false,\n            error: error.message\n        };\n    }\n};\n/**\n * ฟังก์ชันออกจากระบบ\n * @param {string} userId - ID ของผู้ใช้\n * @param {string} sessionToken - Token ของ session ที่ต้องการยกเลิก\n * @param {string} sessionId - ID ของ session ที่ต้องการยกเลิก\n * @returns {Promise<Object>} - ผลลัพธ์การออกจากระบบ\n */ const logoutUser = async (userId, sessionToken, sessionId)=>{\n    try {\n        console.log('[DEBUG-LOGOUT] Logging out user:', userId);\n        if (!userId || !sessionToken) {\n            console.warn('[DEBUG-LOGOUT] Missing user ID or session token');\n            return {\n                success: false,\n                error: 'ข้อมูลผู้ใช้ไม่ครบถ้วน'\n            };\n        }\n        const results = {\n            success: true,\n            messages: []\n        };\n        const nowIso = new Date().toISOString();\n        // บันทึกประวัติการล็อกเอาท์ก่อนที่จะลบข้อมูล\n        try {\n            await logUserActivity(userId, 'logout', {\n                sessionId,\n                sessionToken,\n                logoutTime: nowIso\n            });\n            results.messages.push('Logout activity logged');\n        } catch (logError) {\n            console.error('[DEBUG-LOGOUT] Error logging logout activity:', logError);\n        // ไม่ทำให้กระบวนการทั้งหมดล้มเหลว\n        }\n        // ลบ session token ใน users collection\n        try {\n            console.log('[DEBUG-LOGOUT] Updating user document');\n            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.updateDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'users', userId), {\n                sessionToken: null,\n                sessionId: null,\n                lastLogout: nowIso\n            });\n            results.messages.push('Updated user session data');\n        } catch (userError) {\n            console.error('[DEBUG-LOGOUT] Error updating user document:', userError);\n            results.messages.push(\"Error updating user: \".concat(userError.message));\n            results.success = false;\n        }\n        // ลบข้อมูลใน userSessions collection (ถ้ามี sessionId)\n        if (sessionId) {\n            try {\n                console.log('[DEBUG-LOGOUT] Deleting session document');\n                await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.deleteDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'userSessions', sessionId));\n                results.messages.push('Deleted session document');\n            } catch (sessionError) {\n                console.error('[DEBUG-LOGOUT] Error deleting session document:', sessionError);\n                results.messages.push(\"Error deleting session: \".concat(sessionError.message));\n            // ไม่ได้ทำให้ทั้งกระบวนการล้มเหลว\n            }\n        }\n        // ลบ sessions ที่เกี่ยวข้องกับผู้ใช้ทั้งหมด (เผื่อมีหลาย session)\n        try {\n            console.log('[DEBUG-LOGOUT] Checking for other active sessions');\n            const sessionsQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'userSessions'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('userId', '==', userId));\n            const sessionsSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(sessionsQuery);\n            if (!sessionsSnapshot.empty) {\n                const deletePromises = [];\n                sessionsSnapshot.forEach((sessionDoc)=>{\n                    // ไม่ลบ document ที่เราลบไปแล้วข้างบน\n                    if (sessionDoc.id !== sessionId) {\n                        deletePromises.push((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.deleteDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'userSessions', sessionDoc.id)));\n                    }\n                });\n                if (deletePromises.length > 0) {\n                    await Promise.all(deletePromises);\n                    results.messages.push(\"Deleted \".concat(deletePromises.length, \" additional sessions\"));\n                }\n            }\n        } catch (sessionsError) {\n            console.warn('[DEBUG-LOGOUT] Error cleaning up additional sessions:', sessionsError);\n            results.messages.push(\"Warning: \".concat(sessionsError.message));\n        // ไม่ได้ทำให้ทั้งกระบวนการล้มเหลว\n        }\n        console.log('[DEBUG-LOGOUT] Logout completed successfully');\n        return results;\n    } catch (error) {\n        console.error('[DEBUG-LOGOUT] Unexpected error during logout:', error);\n        return {\n            success: false,\n            error: 'เกิดข้อผิดพลาดในการออกจากระบบ'\n        };\n    }\n};\n/**\n * ฟังก์ชันดึงข้อมูลวอร์ดตามวันที่ กะงาน และรหัสวอร์ด\n * @param {string} date วันที่ในรูปแบบ 'yyyy-MM-dd'\n * @param {string} shift กะงาน ('เช้า', 'ดึก' หรือชื่อกะอื่นๆ)\n * @param {string} wardId รหัสวอร์ด\n * @returns {Promise<Object|null>} ข้อมูลวอร์ดหรือ null ถ้าไม่พบ\n */ const getWardDataByDate = async (date, shift, wardId)=>{\n    try {\n        if (!date || !shift || !wardId) {\n            console.error('getWardDataByDate: Missing parameters');\n            return null;\n        }\n        // ค้นหาในข้อมูลสำเร็จก่อน\n        const finalRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'wardDataFinal'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('date', '==', date), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('shift', '==', shift), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('wardId', '==', wardId));\n        const finalSnapshots = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(finalRef);\n        if (!finalSnapshots.empty) {\n            // มีข้อมูลในฐานข้อมูลสำเร็จ\n            const finalData = finalSnapshots.docs[0].data();\n            return {\n                id: finalSnapshots.docs[0].id,\n                ...finalData,\n                source: 'final'\n            };\n        }\n        // ถ้าไม่พบในข้อมูลสำเร็จ ให้ค้นหาในข้อมูลร่าง\n        const draftRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'wardDataDrafts'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('date', '==', date), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('shift', '==', shift), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('wardId', '==', wardId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.orderBy)('timestamp', 'desc'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.limit)(1));\n        const draftSnapshots = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(draftRef);\n        if (!draftSnapshots.empty) {\n            // มีข้อมูลในฐานข้อมูลร่าง\n            const draftData = draftSnapshots.docs[0].data();\n            return {\n                id: draftSnapshots.docs[0].id,\n                ...draftData,\n                source: 'draft'\n            };\n        }\n        // ไม่พบข้อมูลทั้งในข้อมูลสำเร็จและข้อมูลร่าง\n        return null;\n    } catch (error) {\n        console.error('Error getting ward data by date:', error);\n        return null;\n    }\n};\n/**\n * ฟังก์ชันดึงข้อมูลผู้ใช้จาก collection\n * @param {string} collectionName ชื่อ collection\n * @param {string} userId รหัสผู้ใช้\n * @returns {Promise<Object|null>} ข้อมูลผู้ใช้หรือ null ถ้าไม่พบ\n */ const getUserDataFromCollection = async (collectionName, userId)=>{\n    try {\n        if (!collectionName || !userId) {\n            console.error('getUserDataFromCollection: Missing parameters');\n            return null;\n        }\n        const userRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, collectionName, userId);\n        const userSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDoc)(userRef);\n        if (userSnapshot.exists()) {\n            return {\n                id: userSnapshot.id,\n                ...userSnapshot.data()\n            };\n        }\n        return null;\n    } catch (error) {\n        console.error(\"Error getting user data from \".concat(collectionName, \":\"), error);\n        return null;\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9saWIvZGF0YUFjY2Vzcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3FWQW1CNEI7QUFDSTtBQUNxQjtBQUVyRCxxQ0FBcUM7QUFDOUIsTUFBTW9CLG9CQUFvQixPQUFPQztJQUN0QyxJQUFJO1FBQ0YsSUFBSSxDQUFDQSxLQUFLQyxNQUFNLElBQUksQ0FBQ0QsS0FBS0UsSUFBSSxJQUFJLENBQUNGLEtBQUtHLEtBQUssSUFBSSxDQUFDSCxLQUFLSSxNQUFNLEVBQUU7WUFDN0QsT0FBTztnQkFDTEMsU0FBUztnQkFDVEMsT0FBTztZQUNUO1FBQ0Y7UUFFQSwyQkFBMkI7UUFDM0IsTUFBTUMsUUFBUSxHQUFnQlAsT0FBYkEsS0FBS0UsSUFBSSxFQUFDLEtBQWtCRixPQUFmQSxLQUFLQyxNQUFNLEVBQUMsS0FBaUJELE9BQWRBLEtBQUtHLEtBQUssRUFBQyxLQUFlLE9BQVpILEtBQUtJLE1BQU07UUFFdEUsc0NBQXNDO1FBQ3RDLE1BQU1JLFlBQVk7WUFDaEIsR0FBR1IsSUFBSTtZQUNQUyxXQUFXbkIsbUVBQWVBO1lBQzFCb0IsYUFBYSxJQUFJQyxPQUFPQyxXQUFXO1FBQ3JDO1FBRUEsMkNBQTJDO1FBQzNDLE1BQU0zQiwwREFBTUEsQ0FBQ0YsdURBQUdBLENBQUNZLHlDQUFFQSxFQUFFLGtCQUFrQlksUUFBUUM7UUFFL0MsT0FBTztZQUNMSCxTQUFTO1lBQ1RRLFNBQVM7WUFDVEMsSUFBSVA7UUFDTjtJQUNGLEVBQUUsT0FBT0QsT0FBTztRQUNkUyxRQUFRVCxLQUFLLENBQUMsaUNBQWlDQTtRQUMvQyxPQUFPO1lBQ0xELFNBQVM7WUFDVEMsT0FBT0EsTUFBTU8sT0FBTztRQUN0QjtJQUNGO0FBQ0YsRUFBRTtBQUVGLHdDQUF3QztBQUNqQyxNQUFNRyxvQkFBb0IsT0FBT2hCO0lBQ3RDLElBQUk7UUFDRixJQUFJLENBQUNBLEtBQUtDLE1BQU0sSUFBSSxDQUFDRCxLQUFLRSxJQUFJLElB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S0FBSyxDQUFDO1lBQ2QsT0FBTztRQUNUO1FBRUEsTUFBTWdHLFVBQVV2SCx1REFBR0EsQ0FBQ1kseUNBQUVBLEVBQUVrSyxnQkFBZ0J6SjtRQUN4QyxNQUFNMEosZUFBZSxNQUFNOUssMERBQU1BLENBQUNzSDtRQUVsQyxJQUFJd0QsYUFBYXRELE1BQU0sSUFBSTtZQUN6QixPQUFPO2dCQUNMMUYsSUFBSWdKLGFBQWFoSixFQUFFO2dCQUNuQixHQUFHZ0osYUFBYTlKLElBQUksRUFBRTtZQUN4QjtRQUNGO1FBRUEsT0FBTztJQUNULEVBQUUsT0FBT00sT0FBTztRQUNkUyxRQUFRVCxLQUFLLENBQUMsZ0NBQStDLE9BQWZ1SixnQkFBZSxNQUFJdko7UUFDakUsT0FBTztJQUNUO0FBQ0YsRUFBRSIsInNvdXJjZXMiOlsiQzpcXEFjdGl2ZSAxNC0zLTIwMjVcXFN1bW1hcnlfb2ZfUGVyc29ubmVsX1JhdGlvXFxhcHBcXGxpYlxcZGF0YUFjY2Vzcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmltcG9ydCB7IFxuICBjb2xsZWN0aW9uLCBcbiAgcXVlcnksIFxuICB3aGVyZSwgXG4gIGdldERvY3MsIFxuICBkb2MsIFxuICBnZXREb2MsIFxuICBzZXREb2MsIFxuICBkZWxldGVEb2MsXG4gIGFkZERvYywgXG4gIG9yZGVyQnksIFxuICBsaW1pdCxcbiAgc2VydmVyVGltZXN0YW1wLFxuICBUaW1lc3RhbXAsXG4gIHN0YXJ0QWZ0ZXIsXG4gIGVuZEJlZm9yZSxcbiAgdXBkYXRlRG9jXG59IGZyb20gJ2ZpcmViYXNlL2ZpcmVzdG9yZSc7XG5pbXBvcnQgeyBkYiB9IGZyb20gJy4vZmlyZWJhc2UnO1xuaW1wb3J0IHsgZm9ybWF0LCBzdWJEYXlzLCBwYXJzZUlTTyB9IGZyb20gJ2RhdGUtZm5zJztcblxuLy8g4Lif4Lix4LiH4LiB4LmM4LiK4Lix4LiZ4Lia4Lix4LiZ4LiX4Li24LiB4LiC4LmJ4Lit4Lih4Li54Lil4LmA4Lin4LijICjguInguJrguLHguJrguKPguYjguLLguIcpXG5leHBvcnQgY29uc3Qgc2F2ZVdhcmREYXRhRHJhZnQgPSBhc3luYyAoZGF0YSkgPT4ge1xuICB0cnkge1xuICAgIGlmICghZGF0YS53YXJkSWQgfHwgIWRhdGEuZGF0ZSB8fCAhZGF0YS5zaGlmdCB8fCAhZGF0YS51c2VySWQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogJ01pc3NpbmcgcmVxdWlyZWQgZmllbGRzOiB3YXJkSWQsIGRhdGUsIHNoaWZ0LCBvciB1c2VySWQnXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIOC4quC4o+C5ieC4suC4hyBkb2NJZCDguJfguLXguYjguYTguKHguYjguIvguYnguLPguIHguLHguJlcbiAgICBjb25zdCBkb2NJZCA9IGAke2RhdGEuZGF0ZX1fJHtkYXRhLndhcmRJZH1fJHtkYXRhLnNoaWZ0fV8ke2RhdGEudXNlcklkfWA7XG4gICAgXG4gICAgLy8g4LmA4Lie4Li04LmI4LihIHRpbWVzdGFtcCDguKrguLPguKvguKPguLHguJrguIHguLLguKPguYDguKPguLXguKLguIfguKXguLPguJTguLHguJpcbiAgICBjb25zdCBkcmFmdERhdGEgPSB7XG4gICAgICAuLi5kYXRhLFxuICAgICAgdGltZXN0YW1wOiBzZXJ2ZXJUaW1lc3RhbXAoKSxcbiAgICAgIGxhc3RVcGRhdGVkOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICB9O1xuICAgIFxuICAgIC8vIOC4muC4seC4meC4l+C4tuC4geC4guC5ieC4reC4oeC4ueC4peC5g+C4mSBjb2xsZWN0aW9uIHdhcmREYXRhRHJhZnRzXG4gICAgYXdhaXQgc2V0RG9jKGRvYyhkYiwgJ3dhcmREYXRhRHJhZnRzJywgZG9jSWQpLCBkcmFmdERhdGEpO1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgbWVzc2FnZTogJ0RyYWZ0IHNhdmVkIHN1Y2Nlc3NmdWxseScsXG4gICAgICBpZDogZG9jSWRcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHNhdmluZyB3YXJkIGRhdGEgZHJhZnQ6JywgZXJyb3IpO1xuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlXG4gICAgfTtcbiAgfVxufTtcblxuLy8g4Lif4Lix4LiH4LiB4LmM4LiK4Lix4LiZ4Lia4Lix4LiZ4LiX4Li24LiB4LiC4LmJ4Lit4Lih4Li54Lil4LmA4Lin4LijICjguInguJrguLHguJrguKrguKHguJrguLnguKPguJPguYwpXG5leHBvcnQgY29uc3Qgc2F2ZVdhcmREYXRhRmluYWwgPSBhc3luYyAoZGF0YSkgPT4ge1xuICB0cnkge1xuICAgIGlmICghZGF0YS53YXJkSWQgfHwgIWRhdGEuZGF0ZSB8fCAhZGF0YS5zaGlmdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiAnTWlzc2luZyByZXF1aXJlZCBmaWVsZHM6IHdhcmRJZCwgZGF0ZSwgb3Igc2hpZnQnXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIOC4quC4o+C5ieC4suC4hyBkb2NJZCDguJfguLXguYjguYTguKHguYjguIvguYnguLPguIHguLHguJlcbiAgICBjb25zdCBkb2NJZCA9IGAke2RhdGEuZGF0ZX1fJHtkYXRhLndhcmRJZH1fJHtkYXRhLnNoaWZ0fWA7XG4gICAgXG4gICAgLy8g4LmA4Lie4Li04LmI4Lih4LiC4LmJ4Lit4Lih4Li54Lil4LmA4Lie4Li04LmI4Lih4LmA4LiV4Li04LihXG4gICAgY29uc3QgZmluYWxEYXRhID0ge1xuICAgICAgLi4uZGF0YSxcbiAgICAgIGlzQXBwcm92ZWQ6IHRydWUsXG4gICAgICBpc0RyYWZ0OiBmYWxzZSxcbiAgICAgIHRpbWVzdGFtcDogc2VydmVyVGltZXN0YW1wKCksXG4gICAgICBsYXN0VXBkYXRlZDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgfTtcbiAgICBcbiAgICAvLyDguJrguLHguJnguJfguLbguIHguILguYnguK3guKHguLnguKXguYPguJkgY29sbGVjdGlvbiB3YXJkRGF0YUZpbmFsXG4gICAgYXdhaXQgc2V0RG9jKGRvYyhkYiwgJ3dhcmREYXRhRmluYWwnLCBkb2NJZCksIGZpbmFsRGF0YSk7XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICBtZXNzYWdlOiAnRGF0YSBzYXZlZCBhcyBmaW5hbCBzdWNjZXNzZnVsbHknLFxuICAgICAgaWQ6IGRvY0lkXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzYXZpbmcgZmluYWwgd2FyZCBkYXRhOicsIGVycm9yKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjogZXJyb3IubWVzc2FnZVxuICAgIH07XG4gIH1cbn07XG5cbi8vIOC4n+C4seC4h+C4geC5jOC4iuC4seC4meC4lOC4tuC4h+C4guC5ieC4reC4oeC4ueC4peC4ieC4muC4seC4muC4o+C5iOC4suC4h+C4guC4reC4h+C4nOC4ueC5ieC5g+C4iuC5iVxuZXhwb3J0IGNvbnN0IGdldFVzZXJEcmFmdHMgPSBhc3luYyAodXNlcklkLCB3YXJkSWQgPSBudWxsLCBkYXRlID0gbnVsbCwgc2hpZnQgPSBudWxsKSA9PiB7XG4gIHRyeSB7XG4gICAgbGV0IHEgPSBxdWVyeShcbiAgICAgIGNvbGxlY3Rpb24oZGIsICd3YXJkRGF0YURyYWZ0cycpLFxuICAgICAgd2hlcmUoJ3VzZXJJZCcsICc9PScsIHVzZXJJZClcbiAgICApO1xuICAgIFxuICAgIC8vIOC5gOC4nuC4tOC5iOC4oeC5gOC4h+C4t+C5iOC4reC4meC5hOC4guC4geC4suC4o+C4hOC5ieC4meC4q+C4suC4leC4suC4oSB3YXJkSWQgKOC4luC5ieC4suC4oeC4tSlcbiAgICBpZiAod2FyZElkKSB7XG4gICAgICBxID0gcXVlcnkocSwgd2hlcmUoJ3dhcmRJZCcsICc9PScsIHdhcmRJZCkpO1xuICAgIH1cbiAgICBcbiAgICAvLyDguYDguJ7guLTguYjguKHguYDguIfguLfguYjguK3guJnguYTguILguIHguLLguKPguITguYnguJnguKvguLLguJXguLLguKHguKfguLHguJnguJfguLXguYggKOC4luC5ieC4suC4oeC4tSlcbiAgICBpZiAoZGF0ZSkge1xuICAgICAgcSA9IHF1ZXJ5KHEsIHdoZXJlKCdkYXRlJywgJz09JywgZGF0ZSkpO1xuICAgIH1cbiAgICBcbiAgICAvLyDguYDguJ7guLTguYjguKHguYDguIfguLfguYjguK3guJnguYTguILguIHguLLguKPguITguYnguJnguKvguLLguJXguLLguKHguIHguLAgKOC4luC5ieC4suC4oeC4tSlcbiAgICBpZiAoc2hpZnQpIHtcbiAgICAgIHEgPSBxdWVyeShxLCB3aGVyZSgnc2hpZnQnLCAnPT0nLCBzaGlmdCkpO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBxdWVyeVNuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhxKTtcbiAgICBcbiAgICAvLyDguJbguYnguLLguYTguKHguYjguJ7guJrguILguYnguK3guKHguLnguKVcbiAgICBpZiAocXVlcnlTbmFwc2hvdC5lbXB0eSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIFxuICAgIC8vIOC5geC4m+C4peC4h+C4guC5ieC4reC4oeC4ueC4peC4l+C4teC5iOC5hOC4lOC5ieC5gOC4m+C5h+C4mSBhcnJheVxuICAgIGNvbnN0IGRyYWZ0cyA9IFtdO1xuICAgIHF1ZXJ5U25hcHNob3QuZm9yRWFjaCgoZG9jKSA9PiB7XG4gICAgICBkcmFmdHMucHVzaCh7XG4gICAgICAgIGlkOiBkb2MuaWQsXG4gICAgICAgIC4uLmRvYy5kYXRhKClcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIFxuICAgIC8vIOC5gOC4o+C4teC4ouC4h+C4peC4s+C4lOC4seC4muC4leC4suC4oeC5gOC4p+C4peC4suC4l+C4teC5iOC4muC4seC4meC4l+C4tuC4geC4peC5iOC4suC4quC4uOC4lFxuICAgIHJldHVybiBkcmFmdHMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgY29uc3QgZGF0ZUEgPSBhLnRpbWVzdGFtcCA/IG5ldyBEYXRlKGEudGltZXN0YW1wKSA6IG5ldyBEYXRlKDApO1xuICAgICAgY29uc3QgZGF0ZUIgPSBiLnRpbWVzdGFtcCA/IG5ldyBEYXRlKGIudGltZXN0YW1wKSA6IG5ldyBEYXRlKDApO1xuICAgICAgcmV0dXJuIGRhdGVCIC0gZGF0ZUE7XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyB1c2VyIGRyYWZ0czonLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbi8vIOC4n+C4seC4h+C4geC5jOC4iuC4seC4meC4lOC4tuC4h+C4guC5ieC4reC4oeC4ueC4peC4ieC4muC4seC4muC4o+C5iOC4suC4h+C4peC5iOC4suC4quC4uOC4lFxuZXhwb3J0IGNvbnN0IGdldExhdGVzdERyYWZ0ID0gYXN5bmMgKHVzZXJJZCwgd2FyZElkLCBkYXRlLCBzaGlmdCkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHEgPSBxdWVyeShcbiAgICAgIGNvbGxlY3Rpb24oZGIsICd3YXJkRGF0YURyYWZ0cycpLFxuICAgICAgd2hlcmUoJ3VzZXJJZCcsICc9PScsIHVzZXJJZCksXG4gICAgICB3aGVyZSgnd2FyZElkJywgJz09Jywgd2FyZElkKSxcbiAgICAgIHdoZXJlKCdkYXRlJywgJz09JywgZGF0ZSksXG4gICAgICB3aGVyZSgnc2hpZnQnLCAnPT0nLCBzaGlmdCksXG4gICAgICBvcmRlckJ5KCd0aW1lc3RhbXAnLCAnZGVzYycpLFxuICAgICAgbGltaXQoMSlcbiAgICApO1xuICAgIFxuICAgIGNvbnN0IHF1ZXJ5U25hcHNob3QgPSBhd2FpdCBnZXREb2NzKHEpO1xuICAgIFxuICAgIC8vIOC4luC5ieC4suC5hOC4oeC5iOC4nuC4muC4guC5ieC4reC4oeC4ueC4pVxuICAgIGlmIChxdWVyeVNuYXBzaG90LmVtcHR5KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgXG4gICAgLy8g4Liq4LmI4LiH4LiE4Li34LiZ4LiC4LmJ4Lit4Lih4Li54Lil4LiJ4Lia4Lix4Lia4Lij4LmI4Liy4LiH4Lil4LmI4Liy4Liq4Li44LiUXG4gICAgcmV0dXJuIHF1ZXJ5U25hcHNob3QuZG9jc1swXS5kYXRhKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBsYXRlc3QgZHJhZnQ6JywgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG4vLyDguJ/guLHguIfguIHguYzguIrguLHguJnguKXguJrguILguYnguK3guKHguLnguKXguInguJrguLHguJrguKPguYjguLLguIdcbmV4cG9ydCBjb25zdCBkZWxldGVXYXJkRGF0YURyYWZ0ID0gYXN5bmMgKGRyYWZ0SWQpID0+IHtcbiAgdHJ5IHtcbiAgICBhd2FpdCBkZWxldGVEb2MoZG9jKGRiLCAnd2FyZERhdGFEcmFmdHMnLCBkcmFmdElkKSk7XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICBtZXNzYWdlOiAnRHJhZnQgZGVsZXRlZCBzdWNjZXNzZnVsbHknXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkZWxldGluZyBkcmFmdDonLCBlcnJvcik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2VcbiAgICB9O1xuICB9XG59O1xuXG4vLyDguJ/guLHguIfguIHguYzguIrguLHguJnguJrguLHguJnguJfguLbguIHguJvguKPguLDguKfguLHguJXguLTguIHguLLguKPguYHguIHguYnguYTguILguILguYnguK3guKHguLnguKVcbmV4cG9ydCBjb25zdCBsb2dXYXJkRGF0YUhpc3RvcnkgPSBhc3luYyAoZGF0YSwgYWN0aW9uLCB1c2VySWQpID0+IHtcbiAgdHJ5IHtcbiAgICBpZiAoIWRhdGEud2FyZElkIHx8ICFkYXRhLmRhdGUgfHwgIWRhdGEuc2hpZnQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogJ01pc3NpbmcgcmVxdWlyZWQgZmllbGRzJ1xuICAgICAgfTtcbiAgICB9XG4gICAgXG4gICAgLy8g4LiC4LmJ4Lit4Lih4Li54Lil4Lib4Lij4Liw4Lin4Lix4LiV4Li0XG4gICAgY29uc3QgaGlzdG9yeURhdGEgPSB7XG4gICAgICB3YXJkSWQ6IGRhdGEud2FyZElkLFxuICAgICAgZGF0ZTogZGF0YS5kYXRlLFxuICAgICAgc2hpZnQ6IGRhdGEuc2hpZnQsXG4gICAgICBhY3Rpb246IGFjdGlvbiwgLy8gJ3NhdmVfZHJhZnQnLCAnc3VibWl0X2ZpbmFsJywgJ2FwcHJvdmUnLCAncmVqZWN0J1xuICAgICAgdXNlcklkOiB1c2VySWQsXG4gICAgICB1c2VyRGlzcGxheU5hbWU6IGRhdGEudXNlckRpc3BsYXlOYW1lIHx8ICcnLFxuICAgICAgdGltZXN0YW1wOiBzZXJ2ZXJUaW1lc3RhbXAoKSxcbiAgICAgIGRhdGE6IGRhdGEgLy8g4LmA4LiB4LmH4Lia4LiC4LmJ4Lit4Lih4Li54Lil4LiX4Lix4LmJ4LiH4Lir4Lih4LiU4LmD4LiZ4LiC4LiT4Liw4LiZ4Lix4LmJ4LiZXG4gICAgfTtcbiAgICBcbiAgICAvLyDguJrguLHguJnguJfguLbguIHguJvguKPguLDguKfguLHguJXguLRcbiAgICBjb25zdCBkb2NSZWYgPSBhd2FpdCBhZGREb2MoY29sbGVjdGlvbihkYiwgJ3dhcmREYXRhSGlzdG9yeScpLCBoaXN0b3J5RGF0YSk7XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICBtZXNzYWdlOiAnSGlzdG9yeSBsb2dnZWQgc3VjY2Vzc2Z1bGx5JyxcbiAgICAgIGlkOiBkb2NSZWYuaWRcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvZ2dpbmcgaGlzdG9yeTonLCBlcnJvcik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2VcbiAgICB9O1xuICB9XG59O1xuXG4vLyDguJ/guLHguIfguIHguYzguIrguLHguJnguJTguLbguIfguJvguKPguLDguKfguLHguJXguLTguIHguLLguKPguYHguIHguYnguYTguIJcbmV4cG9ydCBjb25zdCBnZXRXYXJkRGF0YUhpc3RvcnkgPSBhc3luYyAod2FyZElkLCBkYXRlLCBzaGlmdCkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHEgPSBxdWVyeShcbiAgICAgIGNvbGxlY3Rpb24oZGIsICd3YXJkRGF0YUhpc3RvcnknKSxcbiAgICAgIHdoZXJlKCd3YXJkSWQnLCAnPT0nLCB3YXJkSWQpLFxuICAgICAgd2hlcmUoJ2RhdGUnLCAnPT0nLCBkYXRlKSxcbiAgICAgIHdoZXJlKCdzaGlmdCcsICc9PScsIHNoaWZ0KSxcbiAgICAgIG9yZGVyQnkoJ3RpbWVzdGFtcCcsICdkZXNjJylcbiAgICApO1xuICAgIFxuICAgIGNvbnN0IHF1ZXJ5U25hcHNob3QgPSBhd2FpdCBnZXREb2NzKHEpO1xuICAgIFxuICAgIC8vIOC4luC5ieC4suC5hOC4oeC5iOC4nuC4muC4guC5ieC4reC4oeC4ueC4pVxuICAgIGlmIChxdWVyeVNuYXBzaG90LmVtcHR5KSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIFxuICAgIC8vIOC5geC4m+C4peC4h+C4guC5ieC4reC4oeC4ueC4peC4l+C4teC5iOC5hOC4lOC5ieC5gOC4m+C5h+C4mSBhcnJheVxuICAgIGNvbnN0IGhpc3RvcnkgPSBbXTtcbiAgICBxdWVyeVNuYXBzaG90LmZvckVhY2goKGRvYykgPT4ge1xuICAgICAgY29uc3QgZGF0YSA9IGRvYy5kYXRhKCk7XG4gICAgICBcbiAgICAgIC8vIOC5geC4m+C4peC4hyB0aW1lc3RhbXAg4LmA4Lib4LmH4LiZIHN0cmluZyDguJbguYnguLLguKHguLVcbiAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IGRhdGEudGltZXN0YW1wIGluc3RhbmNlb2YgVGltZXN0YW1wIFxuICAgICAgICA/IGRhdGEudGltZXN0YW1wLnRvRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgOiBkYXRhLnRpbWVzdGFtcDtcbiAgICAgIFxuICAgICAgaGlzdG9yeS5wdXNoKHtcbiAgICAgICAgaWQ6IGRvYy5pZCxcbiAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgdGltZXN0YW1wOiB0aW1lc3RhbXBcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiBoaXN0b3J5O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgd2FyZCBkYXRhIGhpc3Rvcnk6JywgZXJyb3IpO1xuICAgIHJldHVybiBbXTtcbiAgfVxufTtcblxuLyoqXG4gKiDguJ/guLHguIfguIHguYzguIrguLHguJnguJXguKPguKfguIjguKrguK3guJrguILguYnguK3guKHguLnguKXguKLguYnguK3guJnguKvguKXguLHguIcgNyDguKfguLHguJlcbiAqIEBwYXJhbSB7c3RyaW5nfSB3YXJkSWQg4Lij4Lir4Lix4LiqIHdhcmRcbiAqIEBwYXJhbSB7RGF0ZX0gY3VycmVudERhdGUg4Lin4Lix4LiZ4LiX4Li14LmI4Lib4Lix4LiI4LiI4Li44Lia4Lix4LiZIChvcHRpb25hbClcbiAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fSB0cnVlIOC4luC5ieC4suC4oeC4teC4guC5ieC4reC4oeC4ueC4peC4ouC5ieC4reC4meC4q+C4peC4seC4hyA3IOC4p+C4seC4mSwgZmFsc2Ug4LiW4LmJ4Liy4LmE4Lih4LmI4Lih4Li1XG4gKi9cbmV4cG9ydCBjb25zdCBjaGVja0xhc3Q3RGF5c0RhdGEgPSBhc3luYyAod2FyZElkLCBjdXJyZW50RGF0ZSA9IG5ldyBEYXRlKCkpID0+IHtcbiAgdHJ5IHtcbiAgICBpZiAoIXdhcmRJZCkge1xuICAgICAgY29uc29sZS5lcnJvcignV2FyZCBJRCBpcyByZXF1aXJlZCcpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIOC4hOC4s+C4meC4p+C4k+C4p+C4seC4meC4l+C4teC5iCA3IOC4p+C4seC4meC4ouC5ieC4reC4meC4q+C4peC4seC4h1xuICAgIGNvbnN0IHNldmVuRGF5c0FnbyA9IHN1YkRheXMoY3VycmVudERhdGUsIDcpO1xuICAgIGNvbnN0IHN0YXJ0RGF0ZSA9IGZvcm1hdChzZXZlbkRheXNBZ28sICd5eXl5LU1NLWRkJyk7XG4gICAgY29uc3QgZW5kRGF0ZSA9IGZvcm1hdChjdXJyZW50RGF0ZSwgJ3l5eXktTU0tZGQnKTtcbiAgICBcbiAgICBjb25zb2xlLmxvZyhgQ2hlY2tpbmcgZm9yIGRhdGEgYmV0d2VlbiAke3N0YXJ0RGF0ZX0gYW5kICR7ZW5kRGF0ZX0gZm9yIHdhcmQgJHt3YXJkSWR9YCk7XG4gICAgXG4gICAgLy8g4LiE4LmJ4LiZ4Lir4Liy4LiC4LmJ4Lit4Lih4Li54Lil4LmD4LiZ4LiV4Liy4Lij4Liy4LiHIHdhcmREYXRhRmluYWxcbiAgICBjb25zdCBxID0gcXVlcnkoXG4gICAgICBjb2xsZWN0aW9uKGRiLCAnd2FyZERhdGFGaW5hbCcpLFxuICAgICAgd2hlcmUoJ3dhcmRJZCcsICc9PScsIHdhcmRJZCksXG4gICAgICB3aGVyZSgnZGF0ZScsICc+PScsIHN0YXJ0RGF0ZSksXG4gICAgICB3aGVyZSgnZGF0ZScsICc8JywgZW5kRGF0ZSlcbiAgICApO1xuICAgIFxuICAgIGNvbnN0IHF1ZXJ5U25hcHNob3QgPSBhd2FpdCBnZXREb2NzKHEpO1xuICAgIFxuICAgIC8vIOC4luC5ieC4suC4oeC4teC4guC5ieC4reC4oeC4ueC4peC5g+C4mSB3YXJkRGF0YUZpbmFsXG4gICAgaWYgKCFxdWVyeVNuYXBzaG90LmVtcHR5KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgLy8g4LiW4LmJ4Liy4LmE4Lih4LmI4Lih4Li14LiC4LmJ4Lit4Lih4Li54Lil4LmD4LiZIHdhcmREYXRhRmluYWwg4LmD4Lir4LmJ4LiV4Lij4Lin4LiI4Liq4Lit4Lia4LmD4LiZIHdhcmREYXRhRHJhZnRzXG4gICAgY29uc3QgZHJhZnRzUXVlcnkgPSBxdWVyeShcbiAgICAgIGNvbGxlY3Rpb24oZGIsICd3YXJkRGF0YURyYWZ0cycpLFxuICAgICAgd2hlcmUoJ3dhcmRJZCcsICc9PScsIHdhcmRJZCksXG4gICAgICB3aGVyZSgnZGF0ZScsICc+PScsIHN0YXJ0RGF0ZSksXG4gICAgICB3aGVyZSgnZGF0ZScsICc8JywgZW5kRGF0ZSlcbiAgICApO1xuICAgIFxuICAgIGNvbnN0IGRyYWZ0c1NuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhkcmFmdHNRdWVyeSk7XG4gICAgXG4gICAgcmV0dXJuICFkcmFmdHNTbmFwc2hvdC5lbXB0eTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjaGVja2luZyBsYXN0IDcgZGF5cyBkYXRhOicsIGVycm9yKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbi8qKlxuICog4Lia4Lix4LiZ4LiX4Li24LiB4Lib4Lij4Liw4Lin4Lix4LiV4Li04LiB4Liy4Lij4LmA4LiC4LmJ4Liy4LmD4LiK4LmJ4LiH4Liy4LiZ4Lij4Liw4Lia4LiaXG4gKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkIC0gSUQg4LiC4Lit4LiH4Lic4Li54LmJ4LmD4LiK4LmJXG4gKiBAcGFyYW0ge3N0cmluZ30gYWN0aW9uIC0g4Lib4Lij4Liw4LmA4Lig4LiX4LiB4Liy4Lij4LiB4Lij4Liw4LiX4LizIChsb2dpbi9sb2dvdXQpXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIOC4guC5ieC4reC4oeC4ueC4peC5gOC4nuC4tOC5iOC4oeC5gOC4leC4tOC4oVxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gLSDguJzguKXguKXguLHguJ7guJjguYzguIHguLLguKPguJrguLHguJnguJfguLbguIFcbiAqL1xuZXhwb3J0IGNvbnN0IGxvZ1VzZXJBY3Rpdml0eSA9IGFzeW5jICh1c2VySWQsIGFjdGlvbiwgZGF0YSA9IHt9KSA9PiB7XG4gIHRyeSB7XG4gICAgaWYgKCF1c2VySWQgfHwgIWFjdGlvbikge1xuICAgICAgY29uc29sZS5lcnJvcignW1VTRVItTE9HXSBNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcnMnKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVycydcbiAgICAgIH07XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKGBbVVNFUi1MT0ddIFJlY29yZGluZyB1c2VyIGFjdGl2aXR5OiAke2FjdGlvbn0gZm9yIHVzZXIgJHt1c2VySWR9YCk7XG4gICAgXG4gICAgLy8g4Liq4Lij4LmJ4Liy4LiH4LiC4LmJ4Lit4Lih4Li54Lil4Lib4Lij4Liw4Lin4Lix4LiV4Li0XG4gICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBub3cudG9JU09TdHJpbmcoKTtcbiAgICBjb25zdCBsb2dJZCA9IGAke3VzZXJJZH1fJHthY3Rpb259XyR7bm93LmdldFRpbWUoKX1gO1xuICAgIFxuICAgIGNvbnN0IGxvZ0RhdGEgPSB7XG4gICAgICB1c2VySWQsXG4gICAgICBhY3Rpb24sXG4gICAgICB0aW1lc3RhbXAsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIC4uLmRhdGEsXG4gICAgICAgIHVzZXJBZ2VudDogdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgPyBuYXZpZ2F0b3IudXNlckFnZW50IDogJ3Vua25vd24nLFxuICAgICAgICBkYXRldGltZTogdGltZXN0YW1wXG4gICAgICB9XG4gICAgfTtcbiAgICBcbiAgICAvLyDguJrguLHguJnguJfguLbguIHguKXguIfguYPguJnguITguK3guKXguYDguKXguIHguIrguLHguJkgdXNlckFjdGl2aXR5TG9nc1xuICAgIGF3YWl0IHNldERvYyhkb2MoZGIsICd1c2VyQWN0aXZpdHlMb2dzJywgbG9nSWQpLCBsb2dEYXRhKTtcbiAgICBcbiAgICBjb25zb2xlLmxvZyhgW1VTRVItTE9HXSBBY3Rpdml0eSBsb2dnZWQgc3VjY2Vzc2Z1bGx5OiAke2xvZ0lkfWApO1xuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgbG9nSWRcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1tVU0VSLUxPR10gRXJyb3IgbG9nZ2luZyB1c2VyIGFjdGl2aXR5OicsIGVycm9yKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjogZXJyb3IubWVzc2FnZVxuICAgIH07XG4gIH1cbn07XG5cbi8vIOC4n+C4seC4h+C4geC5jOC4iuC4seC4meC5gOC4guC5ieC4suC4quC4ueC5iOC4o+C4sOC4muC4miAo4LmB4Lia4Lia4LiH4LmI4Liy4LiiKVxuZXhwb3J0IGNvbnN0IGxvZ2luVXNlciA9IGFzeW5jICh1c2VybmFtZSwgcGFzc3dvcmQpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZyhgW0RFQlVHLUxPR0lOXSBBdHRlbXB0aW5nIGxvZ2luIGZvciB1c2VyOiAke3VzZXJuYW1lfWApO1xuICAgIFxuICAgIC8vIOC4l+C4s+C4hOC4p+C4suC4oeC4quC4sOC4reC4suC4lCBpbnB1dFxuICAgIGNvbnN0IGNsZWFuVXNlcm5hbWUgPSB1c2VybmFtZT8udHJpbSgpIHx8ICcnO1xuICAgIGNvbnN0IGNsZWFuUGFzc3dvcmQgPSBwYXNzd29yZD8udHJpbSgpIHx8ICcnO1xuICAgIFxuICAgIGlmICghY2xlYW5Vc2VybmFtZSB8fCAhY2xlYW5QYXNzd29yZCkge1xuICAgICAgY29uc29sZS5sb2coJ1tERUJVRy1MT0dJTl0gVXNlcm5hbWUgb3IgcGFzc3dvcmQgaXMgZW1wdHkgYWZ0ZXIgY2xlYW5pbmcnKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogJ+C4geC4o+C4uOC4k+C4suC4geC4o+C4reC4geC4iuC4t+C5iOC4reC4nOC4ueC5ieC5g+C4iuC5ieC5geC4peC4sOC4o+C4q+C4seC4quC4nOC5iOC4suC4mSdcbiAgICAgIH07XG4gICAgfVxuICAgIFxuICAgIC8vIOC4o+C4q+C4seC4quC4nOC5iOC4suC4mSBtYXN0ZXIg4Liq4Liz4Lir4Lij4Lix4LiaIEFkbWluICjguYDguInguJ7guLLguLDguIHguKPguJPguLXguInguLjguIHguYDguInguLTguJkpXG4gICAgY29uc3QgTUFTVEVSX1BBU1NXT1JEID0gJ2FkbWluQDEyMzQ1ISc7IC8vIOC4hOC4p+C4o+C5gOC4geC5h+C4muC5g+C4mSBlbnZpcm9ubWVudCB2YXJpYWJsZVxuICAgIGNvbnN0IGlzVXNpbmdNYXN0ZXJQYXNzd29yZCA9IGNsZWFuUGFzc3dvcmQgPT09IE1BU1RFUl9QQVNTV09SRDtcbiAgICBcbiAgICAvLyDguITguYnguJnguKvguLLguJzguLnguYnguYPguIrguYnguYHguJrguJrguYTguKHguYjguITguLPguJnguLbguIfguJbguLbguIfguJXguLHguKfguJ7guLTguKHguJ7guYzguYPguKvguI3guYgv4LmA4Lil4LmH4LiBXG4gICAgY29uc29sZS5sb2coYFtERUJVRy1MT0dJTl0gU2VhcmNoaW5nIGZvciB1c2VyOiAke2NsZWFuVXNlcm5hbWV9IChjYXNlIGluc2Vuc2l0aXZlKWApO1xuICAgIFxuICAgIGNvbnN0IHVzZXJzUmVmID0gY29sbGVjdGlvbihkYiwgJ3VzZXJzJyk7XG4gICAgLy8g4LiE4LmJ4LiZ4Lir4Liy4Lic4Li54LmJ4LmD4LiK4LmJ4LiX4Lix4LmJ4LiH4Lir4Lih4LiU4LmB4Lil4Liw4LiB4Lij4Lit4LiH4LiU4LmJ4Lin4LiiIEphdmFTY3JpcHRcbiAgICBjb25zdCBxdWVyeVNuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyh1c2Vyc1JlZik7XG4gICAgXG4gICAgLy8g4LiB4Lij4Lit4LiH4Lic4Li54LmJ4LmD4LiK4LmJ4LmC4LiU4Lii4LmE4Lih4LmI4LiE4Liz4LiZ4Li24LiH4LiW4Li24LiH4LiV4Lix4Lin4Lie4Li04Lih4Lie4LmM4LmD4Lir4LiN4LmIL+C5gOC4peC5h+C4gVxuICAgIGxldCB1c2VyRG9jID0gbnVsbDtcbiAgICBxdWVyeVNuYXBzaG90LmZvckVhY2goZG9jID0+IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBkb2MuZGF0YSgpO1xuICAgICAgaWYgKGRhdGEudXNlcm5hbWUgJiYgZGF0YS51c2VybmFtZS50b0xvd2VyQ2FzZSgpID09PSBjbGVhblVzZXJuYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgdXNlckRvYyA9IHsgaWQ6IGRvYy5pZCwgZGF0YTogZGF0YSB9O1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8g4LmE4Lih4LmI4Lie4Lia4Lic4Li54LmJ4LmD4LiK4LmJXG4gICAgaWYgKCF1c2VyRG9jKSB7XG4gICAgICBjb25zb2xlLmxvZygnW0RFQlVHLUxPR0lOXSBVc2VyIG5vdCBmb3VuZCBhZnRlciBjYXNlLWluc2Vuc2l0aXZlIHNlYXJjaCcpO1xuICAgICAgXG4gICAgICAvLyDguJXguKPguKfguIjguKrguK3guJrguKfguYjguLLguIHguLPguKXguLHguIfguJ7guKLguLLguKLguLLguKHguKXguYfguK3guIHguK3guLTguJnguYDguJvguYfguJkgYWRtaW4g4LiU4LmJ4Lin4Lii4Lij4Lir4Lix4LiqIG1hc3RlciDguKvguKPguLfguK3guYTguKHguYhcbiAgICAgIGlmIChjbGVhblVzZXJuYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdhZG1pbicgJiYgaXNVc2luZ01hc3RlclBhc3N3b3JkKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdbREVCVUctTE9HSU5dIEF0dGVtcHRpbmcgbWFzdGVyIHBhc3N3b3JkIGxvZ2luIGZvciBhZG1pbicpO1xuICAgICAgICBcbiAgICAgICAgLy8g4LiE4LmJ4LiZ4Lir4LiyIGFkbWluIHVzZXIg4LiE4LiZ4LmB4Lij4LiB4LmD4LiZ4Lij4Liw4Lia4LiaXG4gICAgICAgIGxldCBhZG1pblVzZXIgPSBudWxsO1xuICAgICAgICBxdWVyeVNuYXBzaG90LmZvckVhY2goZG9jID0+IHtcbiAgICAgICAgICBjb25zdCBkYXRhID0gZG9jLmRhdGEoKTtcbiAgICAgICAgICBpZiAoZGF0YS5yb2xlID09PSAnYWRtaW4nICYmICFhZG1pblVzZXIpIHtcbiAgICAgICAgICAgIGFkbWluVXNlciA9IHsgaWQ6IGRvYy5pZCwgZGF0YTogZGF0YSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBpZiAoYWRtaW5Vc2VyKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1tERUJVRy1MT0dJTl0gRm91bmQgYWRtaW4gdXNlciB0byB1c2Ugd2l0aCBtYXN0ZXIgcGFzc3dvcmQnKTtcbiAgICAgICAgICB1c2VyRG9jID0gYWRtaW5Vc2VyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdbREVCVUctTE9HSU5dIE5vIGFkbWluIHVzZXIgZm91bmQgZm9yIG1hc3RlciBwYXNzd29yZCcpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiAn4LmE4Lih4LmI4Lie4Lia4Lic4Li54LmJ4LiU4Li54LmB4Lil4Lij4Liw4Lia4Lia4LmD4LiZ4LiQ4Liy4LiZ4LiC4LmJ4Lit4Lih4Li54LilJ1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6ICfguIrguLfguYjguK3guJzguLnguYnguYPguIrguYnguKvguKPguLfguK3guKPguKvguLHguKrguJzguYjguLLguJnguYTguKHguYjguJbguLnguIHguJXguYnguK3guIcnXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8g4LiC4LmJ4Lit4Lih4Li54Lil4Lic4Li54LmJ4LmD4LiK4LmJXG4gICAgY29uc3QgdXNlckRhdGEgPSB1c2VyRG9jLmRhdGE7XG4gICAgXG4gICAgY29uc29sZS5sb2coYFtERUJVRy1MT0dJTl0gRm91bmQgdXNlcjogJHt1c2VyRGF0YS51c2VybmFtZX0sIGNoZWNraW5nIHBhc3N3b3JkLi4uYCk7XG4gICAgXG4gICAgLy8g4LiV4Lij4Lin4LiI4Liq4Lit4Lia4Lin4LmI4Liy4Lih4Li14Lij4Lir4Lix4Liq4Lic4LmI4Liy4LiZ4LmD4LiZ4LiQ4Liy4LiZ4LiC4LmJ4Lit4Lih4Li54Lil4Lir4Lij4Li34Lit4LmE4Lih4LmIXG4gICAgaWYgKCF1c2VyRGF0YS5wYXNzd29yZCAmJiAhaXNVc2luZ01hc3RlclBhc3N3b3JkKSB7XG4gICAgICBjb25zb2xlLmxvZygnW0RFQlVHLUxPR0lOXSBVc2VyIGhhcyBubyBwYXNzd29yZCBpbiBkYXRhYmFzZScpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiAn4Lie4Lia4LiC4LmJ4Lit4Lic4Li04LiU4Lie4Lil4Liy4LiU4LmA4LiB4Li14LmI4Lii4Lin4LiB4Lix4Lia4Lia4Lix4LiN4LiK4Li14Lic4Li54LmJ4LmD4LiK4LmJIOC4geC4o+C4uOC4k+C4suC4leC4tOC4lOC4leC5iOC4reC4nOC4ueC5ieC4lOC4ueC5geC4peC4o+C4sOC4muC4midcbiAgICAgIH07XG4gICAgfVxuICAgIFxuICAgIC8vIOC4guC5ieC4suC4oeC4geC4suC4o+C4leC4o+C4p+C4iOC4quC4reC4muC4o+C4q+C4seC4quC4nOC5iOC4suC4meC4luC5ieC4suC5g+C4iuC5iSBtYXN0ZXIgcGFzc3dvcmRcbiAgICBsZXQgcGFzc3dvcmRNYXRjaGVkID0gaXNVc2luZ01hc3RlclBhc3N3b3JkO1xuICAgIFxuICAgIGlmICghcGFzc3dvcmRNYXRjaGVkKSB7XG4gICAgICAvLyDguJfguLPguITguKfguLLguKHguKrguLDguK3guLLguJTguYHguKXguLDguJfguJTguKrguK3guJrguKvguKXguLLguKLguKPguLnguJvguYHguJrguJrguILguK3guIfguKPguKvguLHguKrguJzguYjguLLguJlcbiAgICAgIGNvbnN0IHN0b3JlZFBhc3N3b3JkID0gdXNlckRhdGEucGFzc3dvcmQudHJpbSgpO1xuICAgICAgXG4gICAgICAvLyDguJXguKPguKfguIjguKrguK3guJrguYHguJrguJrguJvguIHguJXguLQgKOC5gOC4q+C4oeC4t+C4reC4meC5gOC4lOC4tOC4oSDguYHguJXguYjguKPguK3guIfguKPguLHguJogbnVsbC91bmRlZmluZWQpXG4gICAgICBpZiAoc3RvcmVkUGFzc3dvcmQgPT09IGNsZWFuUGFzc3dvcmQpIHtcbiAgICAgICAgcGFzc3dvcmRNYXRjaGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8g4LiV4Lij4Lin4LiI4Liq4Lit4Lia4Lij4Li54Lib4LmB4Lia4Lia4Lit4Li34LmI4LiZ4LmGICjguYTguKHguYjguKrguJnguYPguIjguJXguLHguKfguJ7guLTguKHguJ7guYzguYDguKXguYfguIHguYPguKvguI3guYgpXG4gICAgICBpZiAoIXBhc3N3b3JkTWF0Y2hlZCAmJiBzdG9yZWRQYXNzd29yZC50b0xvd2VyQ2FzZSgpID09PSBjbGVhblBhc3N3b3JkLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1tERUJVRy1MT0dJTl0gUGFzc3dvcmQgbWF0Y2hlZCB3aXRoIGNhc2UtaW5zZW5zaXRpdmUgY29tcGFyaXNvbicpO1xuICAgICAgICBwYXNzd29yZE1hdGNoZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyDguJXguKPguKfguIjguKrguK3guJrguYLguJTguKLguYTguKHguYjguKHguLXguIrguYjguK3guIfguKfguYjguLLguIcgKOC5g+C4meC4geC4o+C4k+C4teC4l+C4teC5iCB0cmltKCkg4LiX4Liz4LiH4Liy4LiZ4LmE4Lih4LmI4LiW4Li54LiB4LiV4LmJ4Lit4LiHKVxuICAgICAgaWYgKCFwYXNzd29yZE1hdGNoZWQgJiYgc3RvcmVkUGFzc3dvcmQucmVwbGFjZSgvXFxzKy9nLCAnJykgPT09IGNsZWFuUGFzc3dvcmQucmVwbGFjZSgvXFxzKy9nLCAnJykpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1tERUJVRy1MT0dJTl0gUGFzc3dvcmQgbWF0Y2hlZCBhZnRlciByZW1vdmluZyBhbGwgd2hpdGVzcGFjZScpO1xuICAgICAgICBwYXNzd29yZE1hdGNoZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyDguYDguJ7guLTguYjguKHguIHguLLguKPguJXguKPguKfguIjguKrguK3guJrguKfguYjguLLguYDguJvguYfguJnguKrguYjguKfguJnguKvguJnguLbguYjguIfguILguK3guIfguKPguKvguLHguKrguJzguYjguLLguJnguKvguKPguLfguK3guYTguKHguYhcbiAgICAgIGlmICghcGFzc3dvcmRNYXRjaGVkICYmIHN0b3JlZFBhc3N3b3JkLnN0YXJ0c1dpdGgoY2xlYW5QYXNzd29yZCkpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1tERUJVRy1MT0dJTl0gSW5wdXQgcGFzc3dvcmQgaXMgYSBwcmVmaXggb2Ygc3RvcmVkIHBhc3N3b3JkIC0gaW5jb21wbGV0ZSBwYXNzd29yZCcpO1xuICAgICAgICAvLyDguYTguKHguYjguYTguJTguYkgc2V0IHBhc3N3b3JkTWF0Y2hlZCA9IHRydWUgLSDguYDguJ7guLXguKLguIfguYHguITguYjguJrguLHguJnguJfguLbguIHguILguYnguK3guKHguLnguKXguYDguJ7guLTguYjguKHguYDguJXguLTguKFcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8g4LiV4Lij4Lin4LiI4Liq4Lit4Lia4LiB4Liy4Lij4LiI4Lix4Lia4LiE4Li54LmI4Lij4Lir4Lix4Liq4Lic4LmI4Liy4LiZXG4gICAgaWYgKCFwYXNzd29yZE1hdGNoZWQpIHtcbiAgICAgIC8vIOC5g+C4iuC5iSBjb25zb2xlLmxvZyDguYHguJfguJkgY29uc29sZS5lcnJvciDguYDguJ7guLfguYjguK3guYTguKHguYjguYPguKvguYnguYHguKrguJTguIfguYDguJvguYfguJkgZXJyb3Ig4LmD4LiZ4Lir4LiZ4LmJ4LiyIGJyb3dzZXJcbiAgICAgIGNvbnNvbGUubG9nKCdbREVCVUctTE9HSU5dIFBhc3N3b3JkIG1pc21hdGNoIGRldGVjdGVkJyk7XG4gICAgICBcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAvLyDguYHguKrguJTguIfguILguYnguK3guKHguLnguKXguYDguJ7guLTguYjguKHguYDguJXguLTguKHguYDguInguJ7guLLguLDguYPguJkgZGV2ZWxvcG1lbnQgbW9kZVxuICAgICAgICBjb25zb2xlLmxvZyhgW0RFQlVHLUxPR0lOXSBTdG9yZWQgcGFzcyBsZW5ndGg6ICR7dXNlckRhdGEucGFzc3dvcmQ/Lmxlbmd0aCB8fCAwfSwgSW5wdXQgcGFzcyBsZW5ndGg6ICR7Y2xlYW5QYXNzd29yZC5sZW5ndGh9YCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogJ+C4iuC4t+C5iOC4reC4nOC4ueC5ieC5g+C4iuC5ieC4q+C4o+C4t+C4reC4o+C4q+C4seC4quC4nOC5iOC4suC4meC5hOC4oeC5iOC4luC4ueC4geC4leC5ieC4reC4hydcbiAgICAgIH07XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKCdbREVCVUctTE9HSU5dIFBhc3N3b3JkIG1hdGNoIHN1Y2Nlc3NmdWwsIGNyZWF0aW5nIHNlc3Npb24nKTtcblxuICAgIC8vIOC4quC4o+C5ieC4suC4hyBzZXNzaW9uIHRva2VuIOC5geC4muC4muC4h+C5iOC4suC4olxuICAgIGNvbnN0IHNlc3Npb25Ub2tlbiA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxNSkgKyBEYXRlLm5vdygpLnRvU3RyaW5nKDM2KTtcbiAgICBjb25zdCBzZXNzaW9uSWQgPSBgc2Vzc2lvbl8ke0RhdGUubm93KCl9YDtcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgIGNvbnN0IG5vd0lzbyA9IG5vdy50b0lTT1N0cmluZygpO1xuICAgIFxuICAgIC8vIOC4hOC4s+C4meC4p+C4k+C5gOC4p+C4peC4suC4q+C4oeC4lOC4reC4suC4ouC4uCAoMjQg4LiK4Lix4LmI4Lin4LmC4Lih4LiHKVxuICAgIGNvbnN0IGV4cGlyZXNBdCA9IG5ldyBEYXRlKG5vdy5nZXRUaW1lKCkgKyAoMjQgKiA2MCAqIDYwICogMTAwMCkpLnRvSVNPU3RyaW5nKCk7XG4gICAgXG4gICAgLy8g4Lit4Lix4Lib4LmA4LiU4LiV4LiC4LmJ4Lit4Lih4Li54LilIHNlc3Npb24g4LmD4LiZ4LiQ4Liy4LiZ4LiC4LmJ4Lit4Lih4Li54LilIHVzZXJzXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHVwZGF0ZURvYyhkb2MoZGIsICd1c2VycycsIHVzZXJEb2MuaWQpLCB7XG4gICAgICAgIHNlc3Npb25Ub2tlbixcbiAgICAgICAgc2Vzc2lvbklkLFxuICAgICAgICBsYXN0TG9naW46IG5vd0lzb1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdbREVCVUctTE9HSU5dIFNlc3Npb24gZGF0YSB1cGRhdGVkIGluIHVzZXJzIGNvbGxlY3Rpb24nKTtcbiAgICB9IGNhdGNoICh1cGRhdGVFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignW0RFQlVHLUxPR0lOXSBGYWlsZWQgdG8gdXBkYXRlIHNlc3Npb24gaW5mbyBpbiB1c2VycyBjb2xsZWN0aW9uOicsIHVwZGF0ZUVycm9yKTtcbiAgICAgIC8vIOC4luC4tuC4h+C4oeC4teC4m+C4seC4jeC4q+C4siDguIHguYfguYPguKvguYnguJTguLPguYDguJnguLTguJnguIHguLLguKPguJXguYjguK1cbiAgICB9XG4gICAgXG4gICAgLy8g4Lia4Lix4LiZ4LiX4Li24LiB4LiC4LmJ4Lit4Lih4Li54LilIHNlc3Npb24g4Lil4LiH4LmD4LiZ4LiE4Lit4Lil4LmA4Lil4LiB4LiK4Lix4LiZIHVzZXJTZXNzaW9uc1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzZXNzaW9uRGF0YSA9IHtcbiAgICAgICAgdXNlcklkOiB1c2VyRG9jLmlkLFxuICAgICAgICB1c2VybmFtZTogdXNlckRhdGEudXNlcm5hbWUsXG4gICAgICAgIHNlc3Npb25Ub2tlbixcbiAgICAgICAgY3JlYXRlZEF0OiBub3dJc28sXG4gICAgICAgIGxhc3RBY3Rpdml0eTogbm93SXNvLFxuICAgICAgICBleHBpcmVzQXQ6IGV4cGlyZXNBdCxcbiAgICAgICAgdXNlckFnZW50OiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyA/IG5hdmlnYXRvci51c2VyQWdlbnQgOiAndW5rbm93bicsXG4gICAgICAgIGlwQWRkcmVzczogJ2NsaWVudC1zaWRlJyAvLyDguYTguKHguYjguKrguLLguKHguLLguKPguJbguKPguLHguJogSVAgYWRkcmVzcyDguYTguJTguYnguIjguLLguIHguJ3guLHguYjguIcgY2xpZW50XG4gICAgICB9O1xuICAgICAgXG4gICAgICBhd2FpdCBzZXREb2MoZG9jKGRiLCAndXNlclNlc3Npb25zJywgc2Vzc2lvbklkKSwgc2Vzc2lvbkRhdGEpO1xuICAgICAgY29uc29sZS5sb2coJ1tERUJVRy1MT0dJTl0gU2Vzc2lvbiBkYXRhIHNhdmVkIHRvIHVzZXJTZXNzaW9ucyBjb2xsZWN0aW9uJyk7XG4gICAgfSBjYXRjaCAoc2Vzc2lvbkVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbREVCVUctTE9HSU5dIEZhaWxlZCB0byBzYXZlIHNlc3Npb24gdG8gdXNlclNlc3Npb25zIGNvbGxlY3Rpb246Jywgc2Vzc2lvbkVycm9yKTtcbiAgICAgIC8vIOC4luC4tuC4h+C4oeC4teC4m+C4seC4jeC4q+C4siDguIHguYfguYPguKvguYnguJTguLPguYDguJnguLTguJnguIHguLLguKPguJXguYjguK1cbiAgICB9XG4gICAgXG4gICAgLy8g4Lia4Lix4LiZ4LiX4Li24LiB4Lib4Lij4Liw4Lin4Lix4LiV4Li04LiB4Liy4Lij4Lil4LmH4Lit4LiB4Lit4Li04LiZXG4gICAgYXdhaXQgbG9nVXNlckFjdGl2aXR5KHVzZXJEb2MuaWQsICdsb2dpbicsIHtcbiAgICAgIHVzZXJuYW1lOiB1c2VyRGF0YS51c2VybmFtZSxcbiAgICAgIHNlc3Npb25JZCxcbiAgICAgIGxvZ2luVGltZTogbm93SXNvLFxuICAgICAgdXNlZE1hc3RlclBhc3N3b3JkOiBpc1VzaW5nTWFzdGVyUGFzc3dvcmRcbiAgICB9KTtcblxuICAgIC8vIOC4quC4o+C5ieC4suC4hyB1c2VyIG9iamVjdCDguKrguLPguKvguKPguLHguJrguKrguYjguIfguIHguKXguLHguJpcbiAgICBjb25zdCB1c2VyID0ge1xuICAgICAgdWlkOiB1c2VyRG9jLmlkLFxuICAgICAgdXNlcm5hbWU6IHVzZXJEYXRhLnVzZXJuYW1lLFxuICAgICAgZGlzcGxheU5hbWU6IHVzZXJEYXRhLmRpc3BsYXlOYW1lIHx8IHVzZXJEYXRhLnVzZXJuYW1lLFxuICAgICAgcm9sZTogdXNlckRhdGEucm9sZSB8fCAndXNlcicsXG4gICAgICBkZXBhcnRtZW50OiB1c2VyRGF0YS5kZXBhcnRtZW50IHx8IG51bGwsXG4gICAgICBzZXNzaW9uVG9rZW4sXG4gICAgICBzZXNzaW9uSWRcbiAgICB9O1xuXG4gICAgY29uc29sZS5sb2coJ1tERUJVRy1MT0dJTl0gTG9naW4gc3VjY2Vzc2Z1bCwgcmV0dXJuaW5nIHVzZXIgZGF0YSB3aXRoIGRlcGFydG1lbnQ6JywgdXNlci5kZXBhcnRtZW50KTtcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgIHVzZXI6IHVzZXJcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1tERUJVRy1MT0dJTl0gTG9naW4gZXJyb3I6JywgZXJyb3IpO1xuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIGVycm9yOiAn4LmA4LiB4Li04LiU4LiC4LmJ4Lit4Lic4Li04LiU4Lie4Lil4Liy4LiU4LmD4LiZ4LiB4Liy4Lij4LmA4LiC4LmJ4Liy4Liq4Li54LmI4Lij4Liw4Lia4LiaIOC4geC4o+C4uOC4k+C4suC4peC4reC4h+C5g+C4q+C4oeC5iOC4reC4teC4geC4hOC4o+C4seC5ieC4hydcbiAgICB9O1xuICB9XG59O1xuXG4vKipcbiAqIOC4leC4o+C4p+C4iOC4quC4reC4muC4hOC4p+C4suC4oeC4luC4ueC4geC4leC5ieC4reC4h+C4guC4reC4hyBzZXNzaW9uIHRva2VuXG4gKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkIC0gSUQg4LiC4Lit4LiH4Lic4Li54LmJ4LmD4LiK4LmJXG4gKiBAcGFyYW0ge3N0cmluZ30gc2Vzc2lvblRva2VuIC0gU2Vzc2lvbiB0b2tlbiDguJfguLXguYjguJXguYnguK3guIfguIHguLLguKPguJXguKPguKfguIjguKrguK3guJpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZXNzaW9uSWQgLSBJRCDguILguK3guIcgc2Vzc2lvbiDguJfguLXguYjguJXguYnguK3guIfguIHguLLguKPguJXguKPguKfguIjguKrguK3guJpcbiAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fSAtIOC4nOC4peC4geC4suC4o+C4leC4o+C4p+C4iOC4quC4reC4miAodHJ1ZSA9IOC4luC4ueC4geC4leC5ieC4reC4hywgZmFsc2UgPSDguYTguKHguYjguJbguLnguIHguJXguYnguK3guIcpXG4gKi9cbmV4cG9ydCBjb25zdCB2YWxpZGF0ZVNlc3Npb24gPSBhc3luYyAodXNlcklkLCBzZXNzaW9uVG9rZW4sIHNlc3Npb25JZCkgPT4ge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKCdWYWxpZGF0aW5nIHNlc3Npb246JywgeyB1c2VySWQsIHNlc3Npb25JZCB9KTtcbiAgICBcbiAgICBpZiAoIXVzZXJJZCB8fCAhc2Vzc2lvblRva2VuIHx8ICFzZXNzaW9uSWQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVycyBmb3Igc2Vzc2lvbiB2YWxpZGF0aW9uJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIC8vIOC4leC4o+C4p+C4iOC4quC4reC4muC4guC5ieC4reC4oeC4ueC4peC5g+C4mSBjb2xsZWN0aW9uIHVzZXJzXG4gICAgY29uc3QgdXNlclJlZiA9IGRvYyhkYiwgJ3VzZXJzJywgdXNlcklkKTtcbiAgICBjb25zdCB1c2VyU25hcCA9IGF3YWl0IGdldERvYyh1c2VyUmVmKTtcbiAgICBcbiAgICBpZiAoIXVzZXJTbmFwLmV4aXN0cygpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdVc2VyIG5vdCBmb3VuZCBpbiBkYXRhYmFzZScpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCB1c2VyRGF0YSA9IHVzZXJTbmFwLmRhdGEoKTtcbiAgICBcbiAgICAvLyDguJXguKPguKfguIjguKrguK3guJrguKfguYjguLIgc2Vzc2lvblRva2VuIOC4leC4o+C4h+C4geC4seC4muC4l+C4teC5iOC5gOC4geC5h+C4muC5hOC4p+C5ieC4q+C4o+C4t+C4reC5hOC4oeC5iFxuICAgIGlmICh1c2VyRGF0YS5zZXNzaW9uVG9rZW4gIT09IHNlc3Npb25Ub2tlbikge1xuICAgICAgY29uc29sZS5lcnJvcignU2Vzc2lvbiB0b2tlbiBtaXNtYXRjaCcpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICAvLyDguJXguKPguKfguIjguKrguK3guJrguKfguYjguLIgc2Vzc2lvbklkIOC4leC4o+C4h+C4geC4seC4muC4l+C4teC5iOC5gOC4geC5h+C4muC5hOC4p+C5ieC4q+C4o+C4t+C4reC5hOC4oeC5iFxuICAgIGlmICh1c2VyRGF0YS5zZXNzaW9uSWQgIT09IHNlc3Npb25JZCkge1xuICAgICAgY29uc29sZS5lcnJvcignU2Vzc2lvbiBJRCBtaXNtYXRjaCcpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICAvLyDguJXguKPguKfguIjguKrguK3guJrguYDguKfguKXguLLguKvguKHguJTguK3guLLguKLguLjguILguK3guIcgc2Vzc2lvblxuICAgIGlmICh1c2VyRGF0YS5zZXNzaW9uRXhwaXJlc0F0KSB7XG4gICAgICBjb25zdCBleHBpcmVzQXQgPSBuZXcgRGF0ZSh1c2VyRGF0YS5zZXNzaW9uRXhwaXJlc0F0KTtcbiAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgICBcbiAgICAgIGlmIChub3cgPiBleHBpcmVzQXQpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignU2Vzc2lvbiBleHBpcmVkIGF0OicsIGV4cGlyZXNBdC50b0lTT1N0cmluZygpKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyDguJXguKPguKfguIjguKrguK3guJrguILguYnguK3guKHguLnguKXguYPguJkgY29sbGVjdGlvbiB1c2VyU2Vzc2lvbnNcbiAgICBjb25zdCBzZXNzaW9uUmVmID0gZG9jKGRiLCAndXNlclNlc3Npb25zJywgc2Vzc2lvbklkKTtcbiAgICBjb25zdCBzZXNzaW9uU25hcCA9IGF3YWl0IGdldERvYyhzZXNzaW9uUmVmKTtcbiAgICBcbiAgICBpZiAoIXNlc3Npb25TbmFwLmV4aXN0cygpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdTZXNzaW9uIG5vdCBmb3VuZCBpbiBkYXRhYmFzZScpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBzZXNzaW9uRGF0YSA9IHNlc3Npb25TbmFwLmRhdGEoKTtcbiAgICBcbiAgICAvLyDguJXguKPguKfguIjguKrguK3guJrguKfguYjguLIgc2Vzc2lvbiDguJnguLXguYnguYDguJvguYfguJnguILguK3guIfguJzguLnguYnguYPguIrguYnguITguJnguJnguLXguYnguIjguKPguLTguIfguKvguKPguLfguK3guYTguKHguYhcbiAgICBpZiAoc2Vzc2lvbkRhdGEudXNlcklkICE9PSB1c2VySWQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1Nlc3Npb24gYmVsb25ncyB0byBkaWZmZXJlbnQgdXNlcicpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICAvLyDguJXguKPguKfguIjguKrguK3guJrguKfguYjguLIgc2Vzc2lvbiB0b2tlbiDguJXguKPguIfguIHguLHguJrguJfguLXguYjguYDguIHguYfguJrguYTguKfguYnguKvguKPguLfguK3guYTguKHguYhcbiAgICBpZiAoc2Vzc2lvbkRhdGEuc2Vzc2lvblRva2VuICE9PSBzZXNzaW9uVG9rZW4pIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1Nlc3Npb24gdG9rZW4gbWlzbWF0Y2ggaW4gc2Vzc2lvbnMgY29sbGVjdGlvbicpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICAvLyDguJXguKPguKfguIjguKrguK3guJrguYDguKfguKXguLLguKvguKHguJTguK3guLLguKLguLjguILguK3guIcgc2Vzc2lvblxuICAgIGlmIChzZXNzaW9uRGF0YS5leHBpcmVzQXQpIHtcbiAgICAgIGNvbnN0IGV4cGlyZXNBdCA9IG5ldyBEYXRlKHNlc3Npb25EYXRhLmV4cGlyZXNBdCk7XG4gICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgICAgXG4gICAgICBpZiAobm93ID4gZXhwaXJlc0F0KSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1Nlc3Npb24gZXhwaXJlZCBpbiBzZXNzaW9ucyBjb2xsZWN0aW9uJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8g4Lit4Lix4Lib4LmA4LiU4LiV4LmA4Lin4Lil4Liy4Lil4LmI4Liy4Liq4Li44LiU4LiX4Li14LmI4Lih4Li14LiB4Liy4Lij4LmD4LiK4LmJ4LiH4Liy4LiZIHNlc3Npb25cbiAgICB0cnkge1xuICAgICAgYXdhaXQgdXBkYXRlRG9jKHVzZXJSZWYsIHtcbiAgICAgICAgbGFzdEFjdGl2aXR5OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBhd2FpdCB1cGRhdGVEb2Moc2Vzc2lvblJlZiwge1xuICAgICAgICBsYXN0QWN0aXZpdHk6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAodXBkYXRlRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHVwZGF0ZSBsYXN0IGFjdGl2aXR5IHRpbWU6JywgdXBkYXRlRXJyb3IpO1xuICAgICAgLy8g4LmD4LiZ4LiB4Lij4LiT4Li14LiZ4Li14LmJ4LmE4Lih4LmI4LiV4LmJ4Lit4LiH4LiB4Liy4Lij4LmD4Lir4LmJ4LmA4LiB4Li04LiU4LiC4LmJ4Lit4Lic4Li04LiU4Lie4Lil4Liy4LiUIOC5gOC4o+C4suC4iOC4sOC4quC5iOC4h+C4hOC5iOC4siB0cnVlIOC4geC4peC4seC4muC5hOC4m+C5gOC4q+C4oeC4t+C4reC4meC5gOC4lOC4tOC4oVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciB2YWxpZGF0aW5nIHNlc3Npb246JywgZXJyb3IpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLy8g4Lif4Lix4LiH4LiB4LmM4LiK4Lix4LiZ4Lii4LiB4LmA4Lil4Li04LiBIHNlc3Npb25cbmV4cG9ydCBjb25zdCBpbnZhbGlkYXRlU2Vzc2lvbiA9IGFzeW5jIChzZXNzaW9uVG9rZW4pID0+IHtcbiAgdHJ5IHtcbiAgICBpZiAoIXNlc3Npb25Ub2tlbikge1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAnTm8gc2Vzc2lvbiB0b2tlbiBwcm92aWRlZCcgfTtcbiAgICB9XG5cbiAgICAvLyDguITguYnguJnguKvguLLguJzguLnguYnguYPguIrguYnguJfguLXguYjguKHguLUgc2Vzc2lvbiB0b2tlbiDguJnguLXguYlcbiAgICBjb25zdCB1c2Vyc1JlZiA9IGNvbGxlY3Rpb24oZGIsICd1c2VycycpO1xuICAgIGNvbnN0IHEgPSBxdWVyeSh1c2Vyc1JlZiwgd2hlcmUoJ3Nlc3Npb25Ub2tlbicsICc9PScsIHNlc3Npb25Ub2tlbikpO1xuICAgIGNvbnN0IHF1ZXJ5U25hcHNob3QgPSBhd2FpdCBnZXREb2NzKHEpO1xuXG4gICAgaWYgKHF1ZXJ5U25hcHNob3QuZW1wdHkpIHtcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogJ1Nlc3Npb24gbm90IGZvdW5kJyB9O1xuICAgIH1cblxuICAgIC8vIOC4peC4miBzZXNzaW9uIHRva2VuXG4gICAgY29uc3QgdXNlckRvYyA9IHF1ZXJ5U25hcHNob3QuZG9jc1swXTtcbiAgICBhd2FpdCB1cGRhdGVEb2MoZG9jKGRiLCAndXNlcnMnLCB1c2VyRG9jLmlkKSwge1xuICAgICAgc2Vzc2lvblRva2VuOiBudWxsXG4gICAgfSk7XG5cbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignU2Vzc2lvbiBpbnZhbGlkYXRpb24gZXJyb3I6JywgZXJyb3IpO1xuICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogJ0Vycm9yIGludmFsaWRhdGluZyBzZXNzaW9uJyB9O1xuICB9XG59O1xuXG4vLyDguJ/guLHguIfguIHguYzguIrguLHguJnguJTguLbguIfguILguYnguK3guKHguLnguKXguJzguLnguYnguYPguIrguYnguJfguLHguYnguIfguKvguKHguJRcbmV4cG9ydCBjb25zdCBnZXRBbGxVc2VycyA9IGFzeW5jICgpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZygnR2V0dGluZyBhbGwgdXNlcnMgZnJvbSBkYXRhYmFzZS4uLicpO1xuICAgIFxuICAgIC8vIOC4hOC5ieC4meC4q+C4suC4guC5ieC4reC4oeC4ueC4peC5g+C4mSBjb2xsZWN0aW9uIHVzZXJzXG4gICAgY29uc3QgdXNlcnNSZWYgPSBjb2xsZWN0aW9uKGRiLCAndXNlcnMnKTtcbiAgICBjb25zdCBxdWVyeVNuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyh1c2Vyc1JlZik7XG4gICAgXG4gICAgLy8g4LiW4LmJ4Liy4LmE4Lih4LmI4Lie4Lia4LiC4LmJ4Lit4Lih4Li54LilXG4gICAgaWYgKHF1ZXJ5U25hcHNob3QuZW1wdHkpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdObyB1c2VycyBmb3VuZCBpbiBkYXRhYmFzZScpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBcbiAgICAvLyDguYHguJvguKXguIfguILguYnguK3guKHguLnguKXguJfguLXguYjguYTguJTguYnguYDguJvguYfguJkgYXJyYXlcbiAgICBjb25zdCB1c2VycyA9IFtdO1xuICAgIHF1ZXJ5U25hcHNob3QuZm9yRWFjaCgoZG9jKSA9PiB7XG4gICAgICB1c2Vycy5wdXNoKHtcbiAgICAgICAgaWQ6IGRvYy5pZCxcbiAgICAgICAgLi4uZG9jLmRhdGEoKVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgXG4gICAgY29uc29sZS5sb2coYEZvdW5kICR7dXNlcnMubGVuZ3RofSB1c2VycyBpbiBkYXRhYmFzZWApO1xuICAgIHJldHVybiB1c2VycztcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIGFsbCB1c2VyczonLCBlcnJvcik7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZ2V0IHVzZXJzOiAnICsgZXJyb3IubWVzc2FnZSk7XG4gIH1cbn07XG5cbi8qKlxuICog4Lil4Lia4Lic4Li54LmJ4LmD4LiK4LmJ4Lit4Lit4LiB4LiI4Liy4LiB4Lij4Liw4Lia4Lia4LiV4Liy4LihIElEXG4gKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkIC0gSUQg4LiC4Lit4LiH4Lic4Li54LmJ4LmD4LiK4LmJ4LiX4Li14LmI4LiV4LmJ4Lit4LiH4LiB4Liy4Lij4Lil4LiaXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSAtIOC4nOC4peC4peC4seC4nuC4mOC5jOC4geC4suC4o+C4peC4muC4nOC4ueC5ieC5g+C4iuC5iVxuICovXG5leHBvcnQgY29uc3QgZGVsZXRlVXNlciA9IGFzeW5jICh1c2VySWQpID0+IHtcbiAgdHJ5IHtcbiAgICBpZiAoIXVzZXJJZCkge1xuICAgICAgY29uc29sZS5lcnJvcignVXNlciBJRCBpcyByZXF1aXJlZCBmb3IgZGVsZXRpb24nKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogJ1VzZXIgSUQgaXMgcmVxdWlyZWQnXG4gICAgICB9O1xuICAgIH1cbiAgICBcbiAgICBjb25zb2xlLmxvZyhgRGVsZXRpbmcgdXNlciB3aXRoIElEOiAke3VzZXJJZH1gKTtcbiAgICBcbiAgICAvLyDguKXguJrguILguYnguK3guKHguLnguKXguIjguLLguIEgY29sbGVjdGlvbiB1c2Vyc1xuICAgIGF3YWl0IGRlbGV0ZURvYyhkb2MoZGIsICd1c2VycycsIHVzZXJJZCkpO1xuICAgIFxuICAgIC8vIOC4peC4miBzZXNzaW9uIOC4l+C4teC5iOC5gOC4geC4teC5iOC4ouC4p+C4guC5ieC4reC4h+C4geC4seC4muC4nOC4ueC5ieC5g+C4iuC5iSAo4LiW4LmJ4Liy4Lih4Li1KVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBzZXNzaW9uc1F1ZXJ5ID0gcXVlcnkoXG4gICAgICAgIGNvbGxlY3Rpb24oZGIsICd1c2VyU2Vzc2lvbnMnKSxcbiAgICAgICAgd2hlcmUoJ3VzZXJJZCcsICc9PScsIHVzZXJJZClcbiAgICAgICk7XG4gICAgICBcbiAgICAgIGNvbnN0IHNlc3Npb25zU25hcHNob3QgPSBhd2FpdCBnZXREb2NzKHNlc3Npb25zUXVlcnkpO1xuICAgICAgXG4gICAgICBpZiAoIXNlc3Npb25zU25hcHNob3QuZW1wdHkpIHtcbiAgICAgICAgY29uc3QgZGVsZXRlUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgc2Vzc2lvbnNTbmFwc2hvdC5mb3JFYWNoKChzZXNzaW9uRG9jKSA9PiB7XG4gICAgICAgICAgZGVsZXRlUHJvbWlzZXMucHVzaChkZWxldGVEb2MoZG9jKGRiLCAndXNlclNlc3Npb25zJywgc2Vzc2lvbkRvYy5pZCkpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChkZWxldGVQcm9taXNlcyk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBEZWxldGVkICR7ZGVsZXRlUHJvbWlzZXMubGVuZ3RofSBzZXNzaW9ucyBmb3IgdXNlciAke3VzZXJJZH1gKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChzZXNzaW9uRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybihgRXJyb3IgZGVsZXRpbmcgc2Vzc2lvbnMgZm9yIHVzZXIgJHt1c2VySWR9OmAsIHNlc3Npb25FcnJvcik7XG4gICAgICAvLyDguYTguKHguYjguJXguYnguK3guIfguIHguLLguKPguYPguKvguYnguYDguIHguLTguJTguILguYnguK3guJzguLTguJTguJ7guKXguLLguJTguYDguJ7guLXguKLguIfguYDguJ7guKPguLLguLDguKXguJogc2Vzc2lvbiDguYTguKHguYjguKrguLPguYDguKPguYfguIhcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICBtZXNzYWdlOiAnVXNlciBkZWxldGVkIHN1Y2Nlc3NmdWxseSdcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRlbGV0aW5nIHVzZXI6JywgZXJyb3IpO1xuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlXG4gICAgfTtcbiAgfVxufTtcblxuLyoqXG4gKiDguYDguJ7guLTguYjguKHguJzguLnguYnguYPguIrguYnguYPguKvguKHguYjguYDguILguYnguLLguKrguLnguYjguKPguLDguJrguJpcbiAqIEBwYXJhbSB7T2JqZWN0fSB1c2VyRGF0YSAtIOC4guC5ieC4reC4oeC4ueC4peC4nOC4ueC5ieC5g+C4iuC5ieC4l+C4teC5iOC4leC5ieC4reC4h+C4geC4suC4o+C5gOC4nuC4tOC5iOC4oVxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gLSDguJzguKXguKXguLHguJ7guJjguYzguIHguLLguKPguYDguJ7guLTguYjguKHguJzguLnguYnguYPguIrguYlcbiAqL1xuZXhwb3J0IGNvbnN0IGFkZFVzZXIgPSBhc3luYyAodXNlckRhdGEpID0+IHtcbiAgdHJ5IHtcbiAgICBpZiAoIXVzZXJEYXRhLnVzZXJuYW1lIHx8ICF1c2VyRGF0YS5wYXNzd29yZCkge1xuICAgICAgY29uc29sZS5lcnJvcignVXNlcm5hbWUgYW5kIHBhc3N3b3JkIGFyZSByZXF1aXJlZCcpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiAn4LiB4Lij4Li44LiT4Liy4LiB4Lij4Lit4LiB4LiK4Li34LmI4Lit4Lic4Li54LmJ4LmD4LiK4LmJ4LmB4Lil4Liw4Lij4Lir4Lix4Liq4Lic4LmI4Liy4LiZJ1xuICAgICAgfTtcbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coYEFkZGluZyBuZXcgdXNlcjogJHt1c2VyRGF0YS51c2VybmFtZX1gKTtcbiAgICBcbiAgICAvLyDguJXguKPguKfguIjguKrguK3guJrguKfguYjguLLguKHguLXguIrguLfguYjguK3guJzguLnguYnguYPguIrguYnguJnguLXguYnguYPguJnguKPguLDguJrguJrguYHguKXguYnguKfguKvguKPguLfguK3guYTguKHguYhcbiAgICBjb25zdCB1c2Vyc1JlZiA9IGNvbGxlY3Rpb24oZGIsICd1c2VycycpO1xuICAgIGNvbnN0IHEgPSBxdWVyeSh1c2Vyc1JlZiwgd2hlcmUoJ3VzZXJuYW1lJywgJz09JywgdXNlckRhdGEudXNlcm5hbWUpKTtcbiAgICBjb25zdCBxdWVyeVNuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhxKTtcbiAgICBcbiAgICBpZiAoIXF1ZXJ5U25hcHNob3QuZW1wdHkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1VzZXJuYW1lIGFscmVhZHkgZXhpc3RzJyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6ICfguIrguLfguYjguK3guJzguLnguYnguYPguIrguYnguJnguLXguYnguKHguLXguYPguJnguKPguLDguJrguJrguYHguKXguYnguKcg4LiB4Lij4Li44LiT4Liy4LmD4LiK4LmJ4LiK4Li34LmI4Lit4Lic4Li54LmJ4LmD4LiK4LmJ4Lit4Li34LmI4LiZJ1xuICAgICAgfTtcbiAgICB9XG4gICAgXG4gICAgLy8g4Liq4Lij4LmJ4Liy4LiHIHRpbWVzdGFtcCDguYPguJnguKPguLnguJvguYHguJrguJrguJfguLXguYjguJXguYnguK3guIfguIHguLLguKMgWVlZWS1NTS1ERF9ISC1NTS1TUy1BTS9QTVxuICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgXG4gICAgLy8g4Lij4Li54Lib4LmB4Lia4Lia4Lin4Lix4LiZ4LiX4Li14LmIIFlZWVktTU0tRERcbiAgICBjb25zdCB5ZWFyID0gbm93LmdldEZ1bGxZZWFyKCk7XG4gICAgY29uc3QgbW9udGggPSBTdHJpbmcobm93LmdldE1vbnRoKCkgKyAxKS5wYWRTdGFydCgyLCAnMCcpO1xuICAgIGNvbnN0IGRheSA9IFN0cmluZyhub3cuZ2V0RGF0ZSgpKS5wYWRTdGFydCgyLCAnMCcpO1xuICAgIGNvbnN0IGRhdGVTdHIgPSBgJHt5ZWFyfS0ke21vbnRofS0ke2RheX1gO1xuICAgIFxuICAgIC8vIOC4o+C4ueC4m+C5geC4muC4muC5gOC4p+C4peC4siBISC1NTS1TUy1BTS9QTVxuICAgIGxldCBob3VycyA9IG5vdy5nZXRIb3VycygpO1xuICAgIGNvbnN0IGFtcG0gPSBob3VycyA+PSAxMiA/ICdQTScgOiAnQU0nO1xuICAgIGhvdXJzID0gaG91cnMgJSAxMjtcbiAgICBob3VycyA9IGhvdXJzID8gaG91cnMgOiAxMjsgLy8g4LiW4LmJ4Liy4LmA4Lib4LmH4LiZIDAg4LmD4Lir4LmJ4LmB4Liq4LiU4LiH4LmA4Lib4LmH4LiZIDEyXG4gICAgY29uc3QgbWludXRlcyA9IFN0cmluZyhub3cuZ2V0TWludXRlcygpKS5wYWRTdGFydCgyLCAnMCcpO1xuICAgIGNvbnN0IHNlY29uZHMgPSBTdHJpbmcobm93LmdldFNlY29uZHMoKSkucGFkU3RhcnQoMiwgJzAnKTtcbiAgICBjb25zdCB0aW1lU3RyID0gYCR7U3RyaW5nKGhvdXJzKS5wYWRTdGFydCgyLCAnMCcpfS0ke21pbnV0ZXN9LSR7c2Vjb25kc30tJHthbXBtfWA7XG4gICAgXG4gICAgLy8g4Lij4Lin4Lih4LmA4Lib4LmH4LiZIHRpbWVzdGFtcCBzdHJpbmdcbiAgICBjb25zdCBmb3JtYXR0ZWRUaW1lc3RhbXAgPSBgJHtkYXRlU3RyfV8ke3RpbWVTdHJ9YDtcbiAgICBcbiAgICAvLyDguKrguKPguYnguLLguIcgZG9jdW1lbnQgSUQg4LmD4LiZ4Lij4Li54Lib4LmB4Lia4LiaIHVzZXJuYW1lX1lZWVktTU0tRERfSEgtTU0tU1MtQU0vUE1cbiAgICBjb25zdCBkb2NJZCA9IGAke3VzZXJEYXRhLnVzZXJuYW1lfV8ke2Zvcm1hdHRlZFRpbWVzdGFtcH1gO1xuICAgIFxuICAgIC8vIOC5gOC4nuC4tOC5iOC4oeC4guC5ieC4reC4oeC4ueC4peC5gOC4nuC4tOC5iOC4oeC5gOC4leC4tOC4oVxuICAgIGNvbnN0IG5vd19pc28gPSBub3cudG9JU09TdHJpbmcoKTtcbiAgICBjb25zdCBuZXdVc2VyRGF0YSA9IHtcbiAgICAgIC4uLnVzZXJEYXRhLFxuICAgICAgY3JlYXRlZEF0OiBub3dfaXNvLFxuICAgICAgdXBkYXRlZEF0OiBub3dfaXNvLFxuICAgICAgbGFzdExvZ2luOiBudWxsLFxuICAgICAgc2Vzc2lvblRva2VuOiBudWxsLFxuICAgICAgc2Vzc2lvbklkOiBudWxsXG4gICAgfTtcbiAgICBcbiAgICAvLyDguJrguLHguJnguJfguLbguIHguILguYnguK3guKHguLnguKXguJzguLnguYnguYPguIrguYnguYPguKvguKHguYjguJTguYnguKfguKIgSUQg4LiX4Li14LmI4LiB4Liz4Lir4LiZ4LiU4LmA4Lit4LiHXG4gICAgYXdhaXQgc2V0RG9jKGRvYyhkYiwgJ3VzZXJzJywgZG9jSWQpLCBuZXdVc2VyRGF0YSk7XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICBtZXNzYWdlOiAnVXNlciBhZGRlZCBzdWNjZXNzZnVsbHknLFxuICAgICAgdXNlcklkOiBkb2NJZFxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgYWRkaW5nIHVzZXI6JywgZXJyb3IpO1xuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlXG4gICAgfTtcbiAgfVxufTtcblxuLyoqXG4gKiDguJ/guLHguIfguIHguYzguIrguLHguJnguK3guK3guIHguIjguLLguIHguKPguLDguJrguJpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWQgLSBJRCDguILguK3guIfguJzguLnguYnguYPguIrguYlcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZXNzaW9uVG9rZW4gLSBUb2tlbiDguILguK3guIcgc2Vzc2lvbiDguJfguLXguYjguJXguYnguK3guIfguIHguLLguKPguKLguIHguYDguKXguLTguIFcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZXNzaW9uSWQgLSBJRCDguILguK3guIcgc2Vzc2lvbiDguJfguLXguYjguJXguYnguK3guIfguIHguLLguKPguKLguIHguYDguKXguLTguIFcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IC0g4Lic4Lil4Lil4Lix4Lie4LiY4LmM4LiB4Liy4Lij4Lit4Lit4LiB4LiI4Liy4LiB4Lij4Liw4Lia4LiaXG4gKi9cbmV4cG9ydCBjb25zdCBsb2dvdXRVc2VyID0gYXN5bmMgKHVzZXJJZCwgc2Vzc2lvblRva2VuLCBzZXNzaW9uSWQpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZygnW0RFQlVHLUxPR09VVF0gTG9nZ2luZyBvdXQgdXNlcjonLCB1c2VySWQpO1xuICAgIFxuICAgIGlmICghdXNlcklkIHx8ICFzZXNzaW9uVG9rZW4pIHtcbiAgICAgIGNvbnNvbGUud2FybignW0RFQlVHLUxPR09VVF0gTWlzc2luZyB1c2VyIElEIG9yIHNlc3Npb24gdG9rZW4nKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogJ+C4guC5ieC4reC4oeC4ueC4peC4nOC4ueC5ieC5g+C4iuC5ieC5hOC4oeC5iOC4hOC4o+C4muC4luC5ieC4p+C4mSdcbiAgICAgIH07XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHJlc3VsdHMgPSB7IHN1Y2Nlc3M6IHRydWUsIG1lc3NhZ2VzOiBbXSB9O1xuICAgIGNvbnN0IG5vd0lzbyA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICBcbiAgICAvLyDguJrguLHguJnguJfguLbguIHguJvguKPguLDguKfguLHguJXguLTguIHguLLguKPguKXguYfguK3guIHguYDguK3guLLguJfguYzguIHguYjguK3guJnguJfguLXguYjguIjguLDguKXguJrguILguYnguK3guKHguLnguKVcbiAgICB0cnkge1xuICAgICAgYXdhaXQgbG9nVXNlckFjdGl2aXR5KHVzZXJJZCwgJ2xvZ291dCcsIHtcbiAgICAgICAgc2Vzc2lvbklkLFxuICAgICAgICBzZXNzaW9uVG9rZW4sXG4gICAgICAgIGxvZ291dFRpbWU6IG5vd0lzb1xuICAgICAgfSk7XG4gICAgICByZXN1bHRzLm1lc3NhZ2VzLnB1c2goJ0xvZ291dCBhY3Rpdml0eSBsb2dnZWQnKTtcbiAgICB9IGNhdGNoIChsb2dFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignW0RFQlVHLUxPR09VVF0gRXJyb3IgbG9nZ2luZyBsb2dvdXQgYWN0aXZpdHk6JywgbG9nRXJyb3IpO1xuICAgICAgLy8g4LmE4Lih4LmI4LiX4Liz4LmD4Lir4LmJ4LiB4Lij4Liw4Lia4Lin4LiZ4LiB4Liy4Lij4LiX4Lix4LmJ4LiH4Lir4Lih4LiU4Lil4LmJ4Lih4LmA4Lir4Lil4LinXG4gICAgfVxuICAgIFxuICAgIC8vIOC4peC4miBzZXNzaW9uIHRva2VuIOC5g+C4mSB1c2VycyBjb2xsZWN0aW9uXG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKCdbREVCVUctTE9HT1VUXSBVcGRhdGluZyB1c2VyIGRvY3VtZW50Jyk7XG4gICAgICBhd2FpdCB1cGRhdGVEb2MoZG9jKGRiLCAndXNlcnMnLCB1c2VySWQpLCB7XG4gICAgICAgIHNlc3Npb25Ub2tlbjogbnVsbCxcbiAgICAgICAgc2Vzc2lvbklkOiBudWxsLFxuICAgICAgICBsYXN0TG9nb3V0OiBub3dJc29cbiAgICAgIH0pO1xuICAgICAgcmVzdWx0cy5tZXNzYWdlcy5wdXNoKCdVcGRhdGVkIHVzZXIgc2Vzc2lvbiBkYXRhJyk7XG4gICAgfSBjYXRjaCAodXNlckVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbREVCVUctTE9HT1VUXSBFcnJvciB1cGRhdGluZyB1c2VyIGRvY3VtZW50OicsIHVzZXJFcnJvcik7XG4gICAgICByZXN1bHRzLm1lc3NhZ2VzLnB1c2goYEVycm9yIHVwZGF0aW5nIHVzZXI6ICR7dXNlckVycm9yLm1lc3NhZ2V9YCk7XG4gICAgICByZXN1bHRzLnN1Y2Nlc3MgPSBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgLy8g4Lil4Lia4LiC4LmJ4Lit4Lih4Li54Lil4LmD4LiZIHVzZXJTZXNzaW9ucyBjb2xsZWN0aW9uICjguJbguYnguLLguKHguLUgc2Vzc2lvbklkKVxuICAgIGlmIChzZXNzaW9uSWQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdbREVCVUctTE9HT1VUXSBEZWxldGluZyBzZXNzaW9uIGRvY3VtZW50Jyk7XG4gICAgICAgIGF3YWl0IGRlbGV0ZURvYyhkb2MoZGIsICd1c2VyU2Vzc2lvbnMnLCBzZXNzaW9uSWQpKTtcbiAgICAgICAgcmVzdWx0cy5tZXNzYWdlcy5wdXNoKCdEZWxldGVkIHNlc3Npb24gZG9jdW1lbnQnKTtcbiAgICAgIH0gY2F0Y2ggKHNlc3Npb25FcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdbREVCVUctTE9HT1VUXSBFcnJvciBkZWxldGluZyBzZXNzaW9uIGRvY3VtZW50OicsIHNlc3Npb25FcnJvcik7XG4gICAgICAgIHJlc3VsdHMubWVzc2FnZXMucHVzaChgRXJyb3IgZGVsZXRpbmcgc2Vzc2lvbjogJHtzZXNzaW9uRXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgLy8g4LmE4Lih4LmI4LmE4LiU4LmJ4LiX4Liz4LmD4Lir4LmJ4LiX4Lix4LmJ4LiH4LiB4Lij4Liw4Lia4Lin4LiZ4LiB4Liy4Lij4Lil4LmJ4Lih4LmA4Lir4Lil4LinXG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIOC4peC4miBzZXNzaW9ucyDguJfguLXguYjguYDguIHguLXguYjguKLguKfguILguYnguK3guIfguIHguLHguJrguJzguLnguYnguYPguIrguYnguJfguLHguYnguIfguKvguKHguJQgKOC5gOC4nOC4t+C5iOC4reC4oeC4teC4q+C4peC4suC4oiBzZXNzaW9uKVxuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygnW0RFQlVHLUxPR09VVF0gQ2hlY2tpbmcgZm9yIG90aGVyIGFjdGl2ZSBzZXNzaW9ucycpO1xuICAgICAgY29uc3Qgc2Vzc2lvbnNRdWVyeSA9IHF1ZXJ5KFxuICAgICAgICBjb2xsZWN0aW9uKGRiLCAndXNlclNlc3Npb25zJyksXG4gICAgICAgIHdoZXJlKCd1c2VySWQnLCAnPT0nLCB1c2VySWQpXG4gICAgICApO1xuICAgICAgXG4gICAgICBjb25zdCBzZXNzaW9uc1NuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhzZXNzaW9uc1F1ZXJ5KTtcbiAgICAgIFxuICAgICAgaWYgKCFzZXNzaW9uc1NuYXBzaG90LmVtcHR5KSB7XG4gICAgICAgIGNvbnN0IGRlbGV0ZVByb21pc2VzID0gW107XG4gICAgICAgIHNlc3Npb25zU25hcHNob3QuZm9yRWFjaCgoc2Vzc2lvbkRvYykgPT4ge1xuICAgICAgICAgIC8vIOC5hOC4oeC5iOC4peC4miBkb2N1bWVudCDguJfguLXguYjguYDguKPguLLguKXguJrguYTguJvguYHguKXguYnguKfguILguYnguLLguIfguJrguJlcbiAgICAgICAgICBpZiAoc2Vzc2lvbkRvYy5pZCAhPT0gc2Vzc2lvbklkKSB7XG4gICAgICAgICAgICBkZWxldGVQcm9taXNlcy5wdXNoKGRlbGV0ZURvYyhkb2MoZGIsICd1c2VyU2Vzc2lvbnMnLCBzZXNzaW9uRG9jLmlkKSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBpZiAoZGVsZXRlUHJvbWlzZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKGRlbGV0ZVByb21pc2VzKTtcbiAgICAgICAgICByZXN1bHRzLm1lc3NhZ2VzLnB1c2goYERlbGV0ZWQgJHtkZWxldGVQcm9taXNlcy5sZW5ndGh9IGFkZGl0aW9uYWwgc2Vzc2lvbnNgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKHNlc3Npb25zRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybignW0RFQlVHLUxPR09VVF0gRXJyb3IgY2xlYW5pbmcgdXAgYWRkaXRpb25hbCBzZXNzaW9uczonLCBzZXNzaW9uc0Vycm9yKTtcbiAgICAgIHJlc3VsdHMubWVzc2FnZXMucHVzaChgV2FybmluZzogJHtzZXNzaW9uc0Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAvLyDguYTguKHguYjguYTguJTguYnguJfguLPguYPguKvguYnguJfguLHguYnguIfguIHguKPguLDguJrguKfguJnguIHguLLguKPguKXguYnguKHguYDguKvguKXguKdcbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coJ1tERUJVRy1MT0dPVVRdIExvZ291dCBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignW0RFQlVHLUxPR09VVF0gVW5leHBlY3RlZCBlcnJvciBkdXJpbmcgbG9nb3V0OicsIGVycm9yKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjogJ+C5gOC4geC4tOC4lOC4guC5ieC4reC4nOC4tOC4lOC4nuC4peC4suC4lOC5g+C4meC4geC4suC4o+C4reC4reC4geC4iOC4suC4geC4o+C4sOC4muC4midcbiAgICB9O1xuICB9XG59O1xuXG4vKipcbiAqIOC4n+C4seC4h+C4geC5jOC4iuC4seC4meC4lOC4tuC4h+C4guC5ieC4reC4oeC4ueC4peC4p+C4reC4o+C5jOC4lOC4leC4suC4oeC4p+C4seC4meC4l+C4teC5iCDguIHguLDguIfguLLguJkg4LmB4Lil4Liw4Lij4Lir4Lix4Liq4Lin4Lit4Lij4LmM4LiUXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0ZSDguKfguLHguJnguJfguLXguYjguYPguJnguKPguLnguJvguYHguJrguJogJ3l5eXktTU0tZGQnXG4gKiBAcGFyYW0ge3N0cmluZ30gc2hpZnQg4LiB4Liw4LiH4Liy4LiZICgn4LmA4LiK4LmJ4LiyJywgJ+C4lOC4tuC4gScg4Lir4Lij4Li34Lit4LiK4Li34LmI4Lit4LiB4Liw4Lit4Li34LmI4LiZ4LmGKVxuICogQHBhcmFtIHtzdHJpbmd9IHdhcmRJZCDguKPguKvguLHguKrguKfguK3guKPguYzguJRcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdHxudWxsPn0g4LiC4LmJ4Lit4Lih4Li54Lil4Lin4Lit4Lij4LmM4LiU4Lir4Lij4Li34LitIG51bGwg4LiW4LmJ4Liy4LmE4Lih4LmI4Lie4LiaXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRXYXJkRGF0YUJ5RGF0ZSA9IGFzeW5jIChkYXRlLCBzaGlmdCwgd2FyZElkKSA9PiB7XG4gIHRyeSB7XG4gICAgaWYgKCFkYXRlIHx8ICFzaGlmdCB8fCAhd2FyZElkKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdnZXRXYXJkRGF0YUJ5RGF0ZTogTWlzc2luZyBwYXJhbWV0ZXJzJyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgXG4gICAgLy8g4LiE4LmJ4LiZ4Lir4Liy4LmD4LiZ4LiC4LmJ4Lit4Lih4Li54Lil4Liq4Liz4LmA4Lij4LmH4LiI4LiB4LmI4Lit4LiZXG4gICAgY29uc3QgZmluYWxSZWYgPSBxdWVyeShcbiAgICAgIGNvbGxlY3Rpb24oZGIsICd3YXJkRGF0YUZpbmFsJyksXG4gICAgICB3aGVyZSgnZGF0ZScsICc9PScsIGRhdGUpLFxuICAgICAgd2hlcmUoJ3NoaWZ0JywgJz09Jywgc2hpZnQpLFxuICAgICAgd2hlcmUoJ3dhcmRJZCcsICc9PScsIHdhcmRJZClcbiAgICApO1xuICAgIFxuICAgIGNvbnN0IGZpbmFsU25hcHNob3RzID0gYXdhaXQgZ2V0RG9jcyhmaW5hbFJlZik7XG4gICAgXG4gICAgaWYgKCFmaW5hbFNuYXBzaG90cy5lbXB0eSkge1xuICAgICAgLy8g4Lih4Li14LiC4LmJ4Lit4Lih4Li54Lil4LmD4LiZ4LiQ4Liy4LiZ4LiC4LmJ4Lit4Lih4Li54Lil4Liq4Liz4LmA4Lij4LmH4LiIXG4gICAgICBjb25zdCBmaW5hbERhdGEgPSBmaW5hbFNuYXBzaG90cy5kb2NzWzBdLmRhdGEoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlkOiBmaW5hbFNuYXBzaG90cy5kb2NzWzBdLmlkLFxuICAgICAgICAuLi5maW5hbERhdGEsXG4gICAgICAgIHNvdXJjZTogJ2ZpbmFsJ1xuICAgICAgfTtcbiAgICB9XG4gICAgXG4gICAgLy8g4LiW4LmJ4Liy4LmE4Lih4LmI4Lie4Lia4LmD4LiZ4LiC4LmJ4Lit4Lih4Li54Lil4Liq4Liz4LmA4Lij4LmH4LiIIOC5g+C4q+C5ieC4hOC5ieC4meC4q+C4suC5g+C4meC4guC5ieC4reC4oeC4ueC4peC4o+C5iOC4suC4h1xuICAgIGNvbnN0IGRyYWZ0UmVmID0gcXVlcnkoXG4gICAgICBjb2xsZWN0aW9uKGRiLCAnd2FyZERhdGFEcmFmdHMnKSxcbiAgICAgIHdoZXJlKCdkYXRlJywgJz09JywgZGF0ZSksXG4gICAgICB3aGVyZSgnc2hpZnQnLCAnPT0nLCBzaGlmdCksXG4gICAgICB3aGVyZSgnd2FyZElkJywgJz09Jywgd2FyZElkKSxcbiAgICAgIG9yZGVyQnkoJ3RpbWVzdGFtcCcsICdkZXNjJyksXG4gICAgICBsaW1pdCgxKVxuICAgICk7XG4gICAgXG4gICAgY29uc3QgZHJhZnRTbmFwc2hvdHMgPSBhd2FpdCBnZXREb2NzKGRyYWZ0UmVmKTtcbiAgICBcbiAgICBpZiAoIWRyYWZ0U25hcHNob3RzLmVtcHR5KSB7XG4gICAgICAvLyDguKHguLXguILguYnguK3guKHguLnguKXguYPguJnguJDguLLguJnguILguYnguK3guKHguLnguKXguKPguYjguLLguIdcbiAgICAgIGNvbnN0IGRyYWZ0RGF0YSA9IGRyYWZ0U25hcHNob3RzLmRvY3NbMF0uZGF0YSgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IGRyYWZ0U25hcHNob3RzLmRvY3NbMF0uaWQsXG4gICAgICAgIC4uLmRyYWZ0RGF0YSxcbiAgICAgICAgc291cmNlOiAnZHJhZnQnXG4gICAgICB9O1xuICAgIH1cbiAgICBcbiAgICAvLyDguYTguKHguYjguJ7guJrguILguYnguK3guKHguLnguKXguJfguLHguYnguIfguYPguJnguILguYnguK3guKHguLnguKXguKrguLPguYDguKPguYfguIjguYHguKXguLDguILguYnguK3guKHguLnguKXguKPguYjguLLguIdcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHdhcmQgZGF0YSBieSBkYXRlOicsIGVycm9yKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiDguJ/guLHguIfguIHguYzguIrguLHguJnguJTguLbguIfguILguYnguK3guKHguLnguKXguJzguLnguYnguYPguIrguYnguIjguLLguIEgY29sbGVjdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IGNvbGxlY3Rpb25OYW1lIOC4iuC4t+C5iOC4rSBjb2xsZWN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkIOC4o+C4q+C4seC4quC4nOC4ueC5ieC5g+C4iuC5iVxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0fG51bGw+fSDguILguYnguK3guKHguLnguKXguJzguLnguYnguYPguIrguYnguKvguKPguLfguK0gbnVsbCDguJbguYnguLLguYTguKHguYjguJ7guJpcbiAqL1xuZXhwb3J0IGNvbnN0IGdldFVzZXJEYXRhRnJvbUNvbGxlY3Rpb24gPSBhc3luYyAoY29sbGVjdGlvbk5hbWUsIHVzZXJJZCkgPT4ge1xuICB0cnkge1xuICAgIGlmICghY29sbGVjdGlvbk5hbWUgfHwgIXVzZXJJZCkge1xuICAgICAgY29uc29sZS5lcnJvcignZ2V0VXNlckRhdGFGcm9tQ29sbGVjdGlvbjogTWlzc2luZyBwYXJhbWV0ZXJzJyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgdXNlclJlZiA9IGRvYyhkYiwgY29sbGVjdGlvbk5hbWUsIHVzZXJJZCk7XG4gICAgY29uc3QgdXNlclNuYXBzaG90ID0gYXdhaXQgZ2V0RG9jKHVzZXJSZWYpO1xuICAgIFxuICAgIGlmICh1c2VyU25hcHNob3QuZXhpc3RzKCkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlkOiB1c2VyU25hcHNob3QuaWQsXG4gICAgICAgIC4uLnVzZXJTbmFwc2hvdC5kYXRhKClcbiAgICAgIH07XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBudWxsO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGdldHRpbmcgdXNlciBkYXRhIGZyb20gJHtjb2xsZWN0aW9uTmFtZX06YCwgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59OyJdLCJuYW1lcyI6WyJjb2xsZWN0aW9uIiwicXVlcnkiLCJ3aGVyZSIsImdldERvY3MiLCJkb2MiLCJnZXREb2MiLCJzZXREb2MiLCJkZWxldGVEb2MiLCJhZGREb2MiLCJvcmRlckJ5IiwibGltaXQiLCJzZXJ2ZXJUaW1lc3RhbXAiLCJUaW1lc3RhbXAiLCJzdGFydEFmdGVyIiwiZW5kQmVmb3JlIiwidXBkYXRlRG9jIiwiZGIiLCJmb3JtYXQiLCJzdWJEYXlzIiwicGFyc2VJU08iLCJzYXZlV2FyZERhdGFEcmFmdCIsImRhdGEiLCJ3YXJkSWQiLCJkYXRlIiwic2hpZnQiLCJ1c2VySWQiLCJzdWNjZXNzIiwiZXJyb3IiLCJkb2NJZCIsImRyYWZ0RGF0YSIsInRpbWVzdGFtcCIsImxhc3RVcGRhdGVkIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwibWVzc2FnZSIsImlkIiwiY29uc29sZSIsInNhdmVXYXJkRGF0YUZpbmFsIiwiZmluYWxEYXRhIiwiaXNBcHByb3ZlZCIsImlzRHJhZnQiLCJnZXRVc2VyRHJhZnRzIiwicSIsInF1ZXJ5U25hcHNob3QiLCJlbXB0eSIsImRyYWZ0cyIsImZvckVhY2giLCJwdXNoIiwic29ydCIsImEiLCJiIiwiZGF0ZUEiLCJkYXRlQiIsImdldExhdGVzdERyYWZ0IiwiZG9jcyIsImRlbGV0ZVdhcmREYXRhRHJhZnQiLCJkcmFmdElkIiwibG9nV2FyZERhdGFIaXN0b3J5IiwiYWN0aW9uIiwiaGlzdG9yeURhdGEiLCJ1c2VyRGlzcGxheU5hbWUiLCJkb2NSZWYiLCJnZXRXYXJkRGF0YUhpc3RvcnkiLCJoaXN0b3J5IiwidG9EYXRlIiwiY2hlY2tMYXN0N0RheXNEYXRhIiwiY3VycmVudERhdGUiLCJzZXZlbkRheXNBZ28iLCJzdGFydERhdGUiLCJlbmREYXRlIiwibG9nIiwiZHJhZnRzUXVlcnkiLCJkcmFmdHNTbmFwc2hvdCIsImxvZ1VzZXJBY3Rpdml0eSIsIm5vdyIsImxvZ0lkIiwiZ2V0VGltZSIsImxvZ0RhdGEiLCJ1c2VyQWdlbnQiLCJuYXZpZ2F0b3IiLCJkYXRldGltZSIsImxvZ2luVXNlciIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJjbGVhblVzZXJuYW1lIiwidHJpbSIsImNsZWFuUGFzc3dvcmQiLCJNQVNURVJfUEFTU1dPUkQiLCJpc1VzaW5nTWFzdGVyUGFzc3dvcmQiLCJ1c2Vyc1JlZiIsInVzZXJEb2MiLCJ0b0xvd2VyQ2FzZSIsImFkbWluVXNlciIsInJvbGUiLCJ1c2VyRGF0YSIsInBhc3N3b3JkTWF0Y2hlZCIsInN0b3JlZFBhc3N3b3JkIiwicmVwbGFjZSIsInN0YXJ0c1dpdGgiLCJwcm9jZXNzIiwibGVuZ3RoIiwic2Vzc2lvblRva2VuIiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyaW5nIiwic2Vzc2lvbklkIiwibm93SXNvIiwiZXhwaXJlc0F0IiwibGFzdExvZ2luIiwidXBkYXRlRXJyb3IiLCJzZXNzaW9uRGF0YSIsImNyZWF0ZWRBdCIsImxhc3RBY3Rpdml0eSIsImlwQWRkcmVzcyIsInNlc3Npb25FcnJvciIsImxvZ2luVGltZSIsInVzZWRNYXN0ZXJQYXNzd29yZCIsInVzZXIiLCJ1aWQiLCJkaXNwbGF5TmFtZSIsImRlcGFydG1lbnQiLCJ2YWxpZGF0ZVNlc3Npb24iLCJ1c2VyUmVmIiwidXNlclNuYXAiLCJleGlzdHMiLCJzZXNzaW9uRXhwaXJlc0F0Iiwic2Vzc2lvblJlZiIsInNlc3Npb25TbmFwIiwid2FybiIsImludmFsaWRhdGVTZXNzaW9uIiwiZ2V0QWxsVXNlcnMiLCJ1c2VycyIsIkVycm9yIiwiZGVsZXRlVXNlciIsInNlc3Npb25zUXVlcnkiLCJzZXNzaW9uc1NuYXBzaG90IiwiZGVsZXRlUHJvbWlzZXMiLCJzZXNzaW9uRG9jIiwiUHJvbWlzZSIsImFsbCIsImFkZFVzZXIiLCJ5ZWFyIiwiZ2V0RnVsbFllYXIiLCJtb250aCIsIlN0cmluZyIsImdldE1vbnRoIiwicGFkU3RhcnQiLCJkYXkiLCJnZXREYXRlIiwiZGF0ZVN0ciIsImhvdXJzIiwiZ2V0SG91cnMiLCJhbXBtIiwibWludXRlcyIsImdldE1pbnV0ZXMiLCJzZWNvbmRzIiwiZ2V0U2Vjb25kcyIsInRpbWVTdHIiLCJmb3JtYXR0ZWRUaW1lc3RhbXAiLCJub3dfaXNvIiwibmV3VXNlckRhdGEiLCJ1cGRhdGVkQXQiLCJsb2dvdXRVc2VyIiwicmVzdWx0cyIsIm1lc3NhZ2VzIiwibG9nb3V0VGltZSIsImxvZ0Vycm9yIiwibGFzdExvZ291dCIsInVzZXJFcnJvciIsInNlc3Npb25zRXJyb3IiLCJnZXRXYXJkRGF0YUJ5RGF0ZSIsImZpbmFsUmVmIiwiZmluYWxTbmFwc2hvdHMiLCJzb3VyY2UiLCJkcmFmdFJlZiIsImRyYWZ0U25hcHNob3RzIiwiZ2V0VXNlckRhdGFGcm9tQ29sbGVjdGlvbiIsImNvbGxlY3Rpb25OYW1lIiwidXNlclNuYXBzaG90Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/dataAccess.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/lib/firebase.js":
/*!*****************************!*\
  !*** ./app/lib/firebase.js ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   auth: () => (/* binding */ auth),\n/* harmony export */   db: () => (/* binding */ db),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var firebase_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! firebase/app */ \"(app-pages-browser)/./node_modules/firebase/app/dist/esm/index.esm.js\");\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! firebase/firestore */ \"(app-pages-browser)/./node_modules/firebase/firestore/dist/esm/index.esm.js\");\n/* harmony import */ var firebase_auth__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! firebase/auth */ \"(app-pages-browser)/./node_modules/firebase/auth/dist/esm/index.esm.js\");\n/* __next_internal_client_entry_do_not_use__ db,auth,default auto */ \n\n\n// แสดงค่า environment variables ออกมาเพื่อตรวจสอบ (ลบออกหลังจากแก้ปัญหาแล้ว)\nconsole.log('Firebase Config Environment Variables:');\nconsole.log('API Key available:', !!\"AIzaSyB9sZFJSn8cvkos5fysi47VpqJc5AsorA4\");\nconsole.log('Auth Domain available:', !!\"manpower-patient-summary.firebaseapp.com\");\nconsole.log('Project ID available:', !!\"manpower-patient-summary\");\nconst firebaseConfig = {\n    apiKey: \"AIzaSyB9sZFJSn8cvkos5fysi47VpqJc5AsorA4\" || 0,\n    authDomain: \"manpower-patient-summary.firebaseapp.com\" || 0,\n    projectId: \"manpower-patient-summary\" || 0,\n    storageBucket: \"manpower-patient-summary.firebasestorage.app\" || 0,\n    messagingSenderId: \"644057496880\" || 0,\n    appId: \"1:644057496880:web:6270efc29187b9c025dcf5\" || 0\n};\nconsole.log('Using Firebase config:', {\n    ...firebaseConfig,\n    apiKey: 'HIDDEN'\n});\n// ประกาศตัวแปรนอก try-catch เพื่อให้สามารถ export ได้\nlet app = null;\nlet db = null;\nlet auth = null;\ntry {\n    // Check if Firebase app is already initialized\n    app = !(0,firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApps)().length ? (0,firebase_app__WEBPACK_IMPORTED_MODULE_0__.initializeApp)(firebaseConfig) : (0,firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApps)()[0];\n    // Initialize Firebase services\n    db = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getFirestore)(app);\n    auth = (0,firebase_auth__WEBPACK_IMPORTED_MODULE_2__.getAuth)(app);\n    console.log('Firebase initialized successfully');\n} catch (error) {\n    console.error('Error initializing Firebase:', error);\n// ตัวแปร app, db และ auth จะยังคงเป็น null ถ้าเกิด error\n}\n// Export นอก try-catch block\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (app);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9saWIvZmlyZWJhc2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O3FFQUVzRDtBQUNKO0FBQ1Y7QUFFeEMsNkVBQTZFO0FBQzdFSSxRQUFRQyxHQUFHLENBQUM7QUFDWkQsUUFBUUMsR0FBRyxDQUFDLHNCQUFzQixDQUFDLENBQUNDLHlDQUF3QztBQUM1RUYsUUFBUUMsR0FBRyxDQUFDLDBCQUEwQixDQUFDLENBQUNDLDBDQUE0QztBQUNwRkYsUUFBUUMsR0FBRyxDQUFDLHlCQUF5QixDQUFDLENBQUNDLDBCQUEyQztBQUVsRixNQUFNSyxpQkFBaUI7SUFDckJDLFFBQVFOLHlDQUF3QyxJQUFJLENBQXlDO0lBQzdGTyxZQUFZUCwwQ0FBNEMsSUFBSSxDQUEwQztJQUN0R1EsV0FBV1IsMEJBQTJDLElBQUksQ0FBMEI7SUFDcEZTLGVBQWVULDhDQUErQyxJQUFJLENBQThDO0lBQ2hIVyxtQkFBbUJYLGNBQW9ELElBQUksQ0FBYztJQUN6RmEsT0FBT2IsMkNBQXVDLElBQUksQ0FBMkM7QUFDL0Y7QUFFQUYsUUFBUUMsR0FBRyxDQUFDLDBCQUEwQjtJQUFDLEdBQUdNLGNBQWM7SUFBRUMsUUFBUTtBQUFRO0FBRTFFLHNEQUFzRDtBQUN0RCxJQUFJUyxNQUFNO0FBQ1YsSUFBSUMsS0FBSztBQUNULElBQUlDLE9BQU87QUFFWCxJQUFJO0lBQ0YsK0NBQStDO0lBQy9DRixNQUFNLENBQUNwQixxREFBT0EsR0FBR3VCLE1BQU0sR0FBR3hCLDJEQUFhQSxDQUFDVyxrQkFBa0JWLHFEQUFPQSxFQUFFLENBQUMsRUFBRTtJQUV0RSwrQkFBK0I7SUFDL0JxQixLQUFLcEIsZ0VBQVlBLENBQUNtQjtJQUNsQkUsT0FBT3BCLHNEQUFPQSxDQUFDa0I7SUFFZmpCLFFBQVFDLEdBQUcsQ0FBQztBQUNkLEVBQUUsT0FBT29CLE9BQU87SUFDZHJCLFFBQVFxQixLQUFLLENBQUMsZ0NBQWdDQTtBQUM5Qyx5REFBeUQ7QUFDM0Q7QUFFQSw2QkFBNkI7QUFDVDtBQUNwQixpRUFBZUosR0FBR0EsRUFBQyIsInNvdXJjZXMiOlsiQzpcXEFjdGl2ZSAxNC0zLTIwMjVcXFN1bW1hcnlfb2ZfUGVyc29ubmVsX1JhdGlvXFxhcHBcXGxpYlxcZmlyZWJhc2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xyXG5cclxuaW1wb3J0IHsgaW5pdGlhbGl6ZUFwcCwgZ2V0QXBwcyB9IGZyb20gJ2ZpcmViYXNlL2FwcCc7XHJcbmltcG9ydCB7IGdldEZpcmVzdG9yZSB9IGZyb20gJ2ZpcmViYXNlL2ZpcmVzdG9yZSc7XHJcbmltcG9ydCB7IGdldEF1dGggfSBmcm9tICdmaXJlYmFzZS9hdXRoJztcclxuXHJcbi8vIOC5geC4quC4lOC4h+C4hOC5iOC4siBlbnZpcm9ubWVudCB2YXJpYWJsZXMg4Lit4Lit4LiB4Lih4Liy4LmA4Lie4Li34LmI4Lit4LiV4Lij4Lin4LiI4Liq4Lit4LiaICjguKXguJrguK3guK3guIHguKvguKXguLHguIfguIjguLLguIHguYHguIHguYnguJvguLHguI3guKvguLLguYHguKXguYnguKcpXHJcbmNvbnNvbGUubG9nKCdGaXJlYmFzZSBDb25maWcgRW52aXJvbm1lbnQgVmFyaWFibGVzOicpO1xyXG5jb25zb2xlLmxvZygnQVBJIEtleSBhdmFpbGFibGU6JywgISFwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19GSVJFQkFTRV9BUElfS0VZKTtcclxuY29uc29sZS5sb2coJ0F1dGggRG9tYWluIGF2YWlsYWJsZTonLCAhIXByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0ZJUkVCQVNFX0FVVEhfRE9NQUlOKTtcclxuY29uc29sZS5sb2coJ1Byb2plY3QgSUQgYXZhaWxhYmxlOicsICEhcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRklSRUJBU0VfUFJPSkVDVF9JRCk7XHJcblxyXG5jb25zdCBmaXJlYmFzZUNvbmZpZyA9IHtcclxuICBhcGlLZXk6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0ZJUkVCQVNFX0FQSV9LRVkgfHwgJ0FJemFTeUI5c1pGSlNuOGN2a29zNWZ5c2k0N1ZwcUpjNUFzb3JBNCcsXHJcbiAgYXV0aERvbWFpbjogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRklSRUJBU0VfQVVUSF9ET01BSU4gfHwgJ21hbnBvd2VyLXBhdGllbnQtc3VtbWFyeS5maXJlYmFzZWFwcC5jb20nLFxyXG4gIHByb2plY3RJZDogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRklSRUJBU0VfUFJPSkVDVF9JRCB8fCAnbWFucG93ZXItcGF0aWVudC1zdW1tYXJ5JyxcclxuICBzdG9yYWdlQnVja2V0OiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19GSVJFQkFTRV9TVE9SQUdFX0JVQ0tFVCB8fCAnbWFucG93ZXItcGF0aWVudC1zdW1tYXJ5LmZpcmViYXNlc3RvcmFnZS5hcHAnLFxyXG4gIG1lc3NhZ2luZ1NlbmRlcklkOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19GSVJFQkFTRV9NRVNTQUdJTkdfU0VOREVSX0lEIHx8ICc2NDQwNTc0OTY4ODAnLFxyXG4gIGFwcElkOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19GSVJFQkFTRV9BUFBfSUQgfHwgJzE6NjQ0MDU3NDk2ODgwOndlYjo2MjcwZWZjMjkxODdiOWMwMjVkY2Y1J1xyXG59O1xyXG5cclxuY29uc29sZS5sb2coJ1VzaW5nIEZpcmViYXNlIGNvbmZpZzonLCB7Li4uZmlyZWJhc2VDb25maWcsIGFwaUtleTogJ0hJRERFTid9KTtcclxuXHJcbi8vIOC4m+C4o+C4sOC4geC4suC4qOC4leC4seC4p+C5geC4m+C4o+C4meC4reC4gSB0cnktY2F0Y2gg4LmA4Lie4Li34LmI4Lit4LmD4Lir4LmJ4Liq4Liy4Lih4Liy4Lij4LiWIGV4cG9ydCDguYTguJTguYlcclxubGV0IGFwcCA9IG51bGw7XHJcbmxldCBkYiA9IG51bGw7XHJcbmxldCBhdXRoID0gbnVsbDtcclxuXHJcbnRyeSB7XHJcbiAgLy8gQ2hlY2sgaWYgRmlyZWJhc2UgYXBwIGlzIGFscmVhZHkgaW5pdGlhbGl6ZWRcclxuICBhcHAgPSAhZ2V0QXBwcygpLmxlbmd0aCA/IGluaXRpYWxpemVBcHAoZmlyZWJhc2VDb25maWcpIDogZ2V0QXBwcygpWzBdO1xyXG5cclxuICAvLyBJbml0aWFsaXplIEZpcmViYXNlIHNlcnZpY2VzXHJcbiAgZGIgPSBnZXRGaXJlc3RvcmUoYXBwKTtcclxuICBhdXRoID0gZ2V0QXV0aChhcHApO1xyXG5cclxuICBjb25zb2xlLmxvZygnRmlyZWJhc2UgaW5pdGlhbGl6ZWQgc3VjY2Vzc2Z1bGx5Jyk7XHJcbn0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgY29uc29sZS5lcnJvcignRXJyb3IgaW5pdGlhbGl6aW5nIEZpcmViYXNlOicsIGVycm9yKTtcclxuICAvLyDguJXguLHguKfguYHguJvguKMgYXBwLCBkYiDguYHguKXguLAgYXV0aCDguIjguLDguKLguLHguIfguITguIfguYDguJvguYfguJkgbnVsbCDguJbguYnguLLguYDguIHguLTguJQgZXJyb3JcclxufVxyXG5cclxuLy8gRXhwb3J0IOC4meC4reC4gSB0cnktY2F0Y2ggYmxvY2tcclxuZXhwb3J0IHsgZGIsIGF1dGggfTtcclxuZXhwb3J0IGRlZmF1bHQgYXBwO1xyXG4iXSwibmFtZXMiOlsiaW5pdGlhbGl6ZUFwcCIsImdldEFwcHMiLCJnZXRGaXJlc3RvcmUiLCJnZXRBdXRoIiwiY29uc29sZSIsImxvZyIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19GSVJFQkFTRV9BUElfS0VZIiwiTkVYVF9QVUJMSUNfRklSRUJBU0VfQVVUSF9ET01BSU4iLCJORVhUX1BVQkxJQ19GSVJFQkFTRV9QUk9KRUNUX0lEIiwiZmlyZWJhc2VDb25maWciLCJhcGlLZXkiLCJhdXRoRG9tYWluIiwicHJvamVjdElkIiwic3RvcmFnZUJ1Y2tldCIsIk5FWFRfUFVCTElDX0ZJUkVCQVNFX1NUT1JBR0VfQlVDS0VUIiwibWVzc2FnaW5nU2VuZGVySWQiLCJORVhUX1BVQkxJQ19GSVJFQkFTRV9NRVNTQUdJTkdfU0VOREVSX0lEIiwiYXBwSWQiLCJORVhUX1BVQkxJQ19GSVJFQkFTRV9BUFBfSUQiLCJhcHAiLCJkYiIsImF1dGgiLCJsZW5ndGgiLCJlcnJvciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/firebase.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/utils/clientLogging.js":
/*!************************************!*\
  !*** ./app/utils/clientLogging.js ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clearLogs: () => (/* binding */ clearLogs),\n/* harmony export */   getLogs: () => (/* binding */ getLogs),\n/* harmony export */   logEvent: () => (/* binding */ logEvent)\n/* harmony export */ });\n// Local storage key for logs\nconst LOGS_STORAGE_KEY = 'app_logs';\nconst MAX_LOGS = 1000;\n// ส่ง log ไปยัง server\nconst sendLogToServer = async (log)=>{\n    try {\n        const response = await fetch('/api/logs', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(log)\n        });\n        if (!response.ok) {\n            throw new Error(\"Server responded with status \".concat(response.status));\n        }\n        return true;\n    } catch (error) {\n        console.warn('Failed to send log to server:', error);\n        return false;\n    }\n};\nconst logEvent = async function(name) {\n    let properties = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    try {\n        const log = {\n            timestamp: new Date().toISOString(),\n            event: name,\n            properties\n        };\n        // Get existing logs\n        const existingLogs = JSON.parse(localStorage.getItem(LOGS_STORAGE_KEY) || '[]');\n        // Add new log\n        existingLogs.push(log);\n        // Keep only the latest MAX_LOGS entries\n        const trimmedLogs = existingLogs.slice(-MAX_LOGS);\n        // Save back to localStorage\n        localStorage.setItem(LOGS_STORAGE_KEY, JSON.stringify(trimmedLogs));\n        // Development logging\n        if (true) {\n            console.log(\"[Event: \".concat(name, \"]\"), properties);\n        }\n        // ส่ง log ไปยัง server (ไม่รอการตอบกลับ)\n        sendLogToServer(log).catch((error)=>{\n            console.warn('Error sending log to server:', error);\n        });\n        // If you have external logging service (optional)\n        if (false) {}\n    } catch (error) {\n        console.warn('Logging failed:', error);\n    }\n};\nconst getLogs = ()=>{\n    try {\n        return JSON.parse(localStorage.getItem(LOGS_STORAGE_KEY) || '[]');\n    } catch (error) {\n        console.warn('Failed to retrieve logs:', error);\n        return [];\n    }\n};\nconst clearLogs = ()=>{\n    try {\n        localStorage.setItem(LOGS_STORAGE_KEY, '[]');\n    } catch (error) {\n        console.warn('Failed to clear logs:', error);\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC91dGlscy9jbGllbnRMb2dnaW5nLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLDZCQUE2QjtBQUM3QixNQUFNQSxtQkFBbUI7QUFDekIsTUFBTUMsV0FBVztBQUVqQix1QkFBdUI7QUFDdkIsTUFBTUMsa0JBQWtCLE9BQU9DO0lBQzdCLElBQUk7UUFDRixNQUFNQyxXQUFXLE1BQU1DLE1BQU0sYUFBYTtZQUN4Q0MsUUFBUTtZQUNSQyxTQUFTO2dCQUFFLGdCQUFnQjtZQUFtQjtZQUM5Q0MsTUFBTUMsS0FBS0MsU0FBUyxDQUFDUDtRQUN2QjtRQUVBLElBQUksQ0FBQ0MsU0FBU08sRUFBRSxFQUFFO1lBQ2hCLE1BQU0sSUFBSUMsTUFBTSxnQ0FBZ0QsT0FBaEJSLFNBQVNTLE1BQU07UUFDakU7UUFFQSxPQUFPO0lBQ1QsRUFBRSxPQUFPQyxPQUFPO1FBQ2RDLFFBQVFDLElBQUksQ0FBQyxpQ0FBaUNGO1FBQzlDLE9BQU87SUFDVDtBQUNGO0FBRU8sTUFBTUcsV0FBVyxlQUFPQztRQUFNQyw4RUFBYSxDQUFDO0lBQ2pELElBQUk7UUFDRixNQUFNaEIsTUFBTTtZQUNWaUIsV0FBVyxJQUFJQyxPQUFPQyxXQUFXO1lBQ2pDQyxPQUFPTDtZQUNQQztRQUNGO1FBRUEsb0JBQW9CO1FBQ3BCLE1BQU1LLGVBQWVmLEtBQUtnQixLQUFLLENBQUNDLGFBQWFDLE9BQU8sQ0FBQzNCLHFCQUFxQjtRQUUxRSxjQUFjO1FBQ2R3QixhQUFhSSxJQUFJLENBQUN6QjtRQUVsQix3Q0FBd0M7UUFDeEMsTUFBTTBCLGNBQWNMLGFBQWFNLEtBQUssQ0FBQyxDQUFDN0I7UUFFeEMsNEJBQTRCO1FBQzVCeUIsYUFBYUssT0FBTyxDQUFDL0Isa0JBQWtCUyxLQUFLQyxTQUFTLENBQUNtQjtRQUV0RCxzQkFBc0I7UUFDdEIsSUFBSUcsSUFBc0MsRUFBRTtZQUMxQ2pCLFFBQVFaLEdBQUcsQ0FBQyxXQUFnQixPQUFMZSxNQUFLLE1BQUlDO1FBQ2xDO1FBRUEseUNBQXlDO1FBQ3pDakIsZ0JBQWdCQyxLQUFLOEIsS0FBSyxDQUFDbkIsQ0FBQUE7WUFDekJDLFFBQVFDLElBQUksQ0FBQyxnQ0FBZ0NGO1FBQy9DO1FBRUEsa0RBQWtEO1FBQ2xELElBQUlrQixLQUFxRixFQUFFLEVBTTFGO0lBQ0gsRUFBRSxPQUFPbEIsT0FBTztRQUNkQyxRQUFRQyxJQUFJLENBQUMsbUJBQW1CRjtJQUNsQztBQUNGLEVBQUU7QUFFSyxNQUFNc0IsVUFBVTtJQUNyQixJQUFJO1FBQ0YsT0FBTzNCLEtBQUtnQixLQUFLLENBQUNDLGFBQWFDLE9BQU8sQ0FBQzNCLHFCQUFxQjtJQUM5RCxFQUFFLE9BQU9jLE9BQU87UUFDZEMsUUFBUUMsSUFBSSxDQUFDLDRCQUE0QkY7UUFDekMsT0FBTyxFQUFFO0lBQ1g7QUFDRixFQUFFO0FBRUssTUFBTXVCLFlBQVk7SUFDdkIsSUFBSTtRQUNGWCxhQUFhSyxPQUFPLENBQUMvQixrQkFBa0I7SUFDekMsRUFBRSxPQUFPYyxPQUFPO1FBQ2RDLFFBQVFDLElBQUksQ0FBQyx5QkFBeUJGO0lBQ3hDO0FBQ0YsRUFBRSIsInNvdXJjZXMiOlsiQzpcXEFjdGl2ZSAxNC0zLTIwMjVcXFN1bW1hcnlfb2ZfUGVyc29ubmVsX1JhdGlvXFxhcHBcXHV0aWxzXFxjbGllbnRMb2dnaW5nLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIExvY2FsIHN0b3JhZ2Uga2V5IGZvciBsb2dzXHJcbmNvbnN0IExPR1NfU1RPUkFHRV9LRVkgPSAnYXBwX2xvZ3MnO1xyXG5jb25zdCBNQVhfTE9HUyA9IDEwMDA7XHJcblxyXG4vLyDguKrguYjguIcgbG9nIOC5hOC4m+C4ouC4seC4hyBzZXJ2ZXJcclxuY29uc3Qgc2VuZExvZ1RvU2VydmVyID0gYXN5bmMgKGxvZykgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL2xvZ3MnLCB7XHJcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcclxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkobG9nKSxcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgU2VydmVyIHJlc3BvbmRlZCB3aXRoIHN0YXR1cyAke3Jlc3BvbnNlLnN0YXR1c31gKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHNlbmQgbG9nIHRvIHNlcnZlcjonLCBlcnJvcik7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGxvZ0V2ZW50ID0gYXN5bmMgKG5hbWUsIHByb3BlcnRpZXMgPSB7fSkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBsb2cgPSB7XHJcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICBldmVudDogbmFtZSxcclxuICAgICAgcHJvcGVydGllcyxcclxuICAgIH07XHJcblxyXG4gICAgLy8gR2V0IGV4aXN0aW5nIGxvZ3NcclxuICAgIGNvbnN0IGV4aXN0aW5nTG9ncyA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oTE9HU19TVE9SQUdFX0tFWSkgfHwgJ1tdJyk7XHJcbiAgICBcclxuICAgIC8vIEFkZCBuZXcgbG9nXHJcbiAgICBleGlzdGluZ0xvZ3MucHVzaChsb2cpO1xyXG4gICAgXHJcbiAgICAvLyBLZWVwIG9ubHkgdGhlIGxhdGVzdCBNQVhfTE9HUyBlbnRyaWVzXHJcbiAgICBjb25zdCB0cmltbWVkTG9ncyA9IGV4aXN0aW5nTG9ncy5zbGljZSgtTUFYX0xPR1MpO1xyXG4gICAgXHJcbiAgICAvLyBTYXZlIGJhY2sgdG8gbG9jYWxTdG9yYWdlXHJcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShMT0dTX1NUT1JBR0VfS0VZLCBKU09OLnN0cmluZ2lmeSh0cmltbWVkTG9ncykpO1xyXG5cclxuICAgIC8vIERldmVsb3BtZW50IGxvZ2dpbmdcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xyXG4gICAgICBjb25zb2xlLmxvZyhgW0V2ZW50OiAke25hbWV9XWAsIHByb3BlcnRpZXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIOC4quC5iOC4hyBsb2cg4LmE4Lib4Lii4Lix4LiHIHNlcnZlciAo4LmE4Lih4LmI4Lij4Lit4LiB4Liy4Lij4LiV4Lit4Lia4LiB4Lil4Lix4LiaKVxyXG4gICAgc2VuZExvZ1RvU2VydmVyKGxvZykuY2F0Y2goZXJyb3IgPT4ge1xyXG4gICAgICBjb25zb2xlLndhcm4oJ0Vycm9yIHNlbmRpbmcgbG9nIHRvIHNlcnZlcjonLCBlcnJvcik7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBJZiB5b3UgaGF2ZSBleHRlcm5hbCBsb2dnaW5nIHNlcnZpY2UgKG9wdGlvbmFsKVxyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicgJiYgcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRVhURVJOQUxfTE9HR0lOR19VUkwpIHtcclxuICAgICAgZmV0Y2gocHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRVhURVJOQUxfTE9HR0lOR19VUkwsIHtcclxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcclxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShsb2cpXHJcbiAgICAgIH0pLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xyXG4gICAgfVxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLndhcm4oJ0xvZ2dpbmcgZmFpbGVkOicsIGVycm9yKTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0TG9ncyA9ICgpID0+IHtcclxuICB0cnkge1xyXG4gICAgcmV0dXJuIEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oTE9HU19TVE9SQUdFX0tFWSkgfHwgJ1tdJyk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHJldHJpZXZlIGxvZ3M6JywgZXJyb3IpO1xyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBjbGVhckxvZ3MgPSAoKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKExPR1NfU1RPUkFHRV9LRVksICdbXScpO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBjbGVhciBsb2dzOicsIGVycm9yKTtcclxuICB9XHJcbn07XHJcbiJdLCJuYW1lcyI6WyJMT0dTX1NUT1JBR0VfS0VZIiwiTUFYX0xPR1MiLCJzZW5kTG9nVG9TZXJ2ZXIiLCJsb2ciLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5Iiwib2siLCJFcnJvciIsInN0YXR1cyIsImVycm9yIiwiY29uc29sZSIsIndhcm4iLCJsb2dFdmVudCIsIm5hbWUiLCJwcm9wZXJ0aWVzIiwidGltZXN0YW1wIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwiZXZlbnQiLCJleGlzdGluZ0xvZ3MiLCJwYXJzZSIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJwdXNoIiwidHJpbW1lZExvZ3MiLCJzbGljZSIsInNldEl0ZW0iLCJwcm9jZXNzIiwiY2F0Y2giLCJlbnYiLCJORVhUX1BVQkxJQ19FWFRFUk5BTF9MT0dHSU5HX1VSTCIsImdldExvZ3MiLCJjbGVhckxvZ3MiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/utils/clientLogging.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/utils/sessionRecording.js":
/*!***************************************!*\
  !*** ./app/utils/sessionRecording.js ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   identifyUser: () => (/* binding */ identifyUser),\n/* harmony export */   initSessionRecording: () => (/* binding */ initSessionRecording),\n/* harmony export */   logEvent: () => (/* binding */ logEvent)\n/* harmony export */ });\n/* harmony import */ var _clientLogging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./clientLogging */ \"(app-pages-browser)/./app/utils/clientLogging.js\");\n\nconst logEvent = function(name) {\n    let properties = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    (0,_clientLogging__WEBPACK_IMPORTED_MODULE_0__.logEvent)(name, properties);\n};\nconst initSessionRecording = ()=>{\n// No initialization needed\n};\nconst identifyUser = function(userId) {\n    let userInfo = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    (0,_clientLogging__WEBPACK_IMPORTED_MODULE_0__.logEvent)('user_identified', {\n        userId,\n        ...userInfo\n    });\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC91dGlscy9zZXNzaW9uUmVjb3JkaW5nLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBNkQ7QUFFdEQsTUFBTUEsV0FBVyxTQUFDRTtRQUFNQyw4RUFBYSxDQUFDO0lBQzNDRix3REFBY0EsQ0FBQ0MsTUFBTUM7QUFDdkIsRUFBRTtBQUVLLE1BQU1DLHVCQUF1QjtBQUNsQywyQkFBMkI7QUFDN0IsRUFBRTtBQUVLLE1BQU1DLGVBQWUsU0FBQ0M7UUFBUUMsNEVBQVcsQ0FBQztJQUMvQ04sd0RBQWNBLENBQUMsbUJBQW1CO1FBQUVLO1FBQVEsR0FBR0MsUUFBUTtJQUFDO0FBQzFELEVBQUUiLCJzb3VyY2VzIjpbIkM6XFxBY3RpdmUgMTQtMy0yMDI1XFxTdW1tYXJ5X29mX1BlcnNvbm5lbF9SYXRpb1xcYXBwXFx1dGlsc1xcc2Vzc2lvblJlY29yZGluZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBsb2dFdmVudCBhcyBjbGllbnRMb2dFdmVudCB9IGZyb20gJy4vY2xpZW50TG9nZ2luZyc7XHJcblxyXG5leHBvcnQgY29uc3QgbG9nRXZlbnQgPSAobmFtZSwgcHJvcGVydGllcyA9IHt9KSA9PiB7XHJcbiAgY2xpZW50TG9nRXZlbnQobmFtZSwgcHJvcGVydGllcyk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgaW5pdFNlc3Npb25SZWNvcmRpbmcgPSAoKSA9PiB7XHJcbiAgLy8gTm8gaW5pdGlhbGl6YXRpb24gbmVlZGVkXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgaWRlbnRpZnlVc2VyID0gKHVzZXJJZCwgdXNlckluZm8gPSB7fSkgPT4ge1xyXG4gIGNsaWVudExvZ0V2ZW50KCd1c2VyX2lkZW50aWZpZWQnLCB7IHVzZXJJZCwgLi4udXNlckluZm8gfSk7XHJcbn07XHJcbiJdLCJuYW1lcyI6WyJsb2dFdmVudCIsImNsaWVudExvZ0V2ZW50IiwibmFtZSIsInByb3BlcnRpZXMiLCJpbml0U2Vzc2lvblJlY29yZGluZyIsImlkZW50aWZ5VXNlciIsInVzZXJJZCIsInVzZXJJbmZvIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/utils/sessionRecording.js\n"));

/***/ })

}]);
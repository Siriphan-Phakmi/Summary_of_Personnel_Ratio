"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_app_components_forms_WardForm_EventHandlers_js-_app-pages-browser_app_comp-4828b8",{

/***/ "(app-pages-browser)/./app/components/forms/WardForm/DataFetchers.js":
/*!*******************************************************!*\
  !*** ./app/components/forms/WardForm/DataFetchers.js ***!
  \*******************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculatePatientCensus: () => (/* binding */ calculatePatientCensus),\n/* harmony export */   checkApprovalStatus: () => (/* binding */ checkApprovalStatus),\n/* harmony export */   checkFinalApprovalStatus: () => (/* binding */ checkFinalApprovalStatus),\n/* harmony export */   checkMorningShiftDataExists: () => (/* binding */ checkMorningShiftDataExists),\n/* harmony export */   checkPast30DaysRecords: () => (/* binding */ checkPast30DaysRecords),\n/* harmony export */   fetchAndPrepareWardData: () => (/* binding */ fetchAndPrepareWardData),\n/* harmony export */   fetchApprovalData: () => (/* binding */ fetchApprovalData),\n/* harmony export */   fetchDatesWithData: () => (/* binding */ fetchDatesWithData),\n/* harmony export */   fetchLast7DaysData: () => (/* binding */ fetchLast7DaysData),\n/* harmony export */   fetchLatestRecord: () => (/* binding */ fetchLatestRecord),\n/* harmony export */   fetchPreviousShiftData: () => (/* binding */ fetchPreviousShiftData),\n/* harmony export */   fetchPreviousWardData: () => (/* binding */ fetchPreviousWardData),\n/* harmony export */   fetchWardData: () => (/* binding */ fetchWardData),\n/* harmony export */   formatDate: () => (/* binding */ formatDate)\n/* harmony export */ });\n/* harmony import */ var _lib_dataAccess__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../lib/dataAccess */ \"(app-pages-browser)/./app/lib/dataAccess.js\");\n/* harmony import */ var _lib_firebase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../lib/firebase */ \"(app-pages-browser)/./app/lib/firebase.js\");\n/* harmony import */ var _barrel_optimize_names_format_date_fns__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! __barrel_optimize__?names=format!=!date-fns */ \"(app-pages-browser)/./node_modules/date-fns/esm/format/index.js\");\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! firebase/firestore */ \"(app-pages-browser)/./node_modules/firebase/firestore/dist/esm/index.esm.js\");\n/* __next_internal_client_entry_do_not_use__ checkApprovalStatus,fetchWardData,checkMorningShiftDataExists,fetchLast7DaysData,calculatePatientCensus,checkFinalApprovalStatus,fetchDatesWithData,fetchPreviousShiftData,fetchApprovalData,fetchLatestRecord,checkPast30DaysRecords,fetchPreviousWardData,formatDate,fetchAndPrepareWardData auto */ \n\n\n\n\n/**\n * ฟังก์ชันสำหรับตรวจสอบการอนุมัติ\n * @param {string} date วันที่ตรวจสอบ\n * @param {string} shift กะงานที่ตรวจสอบ\n * @param {string} wardId รหัสวอร์ด\n * @returns {Promise<Object>} สถานะการอนุมัติ\n */ const checkApprovalStatus = async (date, shift, wardId)=>{\n    try {\n        const formattedDate = (0,_barrel_optimize_names_format_date_fns__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(new Date(date), 'yyyy-MM-dd');\n        // ตรวจสอบข้อมูลในฐานข้อมูล\n        const wardData = await (0,_lib_dataAccess__WEBPACK_IMPORTED_MODULE_0__.getWardDataByDate)(formattedDate, shift, wardId);\n        if (!wardData) {\n            return {\n                status: 'not_submitted',\n                message: 'ยังไม่ได้บันทึกข้อมูล'\n            };\n        }\n        if (wardData.approvalStatus === 'approved') {\n            return {\n                status: 'approved',\n                message: 'ได้รับการอนุมัติแล้ว',\n                timestamp: wardData.approvalTimestamp,\n                approvedBy: wardData.approvedBy\n            };\n        }\n        if (wardData.approvalStatus === 'rejected') {\n            return {\n                status: 'rejected',\n                message: 'ถูกปฏิเสธการอนุมัติ',\n                timestamp: wardData.approvalTimestamp,\n                rejectedBy: wardData.rejectedBy,\n                rejectionReason: wardData.rejectionReason\n            };\n        }\n        return {\n            status: 'pending',\n            message: 'รอการอนุมัติ'\n        };\n    } catch (error) {\n        console.error('Error checking approval status:', error);\n        return {\n            status: 'error',\n            message: 'เกิดข้อผิดพลาดในการตรวจสอบ'\n        };\n    }\n};\n/**\n * ฟังก์ชันสำหรับดึงข้อมูลวอร์ด\n * @param {string} date วันที่ต้องการดึงข้อมูล\n * @param {string} wardId รหัสวอร์ด\n * @param {string} shift กะงาน\n * @returns {Promise<Object|null>} ข้อมูลวอร์ดหรือ null ถ้าไม่พบ\n */ const fetchWardData = async (date, wardId, shift)=>{\n    try {\n        console.log('Fetching ward data:', {\n            date,\n            wardId,\n            shift\n        });\n        const formattedDate = (0,_barrel_optimize_names_format_date_fns__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(new Date(date), 'yyyy-MM-dd');\n        const docId = \"\".concat(formattedDate, \"_\").concat(wardId, \"_\").concat(shift);\n        // ลองดึงข้อมูลจาก wardDataFinal ก่อน\n        const docRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.doc)(_lib_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'wardDataFinal', docId);\n        const docSnap = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getDoc)(docRef);\n        if (docSnap.exists()) {\n            console.log('Found data in wardDataFinal');\n            return docSnap.data();\n        }\n        // ถ้าไม่มีข้อมูลใน wardDataFinal ให้ลองดึงข้อมูลร่าง\n        const draftsRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.collection)(_lib_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'wardDataDrafts');\n        const draftsQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.query)(draftsRef, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.where)('date', '==', formattedDate), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.where)('wardId', '==', wardId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.where)('shift', '==', shift));\n        const draftsSnap = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getDocs)(draftsQuery);\n        if (!draftsSnap.empty) {\n            console.log('Found data in wardDataDrafts');\n            // เรียงลำดับตาม timestamp เพื่อเอาร่างล่าสุด\n            const drafts = [];\n            draftsSnap.forEach((doc)=>{\n                drafts.push({\n                    id: doc.id,\n                    ...doc.data()\n                });\n            });\n            drafts.sort((a, b)=>new Date(b.timestamp) - new Date(a.timestamp));\n            return drafts[0];\n        }\n        console.log('No data found for this date/shift');\n        return null;\n    } catch (error) {\n        console.error('Error fetching ward data:', error);\n        throw error;\n    }\n};\n/**\n * ฟังก์ชันสำหรับตรวจสอบว่ามีข้อมูลกะเช้าหรือไม่\n * @param {Date} date วันที่ต้องการตรวจสอบ\n * @param {string} wardId รหัสวอร์ด\n * @returns {Promise<boolean>} true ถ้ามีข้อมูลกะเช้า, false ถ้าไม่มี\n */ const checkMorningShiftDataExists = async (date, wardId)=>{\n    try {\n        const formattedDate = (0,_barrel_optimize_names_format_date_fns__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(new Date(date), 'yyyy-MM-dd');\n        const morningData = await (0,_lib_dataAccess__WEBPACK_IMPORTED_MODULE_0__.getWardDataByDate)(formattedDate, 'เช้า', wardId);\n        return morningData ? true : false;\n    } catch (error) {\n        console.error('Error checking morning shift data:', error);\n        return false;\n    }\n};\n/**\n * ฟังก์ชันสำหรับดึงข้อมูล 7 วันย้อนหลัง\n * @param {string} wardId รหัส ward\n * @param {Date} currentDate วันที่ปัจจุบัน (optional)\n * @returns {Promise<Object|null>} ข้อมูลล่าสุดภายใน 7 วันย้อนหลัง หรือ null ถ้าไม่พบข้อมูล\n */ const fetchLast7DaysData = async (currentDate, wardId)=>{\n    try {\n        // สร้างอาร์เรย์ของวันที่ย้อนหลัง 7 วัน\n        const dates = [];\n        for(let i = 1; i <= 7; i++){\n            const date = new Date(currentDate);\n            date.setDate(date.getDate() - i);\n            dates.push((0,_barrel_optimize_names_format_date_fns__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(date, 'yyyy-MM-dd'));\n        }\n        // ดึงข้อมูลกะเช้าจากทั้ง 7 วันย้อนหลัง\n        const promises = dates.map((date)=>(0,_lib_dataAccess__WEBPACK_IMPORTED_MODULE_0__.getWardDataByDate)(date, 'เช้า', wardId));\n        const results = await Promise.all(promises);\n        // กรองเฉพาะวันที่มีข้อมูล\n        const validData = results.filter((data)=>data !== null);\n        // ถ้าไม่มีข้อมูลเลย ส่งค่าว่าง\n        if (validData.length === 0) {\n            return null;\n        }\n        // เรียงลำดับข้อมูลตามวันที่ (ล่าสุดก่อน)\n        validData.sort((a, b)=>new Date(b.date) - new Date(a.date));\n        // ส่งข้อมูลล่าสุดกลับไป\n        return validData[0];\n    } catch (error) {\n        console.error('Error fetching last 7 days data:', error);\n        return null;\n    }\n};\n/**\n * ฟังก์ชันสำหรับคำนวณค่า Patient Census\n * @param {Object} formData ข้อมูลฟอร์ม\n * @returns {string|number} ค่า Patient Census ที่คำนวณได้ หรือ empty string ถ้าไม่มีข้อมูล\n */ const calculatePatientCensus = (patientData)=>{\n    if (!patientData) {\n        console.warn('ไม่สามารถคำนวณได้: ข้อมูล patientData ไม่มี');\n        return '';\n    }\n    // แปลงค่าเป็นตัวเลข และใช้ parseInt ด้วย radix เพื่อป้องกันการแปลงค่าที่ผิดพลาด\n    const hospitalPatientcensus = parseInt(patientData.hospitalPatientcensus || '0', 10) || 0;\n    const newAdmit = parseInt(patientData.newAdmit || '0', 10) || 0;\n    const transferIn = parseInt(patientData.transferIn || '0', 10) || 0;\n    const referIn = parseInt(patientData.referIn || '0', 10) || 0;\n    const transferOut = parseInt(patientData.transferOut || '0', 10) || 0;\n    const referOut = parseInt(patientData.referOut || '0', 10) || 0;\n    const discharge = parseInt(patientData.discharge || '0', 10) || 0;\n    const dead = parseInt(patientData.dead || '0', 10) || 0;\n    // Debug: แสดงค่าที่นำมาคำนวณ\n    console.log('DataFetchers - Patient Census Values:', {\n        hospitalPatientcensus,\n        newAdmit,\n        transferIn,\n        referIn,\n        transferOut,\n        referOut,\n        discharge,\n        dead\n    });\n    // คำนวณตามสูตร: Hospital Patient Census + New Admit + Transfer In + Refer In - Transfer Out - Refer Out - Discharge - Dead\n    const total = hospitalPatientcensus + newAdmit + transferIn + referIn - transferOut - referOut - discharge - dead;\n    console.log(\"DataFetchers คำนวณ Patient Census: \".concat(hospitalPatientcensus, \" + \").concat(newAdmit, \" + \").concat(transferIn, \" + \").concat(referIn, \" - \").concat(transferOut, \" - \").concat(referOut, \" - \").concat(discharge, \" - \").concat(dead, \" = \").concat(total));\n    // Display empty string if total is 0 and all input fields are empty\n    const shouldShowEmpty = total === 0 && !patientData.hospitalPatientcensus && !patientData.newAdmit && !patientData.transferIn && !patientData.referIn && !patientData.transferOut && !patientData.referOut && !patientData.discharge && !patientData.dead;\n    return shouldShowEmpty ? '' : total.toString();\n};\n/**\n * ฟังก์ชันสำหรับตรวจสอบสถานะการอนุมัติขั้นสุดท้าย\n * @param {Date} date วันที่ต้องการตรวจสอบ\n * @param {string} wardId รหัสวอร์ด\n * @param {string} shift กะการทำงาน\n * @returns {Promise<boolean>} true ถ้าได้รับการอนุมัติแล้ว, false ถ้ายังไม่ได้รับการอนุมัติ\n */ const checkFinalApprovalStatus = async (date, shift, wardId, supervisorId)=>{\n    try {\n        // ดึงข้อมูลวอร์ด\n        const wardData = await (0,_lib_dataAccess__WEBPACK_IMPORTED_MODULE_0__.getWardDataByDate)(date, shift, wardId);\n        if (!wardData) return {\n            approved: false,\n            message: 'ไม่พบข้อมูล'\n        };\n        // ตรวจสอบว่ามีการบันทึกจริงหรือไม่\n        if (wardData.status !== 'final') {\n            return {\n                approved: false,\n                message: 'ข้อมูลยังไม่ถูกบันทึกเป็นฉบับสมบูรณ์'\n            };\n        }\n        // ตรวจสอบรหัสผู้อนุมัติ\n        if (wardData.approvedBy !== supervisorId) {\n            // ดึงข้อมูลผู้อนุมัติจากฐานข้อมูล\n            try {\n                const approverData = await (0,_lib_dataAccess__WEBPACK_IMPORTED_MODULE_0__.getUserDataFromCollection)(wardData.approvedBy);\n                const approverName = (approverData === null || approverData === void 0 ? void 0 : approverData.name) || 'ไม่ทราบชื่อ';\n                return {\n                    approved: false,\n                    message: \"อนุมัติแล้วโดย \".concat(approverName)\n                };\n            } catch (error) {\n                return {\n                    approved: false,\n                    message: 'อนุมัติแล้วโดยผู้ใช้ท่านอื่น'\n                };\n            }\n        }\n        // กรณีที่อนุมัติแล้วโดยผู้ใช้คนปัจจุบัน\n        return {\n            approved: true,\n            message: 'คุณได้อนุมัติข้อมูลนี้แล้ว'\n        };\n    } catch (error) {\n        console.error('Error checking approval status:', error);\n        return {\n            approved: false,\n            message: 'เกิดข้อผิดพลาดในการตรวจสอบสถานะ'\n        };\n    }\n};\n/**\n * ฟังก์ชันสำหรับดึงวันที่ที่มีข้อมูลอยู่แล้วในระบบ\n * @param {string} wardId รหัสวอร์ด\n * @returns {Promise<Array<Object>>} อาร์เรย์ของวันที่ที่มีข้อมูล\n */ const fetchDatesWithData = async (wardId)=>{\n    try {\n        if (!wardId) {\n            console.error('fetchDatesWithData: Missing wardId');\n            return [];\n        }\n        // ดึงข้อมูลจากทั้ง collection wardDataFinal และ wardDataDrafts\n        // โค้ดจำลองการดึงข้อมูล\n        const dates = [\n            {\n                date: '2025-03-18',\n                shifts: [\n                    'Morning (07:00-19:00)',\n                    'Night (19:00-07:00)'\n                ]\n            },\n            {\n                date: '2025-03-17',\n                shifts: [\n                    'Morning (07:00-19:00)'\n                ]\n            },\n            {\n                date: '2025-03-16',\n                shifts: [\n                    'Night (19:00-07:00)'\n                ]\n            }\n        ];\n        return dates;\n    } catch (error) {\n        console.error('Error fetching dates with data:', error);\n        return [];\n    }\n};\n/**\n * ฟังก์ชันสำหรับดึงข้อมูลกะงานก่อนหน้า\n * @param {string} date วันที่\n * @param {string} wardId รหัสวอร์ด\n * @param {string} currentShift กะงานปัจจุบัน\n * @returns {Promise<Object|null>} ข้อมูลกะงานก่อนหน้า หรือ null ถ้าไม่พบ\n */ const fetchPreviousShiftData = async (date, wardId, currentShift)=>{\n    try {\n        if (!date || !wardId || !currentShift) {\n            return null;\n        }\n        // กำหนดกะงานก่อนหน้า\n        let previousShift;\n        let previousDate = new Date(date);\n        if (currentShift === 'Morning (07:00-19:00)') {\n            // ถ้าเป็นกะเช้า ให้ดูกะดึกของวันก่อนหน้า\n            previousDate.setDate(previousDate.getDate() - 1);\n            previousShift = 'Night (19:00-07:00)';\n        } else {\n            // ถ้าเป็นกะดึก ให้ดูกะเช้าของวันเดียวกัน\n            previousShift = 'Morning (07:00-19:00)';\n        }\n        const formattedPreviousDate = (0,_barrel_optimize_names_format_date_fns__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(previousDate, 'yyyy-MM-dd');\n        const previousData = await (0,_lib_dataAccess__WEBPACK_IMPORTED_MODULE_0__.getWardDataByDate)(formattedPreviousDate, previousShift, wardId);\n        return previousData;\n    } catch (error) {\n        console.error('Error fetching previous shift data:', error);\n        return null;\n    }\n};\n/**\n * ฟังก์ชันสำหรับดึงข้อมูลการอนุมัติ\n * @param {string} date วันที่\n * @param {string} wardId รหัสวอร์ด\n * @param {string} shift กะงาน\n * @returns {Promise<Object|null>} ข้อมูลการอนุมัติ หรือ null ถ้าไม่พบ\n */ const fetchApprovalData = async (date, wardId, shift)=>{\n    try {\n        if (!date || !wardId || !shift) {\n            return null;\n        }\n        const formattedDate = (0,_barrel_optimize_names_format_date_fns__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(new Date(date), 'yyyy-MM-dd');\n        const wardData = await (0,_lib_dataAccess__WEBPACK_IMPORTED_MODULE_0__.getWardDataByDate)(formattedDate, shift, wardId);\n        if (!wardData) {\n            return null;\n        }\n        return {\n            status: wardData.approvalStatus || 'pending',\n            approvedBy: wardData.approvedBy || null,\n            approvalTimestamp: wardData.approvalTimestamp || null,\n            rejectedBy: wardData.rejectedBy || null,\n            rejectionReason: wardData.rejectionReason || null,\n            comments: wardData.approvalComments || null\n        };\n    } catch (error) {\n        console.error('Error fetching approval data:', error);\n        return null;\n    }\n};\n/**\n * ฟังก์ชันสำหรับดึงข้อมูลล่าสุด\n * @param {string} wardId รหัสวอร์ด\n * @returns {Promise<Object|null>} ข้อมูลล่าสุด หรือ null ถ้าไม่พบ\n */ const fetchLatestRecord = async (wardId)=>{\n    try {\n        if (!wardId) {\n            return null;\n        }\n        // ตรวจสอบย้อนหลังจากวันปัจจุบันไปจนถึง 30 วันก่อนหน้า\n        const currentDate = new Date();\n        let latestData = null;\n        for(let i = 0; i < 30; i++){\n            const checkDate = new Date(currentDate);\n            checkDate.setDate(checkDate.getDate() - i);\n            const formattedDate = (0,_barrel_optimize_names_format_date_fns__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(checkDate, 'yyyy-MM-dd');\n            // ตรวจสอบกะดึกก่อน แล้วจึงตรวจสอบกะเช้า\n            const nightData = await (0,_lib_dataAccess__WEBPACK_IMPORTED_MODULE_0__.getWardDataByDate)(formattedDate, 'Night (19:00-07:00)', wardId);\n            if (nightData) {\n                return nightData;\n            }\n            const morningData = await (0,_lib_dataAccess__WEBPACK_IMPORTED_MODULE_0__.getWardDataByDate)(formattedDate, 'Morning (07:00-19:00)', wardId);\n            if (morningData) {\n                return morningData;\n            }\n        }\n        return null;\n    } catch (error) {\n        console.error('Error fetching latest record:', error);\n        return null;\n    }\n};\n/**\n * ฟังก์ชันสำหรับตรวจสอบว่ามีข้อมูลใน 30 วันล่าสุดหรือไม่\n * @param {string} wardId รหัสวอร์ด\n * @returns {Promise<boolean>} true ถ้ามีข้อมูลใน 30 วันล่าสุด, false ถ้าไม่มี\n */ const checkPast30DaysRecords = async (wardId)=>{\n    try {\n        if (!wardId) {\n            return false;\n        }\n        const latestRecord = await fetchLatestRecord(wardId);\n        return latestRecord !== null;\n    } catch (error) {\n        console.error('Error checking past 30 days records:', error);\n        return false;\n    }\n};\n/**\n * ฟังก์ชันสำหรับดึงข้อมูลย้อนหลัง X วัน\n */ const fetchPreviousWardData = async function(department, currentDate) {\n    let days = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 7;\n    try {\n        console.log(\"Getting previous \".concat(days, \" days data for \").concat(department, \" from \").concat(currentDate));\n        // โค้ดดึงข้อมูลย้อนหลัง...\n        // (คัดลอกจาก WardForm.js ใส่ตรงนี้)\n        return [];\n    } catch (error) {\n        console.error('Error getting previous data:', error);\n        return [];\n    }\n};\n/**\n * แปลงรูปแบบวันที่\n */ const formatDate = (date)=>{\n    if (!date) return '';\n    const d = new Date(date);\n    if (isNaN(d.getTime())) return '';\n    return (0,_barrel_optimize_names_format_date_fns__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(d, 'yyyy-MM-dd');\n};\n/**\n * ฟังก์ชันสำหรับดึงข้อมูลและจัดการการโหลดข้อมูลอัตโนมัติตามกะ\n * @param {string} date วันที่\n * @param {string} wardId รหัสวอร์ด\n * @param {string} shift กะงาน\n * @returns {Promise<Object>} ข้อมูลที่โหลด พร้อมสถานะ\n */ const fetchAndPrepareWardData = async (date, wardId, shift)=>{\n    try {\n        console.log(\"Fetching and preparing data for \".concat(date, \", \").concat(wardId, \", \").concat(shift));\n        // ดึงข้อมูลของกะปัจจุบัน\n        const wardData = await fetchWardData(date, wardId, shift);\n        let patientCensusTotal = 0;\n        let sourceMessage = '';\n        // ตรวจสอบว่ามีข้อมูลหรือไม่\n        if (wardData) {\n            console.log('Found existing data for this shift');\n            // คำนวณ Patient Census ถ้ามีข้อมูล\n            if (wardData.patientCensus) {\n                patientCensusTotal = calculatePatientCensus(wardData.patientCensus);\n                sourceMessage = 'ข้อมูลผู้ป่วยคำนวณจากข้อมูลในระบบ';\n            }\n            return {\n                data: wardData,\n                hasData: true,\n                patientCensusTotal,\n                sourceMessage\n            };\n        }\n        // ถ้าไม่มีข้อมูล จะดึงข้อมูลตามกฎที่กำหนด\n        if (shift === 'Morning (07:00-19:00)') {\n            // กรณีกะเช้า: ดึงข้อมูลย้อนหลัง 7 วัน\n            const previousDate = new Date(date);\n            previousDate.setDate(previousDate.getDate() - 7);\n            const formattedPreviousDate = (0,_barrel_optimize_names_format_date_fns__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(previousDate, 'yyyy-MM-dd');\n            console.log('No data found for morning shift, checking data from 7 days ago:', formattedPreviousDate);\n            const previousData = await fetchWardData(formattedPreviousDate, wardId, shift);\n            if (previousData) {\n                console.log('Found previous data from 7 days ago');\n                // คำนวณ Patient Census ถ้ามีข้อมูล\n                if (previousData.patientCensus) {\n                    patientCensusTotal = calculatePatientCensus(previousData.patientCensus);\n                    sourceMessage = 'ข้อมูลผู้ป่วยคำนวณจากข้อมูล 7 วันก่อน';\n                }\n                // สร้างข้อมูลใหม่โดยใช้ข้อมูลเดิมแต่ไม่เอา ID และข้อมูลเฉพาะอื่นๆ\n                const newData = {\n                    ...previousData\n                };\n                delete newData.id;\n                delete newData.timestamp;\n                delete newData.createdAt;\n                delete newData.updatedAt;\n                delete newData.approvalStatus;\n                delete newData.approvedBy;\n                delete newData.approvalTimestamp;\n                // อัปเดตค่า Patient Census\n                if (newData.patientCensus) {\n                    newData.patientCensus.total = patientCensusTotal.toString();\n                }\n                return {\n                    data: newData,\n                    hasData: true,\n                    patientCensusTotal,\n                    sourceMessage,\n                    isAutoFilledFromHistory: true\n                };\n            }\n        } else if (shift === 'Night (19:00-07:00)') {\n            // กรณีกะดึก: ดึงข้อมูลจากกะเช้าของวันเดียวกัน\n            console.log('No data found for night shift, checking morning shift from same day');\n            const morningData = await fetchWardData(date, wardId, 'Morning (07:00-19:00)');\n            if (morningData) {\n                console.log('Found morning shift data from same day');\n                // คำนวณ Patient Census ถ้ามีข้อมูล\n                if (morningData.patientCensus) {\n                    patientCensusTotal = calculatePatientCensus(morningData.patientCensus);\n                    sourceMessage = 'ข้อมูลผู้ป่วยคำนวณจากข้อมูลกะเช้า';\n                }\n                // สร้างข้อมูลใหม่โดยใช้ข้อมูลจากกะเช้า\n                const newData = {\n                    ...morningData\n                };\n                delete newData.id;\n                delete newData.timestamp;\n                delete newData.createdAt;\n                delete newData.updatedAt;\n                delete newData.approvalStatus;\n                delete newData.approvedBy;\n                delete newData.approvalTimestamp;\n                // อัปเดตค่า Patient Census และ Overall Data (สำหรับกะดึก)\n                if (newData.patientCensus) {\n                    newData.patientCensus.total = patientCensusTotal.toString();\n                }\n                newData.overallData = patientCensusTotal.toString();\n                return {\n                    data: newData,\n                    hasData: true,\n                    patientCensusTotal,\n                    sourceMessage,\n                    isAutoFilledFromHistory: true\n                };\n            }\n        }\n        // ถ้าไม่มีข้อมูลใดๆ ให้สร้างข้อมูลเปล่า\n        return {\n            data: null,\n            hasData: false,\n            patientCensusTotal: 0,\n            sourceMessage: 'ไม่พบข้อมูลก่อนหน้า'\n        };\n    } catch (error) {\n        console.error('Error fetching and preparing ward data:', error);\n        return {\n            data: null,\n            hasData: false,\n            patientCensusTotal: 0,\n            sourceMessage: 'เกิดข้อผิดพลาดในการโหลดข้อมูล',\n            error: error.message\n        };\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9jb21wb25lbnRzL2Zvcm1zL1dhcmRGb3JtL0RhdGFGZXRjaGVycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b1ZBRTJHO0FBQ2pDO0FBQ3hDO0FBQ1M7QUFDeUQ7QUFFcEc7Ozs7OztDQU1DLEdBQ00sTUFBTWUsc0JBQXNCLE9BQU9DLE1BQU1DLE9BQU9DO0lBQ3JELElBQUk7UUFDRixNQUFNQyxnQkFBZ0JkLGtGQUFNQSxDQUFDLElBQUllLEtBQUtKLE9BQU87UUFDN0MsMkJBQTJCO1FBQzNCLE1BQU1LLFdBQVcsTUFBTXBCLGtFQUFpQkEsQ0FBQ2tCLGVBQWVGLE9BQU9DO1FBRS9ELElBQUksQ0FBQ0csVUFBVTtZQUNiLE9BQU87Z0JBQUVDLFFBQVE7Z0JBQWlCQyxTQUFTO1lBQXdCO1FBQ3JFO1FBRUEsSUFBSUYsU0FBU0csY0FBYyxLQUFLLFlBQVk7WUFDMUMsT0FBTztnQkFDTEYsUUFBUTtnQkFDUkMsU0FBUztnQkFDVEUsV0FBV0osU0FBU0ssaUJBQWlCO2dCQUNyQ0MsWUFBWU4sU0FBU00sVUFBVTtZQUNqQztRQUNGO1FBRUEsSUFBSU4sU0FBU0csY0FBYyxLQUFLLFlBQVk7WUFDMUMsT0FBTztnQkFDTEYsUUFBUTtnQkFDUkMsU0FBUztnQkFDVEUsV0FBV0osU0FBU0ssaUJBQWlCO2dCQUNyQ0UsWUFBWVAsU0FBU08sVUFBVTtnQkFDL0JDLGlCQUFpQlIsU0FBU1EsZUFBZTtZQUMzQztRQUNGO1FBRUEsT0FBTztZQUFFUCxRQUFRO1lBQVdDLFNBQVM7UUFBZTtJQUN0RCxFQUFFLE9BQU9PLE9BQU87UUFDZEMsUUFBUUQsS0FBSyxDQUFDLG1DQUFtQ0E7UUFDakQsT0FBTztZQUFFUixRQUFRO1lBQVNDLFNBQVM7UUFBNkI7SUFDbEU7QUFDRixFQUFFO0FBRUY7Ozs7OztDQU1DLEdBQ00sTUFBTVMsZ0JBQWdCLE9BQU9oQixNQUFNRSxRQUFRRDtJQUM5QyxJQUFJO1FBQ0FjLFFBQVFF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Z0JBQWdCO2dCQUNwQjtnQkFFQSx1Q0FBdUM7Z0JBQ3ZDLE1BQU1HLFVBQVU7b0JBQUUsR0FBR2pFLFdBQVc7Z0JBQUM7Z0JBQ2pDLE9BQU9pRSxRQUFRdEUsRUFBRTtnQkFDakIsT0FBT3NFLFFBQVEzRixTQUFTO2dCQUN4QixPQUFPMkYsUUFBUUMsU0FBUztnQkFDeEIsT0FBT0QsUUFBUUUsU0FBUztnQkFDeEIsT0FBT0YsUUFBUTVGLGNBQWM7Z0JBQzdCLE9BQU80RixRQUFRekYsVUFBVTtnQkFDekIsT0FBT3lGLFFBQVExRixpQkFBaUI7Z0JBRWhDLDBEQUEwRDtnQkFDMUQsSUFBSTBGLFFBQVFGLGFBQWEsRUFBRTtvQkFDdkJFLFFBQVFGLGFBQWEsQ0FBQ3BDLEtBQUssR0FBR2tDLG1CQUFtQmhDLFFBQVE7Z0JBQzdEO2dCQUNBb0MsUUFBUUksV0FBVyxHQUFHUixtQkFBbUJoQyxRQUFRO2dCQUVqRCxPQUFPO29CQUNIMUMsTUFBTThFO29CQUNORCxTQUFTO29CQUNUSDtvQkFDQUM7b0JBQ0FNLHlCQUF5QjtnQkFDN0I7WUFDSjtRQUNKO1FBRUEsd0NBQXdDO1FBQ3hDLE9BQU87WUFDSGpGLE1BQU07WUFDTjZFLFNBQVM7WUFDVEgsb0JBQW9CO1lBQ3BCQyxlQUFlO1FBQ25CO0lBQ0osRUFBRSxPQUFPbkYsT0FBTztRQUNaQyxRQUFRRCxLQUFLLENBQUMsMkNBQTJDQTtRQUN6RCxPQUFPO1lBQ0hRLE1BQU07WUFDTjZFLFNBQVM7WUFDVEgsb0JBQW9CO1lBQ3BCQyxlQUFlO1lBQ2ZuRixPQUFPQSxNQUFNUCxPQUFPO1FBQ3hCO0lBQ0o7QUFDSixFQUFFIiwic291cmNlcyI6WyJDOlxcUHJvamVjdCBCUEs5IDIwLTMtMjU2OFxcU3VtbWFyeV9vZl9QZXJzb25uZWxfUmF0aW9cXGFwcFxcY29tcG9uZW50c1xcZm9ybXNcXFdhcmRGb3JtXFxEYXRhRmV0Y2hlcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgeyBnZXRVc2VyRGF0YUZyb21Db2xsZWN0aW9uLCBnZXRXYXJkRGF0YUJ5RGF0ZSwgY2hlY2tMYXN0N0RheXNEYXRhIH0gZnJvbSAnLi4vLi4vLi4vbGliL2RhdGFBY2Nlc3MnO1xuaW1wb3J0IHsgZ2V0U3ViY29sbGVjdGlvbiwgZ2V0RG9jdW1lbnRCeUlkIH0gZnJvbSAnLi4vLi4vLi4vbGliL2ZpcmViYXNlJztcbmltcG9ydCB7IGZvcm1hdCB9IGZyb20gJ2RhdGUtZm5zJztcbmltcG9ydCB7IGRiIH0gZnJvbSAnLi4vLi4vLi4vbGliL2ZpcmViYXNlJztcbmltcG9ydCB7IGNvbGxlY3Rpb24sIHF1ZXJ5LCB3aGVyZSwgZ2V0RG9jcywgZG9jLCBnZXREb2MsIG9yZGVyQnksIGxpbWl0IH0gZnJvbSAnZmlyZWJhc2UvZmlyZXN0b3JlJztcblxuLyoqXG4gKiDguJ/guLHguIfguIHguYzguIrguLHguJnguKrguLPguKvguKPguLHguJrguJXguKPguKfguIjguKrguK3guJrguIHguLLguKPguK3guJnguLjguKHguLHguJXguLRcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRlIOC4p+C4seC4meC4l+C4teC5iOC4leC4o+C4p+C4iOC4quC4reC4mlxuICogQHBhcmFtIHtzdHJpbmd9IHNoaWZ0IOC4geC4sOC4h+C4suC4meC4l+C4teC5iOC4leC4o+C4p+C4iOC4quC4reC4mlxuICogQHBhcmFtIHtzdHJpbmd9IHdhcmRJZCDguKPguKvguLHguKrguKfguK3guKPguYzguJRcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IOC4quC4luC4suC4meC4sOC4geC4suC4o+C4reC4meC4uOC4oeC4seC4leC4tFxuICovXG5leHBvcnQgY29uc3QgY2hlY2tBcHByb3ZhbFN0YXR1cyA9IGFzeW5jIChkYXRlLCBzaGlmdCwgd2FyZElkKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgZm9ybWF0dGVkRGF0ZSA9IGZvcm1hdChuZXcgRGF0ZShkYXRlKSwgJ3l5eXktTU0tZGQnKTtcbiAgICAvLyDguJXguKPguKfguIjguKrguK3guJrguILguYnguK3guKHguLnguKXguYPguJnguJDguLLguJnguILguYnguK3guKHguLnguKVcbiAgICBjb25zdCB3YXJkRGF0YSA9IGF3YWl0IGdldFdhcmREYXRhQnlEYXRlKGZvcm1hdHRlZERhdGUsIHNoaWZ0LCB3YXJkSWQpO1xuICAgIFxuICAgIGlmICghd2FyZERhdGEpIHtcbiAgICAgIHJldHVybiB7IHN0YXR1czogJ25vdF9zdWJtaXR0ZWQnLCBtZXNzYWdlOiAn4Lii4Lix4LiH4LmE4Lih4LmI4LmE4LiU4LmJ4Lia4Lix4LiZ4LiX4Li24LiB4LiC4LmJ4Lit4Lih4Li54LilJyB9O1xuICAgIH1cbiAgICBcbiAgICBpZiAod2FyZERhdGEuYXBwcm92YWxTdGF0dXMgPT09ICdhcHByb3ZlZCcpIHtcbiAgICAgIHJldHVybiB7IFxuICAgICAgICBzdGF0dXM6ICdhcHByb3ZlZCcsIFxuICAgICAgICBtZXNzYWdlOiAn4LmE4LiU4LmJ4Lij4Lix4Lia4LiB4Liy4Lij4Lit4LiZ4Li44Lih4Lix4LiV4Li04LmB4Lil4LmJ4LinJywgXG4gICAgICAgIHRpbWVzdGFtcDogd2FyZERhdGEuYXBwcm92YWxUaW1lc3RhbXAsXG4gICAgICAgIGFwcHJvdmVkQnk6IHdhcmREYXRhLmFwcHJvdmVkQnkgXG4gICAgICB9O1xuICAgIH1cbiAgICBcbiAgICBpZiAod2FyZERhdGEuYXBwcm92YWxTdGF0dXMgPT09ICdyZWplY3RlZCcpIHtcbiAgICAgIHJldHVybiB7IFxuICAgICAgICBzdGF0dXM6ICdyZWplY3RlZCcsIFxuICAgICAgICBtZXNzYWdlOiAn4LiW4Li54LiB4Lib4LiP4Li04LmA4Liq4LiY4LiB4Liy4Lij4Lit4LiZ4Li44Lih4Lix4LiV4Li0JywgXG4gICAgICAgIHRpbWVzdGFtcDogd2FyZERhdGEuYXBwcm92YWxUaW1lc3RhbXAsXG4gICAgICAgIHJlamVjdGVkQnk6IHdhcmREYXRhLnJlamVjdGVkQnksXG4gICAgICAgIHJlamVjdGlvblJlYXNvbjogd2FyZERhdGEucmVqZWN0aW9uUmVhc29uIFxuICAgICAgfTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHsgc3RhdHVzOiAncGVuZGluZycsIG1lc3NhZ2U6ICfguKPguK3guIHguLLguKPguK3guJnguLjguKHguLHguJXguLQnIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgY2hlY2tpbmcgYXBwcm92YWwgc3RhdHVzOicsIGVycm9yKTtcbiAgICByZXR1cm4geyBzdGF0dXM6ICdlcnJvcicsIG1lc3NhZ2U6ICfguYDguIHguLTguJTguILguYnguK3guJzguLTguJTguJ7guKXguLLguJTguYPguJnguIHguLLguKPguJXguKPguKfguIjguKrguK3guJonIH07XG4gIH1cbn07XG5cbi8qKlxuICog4Lif4Lix4LiH4LiB4LmM4LiK4Lix4LiZ4Liq4Liz4Lir4Lij4Lix4Lia4LiU4Li24LiH4LiC4LmJ4Lit4Lih4Li54Lil4Lin4Lit4Lij4LmM4LiUXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0ZSDguKfguLHguJnguJfguLXguYjguJXguYnguK3guIfguIHguLLguKPguJTguLbguIfguILguYnguK3guKHguLnguKVcbiAqIEBwYXJhbSB7c3RyaW5nfSB3YXJkSWQg4Lij4Lir4Lix4Liq4Lin4Lit4Lij4LmM4LiUXG4gKiBAcGFyYW0ge3N0cmluZ30gc2hpZnQg4LiB4Liw4LiH4Liy4LiZXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3R8bnVsbD59IOC4guC5ieC4reC4oeC4ueC4peC4p+C4reC4o+C5jOC4lOC4q+C4o+C4t+C4rSBudWxsIOC4luC5ieC4suC5hOC4oeC5iOC4nuC4mlxuICovXG5leHBvcnQgY29uc3QgZmV0Y2hXYXJkRGF0YSA9IGFzeW5jIChkYXRlLCB3YXJkSWQsIHNoaWZ0KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5sb2coJ0ZldGNoaW5nIHdhcmQgZGF0YTonLCB7IGRhdGUsIHdhcmRJZCwgc2hpZnQgfSk7XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlZERhdGUgPSBmb3JtYXQobmV3IERhdGUoZGF0ZSksICd5eXl5LU1NLWRkJyk7XG4gICAgICAgIGNvbnN0IGRvY0lkID0gYCR7Zm9ybWF0dGVkRGF0ZX1fJHt3YXJkSWR9XyR7c2hpZnR9YDtcbiAgICAgICAgXG4gICAgICAgIC8vIOC4peC4reC4h+C4lOC4tuC4h+C4guC5ieC4reC4oeC4ueC4peC4iOC4suC4gSB3YXJkRGF0YUZpbmFsIOC4geC5iOC4reC4mVxuICAgICAgICBjb25zdCBkb2NSZWYgPSBkb2MoZGIsICd3YXJkRGF0YUZpbmFsJywgZG9jSWQpO1xuICAgICAgICBjb25zdCBkb2NTbmFwID0gYXdhaXQgZ2V0RG9jKGRvY1JlZik7XG4gICAgICAgIFxuICAgICAgICBpZiAoZG9jU25hcC5leGlzdHMoKSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZvdW5kIGRhdGEgaW4gd2FyZERhdGFGaW5hbCcpO1xuICAgICAgICAgICAgcmV0dXJuIGRvY1NuYXAuZGF0YSgpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyDguJbguYnguLLguYTguKHguYjguKHguLXguILguYnguK3guKHguLnguKXguYPguJkgd2FyZERhdGFGaW5hbCDguYPguKvguYnguKXguK3guIfguJTguLbguIfguILguYnguK3guKHguLnguKXguKPguYjguLLguIdcbiAgICAgICAgY29uc3QgZHJhZnRzUmVmID0gY29sbGVjdGlvbihkYiwgJ3dhcmREYXRhRHJhZnRzJyk7XG4gICAgICAgIGNvbnN0IGRyYWZ0c1F1ZXJ5ID0gcXVlcnkoXG4gICAgICAgICAgICBkcmFmdHNSZWYsXG4gICAgICAgICAgICB3aGVyZSgnZGF0ZScsICc9PScsIGZvcm1hdHRlZERhdGUpLFxuICAgICAgICAgICAgd2hlcmUoJ3dhcmRJZCcsICc9PScsIHdhcmRJZCksXG4gICAgICAgICAgICB3aGVyZSgnc2hpZnQnLCAnPT0nLCBzaGlmdClcbiAgICAgICAgKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGRyYWZ0c1NuYXAgPSBhd2FpdCBnZXREb2NzKGRyYWZ0c1F1ZXJ5KTtcbiAgICAgICAgXG4gICAgICAgIGlmICghZHJhZnRzU25hcC5lbXB0eSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZvdW5kIGRhdGEgaW4gd2FyZERhdGFEcmFmdHMnKTtcbiAgICAgICAgICAgIC8vIOC5gOC4o+C4teC4ouC4h+C4peC4s+C4lOC4seC4muC4leC4suC4oSB0aW1lc3RhbXAg4LmA4Lie4Li34LmI4Lit4LmA4Lit4Liy4Lij4LmI4Liy4LiH4Lil4LmI4Liy4Liq4Li44LiUXG4gICAgICAgICAgICBjb25zdCBkcmFmdHMgPSBbXTtcbiAgICAgICAgICAgIGRyYWZ0c1NuYXAuZm9yRWFjaChkb2MgPT4ge1xuICAgICAgICAgICAgICAgIGRyYWZ0cy5wdXNoKHsgaWQ6IGRvYy5pZCwgLi4uZG9jLmRhdGEoKSB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBkcmFmdHMuc29ydCgoYSwgYikgPT4gbmV3IERhdGUoYi50aW1lc3RhbXApIC0gbmV3IERhdGUoYS50aW1lc3RhbXApKTtcbiAgICAgICAgICAgIHJldHVybiBkcmFmdHNbMF07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKCdObyBkYXRhIGZvdW5kIGZvciB0aGlzIGRhdGUvc2hpZnQnKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgd2FyZCBkYXRhOicsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufTtcblxuLyoqXG4gKiDguJ/guLHguIfguIHguYzguIrguLHguJnguKrguLPguKvguKPguLHguJrguJXguKPguKfguIjguKrguK3guJrguKfguYjguLLguKHguLXguILguYnguK3guKHguLnguKXguIHguLDguYDguIrguYnguLLguKvguKPguLfguK3guYTguKHguYhcbiAqIEBwYXJhbSB7RGF0ZX0gZGF0ZSDguKfguLHguJnguJfguLXguYjguJXguYnguK3guIfguIHguLLguKPguJXguKPguKfguIjguKrguK3guJpcbiAqIEBwYXJhbSB7c3RyaW5nfSB3YXJkSWQg4Lij4Lir4Lix4Liq4Lin4Lit4Lij4LmM4LiUXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn0gdHJ1ZSDguJbguYnguLLguKHguLXguILguYnguK3guKHguLnguKXguIHguLDguYDguIrguYnguLIsIGZhbHNlIOC4luC5ieC4suC5hOC4oeC5iOC4oeC4tVxuICovXG5leHBvcnQgY29uc3QgY2hlY2tNb3JuaW5nU2hpZnREYXRhRXhpc3RzID0gYXN5bmMgKGRhdGUsIHdhcmRJZCkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IGZvcm1hdHRlZERhdGUgPSBmb3JtYXQobmV3IERhdGUoZGF0ZSksICd5eXl5LU1NLWRkJyk7XG4gICAgY29uc3QgbW9ybmluZ0RhdGEgPSBhd2FpdCBnZXRXYXJkRGF0YUJ5RGF0ZShmb3JtYXR0ZWREYXRlLCAn4LmA4LiK4LmJ4LiyJywgd2FyZElkKTtcbiAgICByZXR1cm4gbW9ybmluZ0RhdGEgPyB0cnVlIDogZmFsc2U7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgY2hlY2tpbmcgbW9ybmluZyBzaGlmdCBkYXRhOicsIGVycm9yKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbi8qKlxuICog4Lif4Lix4LiH4LiB4LmM4LiK4Lix4LiZ4Liq4Liz4Lir4Lij4Lix4Lia4LiU4Li24LiH4LiC4LmJ4Lit4Lih4Li54LilIDcg4Lin4Lix4LiZ4Lii4LmJ4Lit4LiZ4Lir4Lil4Lix4LiHXG4gKiBAcGFyYW0ge3N0cmluZ30gd2FyZElkIOC4o+C4q+C4seC4qiB3YXJkXG4gKiBAcGFyYW0ge0RhdGV9IGN1cnJlbnREYXRlIOC4p+C4seC4meC4l+C4teC5iOC4m+C4seC4iOC4iOC4uOC4muC4seC4mSAob3B0aW9uYWwpXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3R8bnVsbD59IOC4guC5ieC4reC4oeC4ueC4peC4peC5iOC4suC4quC4uOC4lOC4oOC4suC4ouC5g+C4mSA3IOC4p+C4seC4meC4ouC5ieC4reC4meC4q+C4peC4seC4hyDguKvguKPguLfguK0gbnVsbCDguJbguYnguLLguYTguKHguYjguJ7guJrguILguYnguK3guKHguLnguKVcbiAqL1xuZXhwb3J0IGNvbnN0IGZldGNoTGFzdDdEYXlzRGF0YSA9IGFzeW5jIChjdXJyZW50RGF0ZSwgd2FyZElkKSA9PiB7XG4gIHRyeSB7XG4gICAgLy8g4Liq4Lij4LmJ4Liy4LiH4Lit4Liy4Lij4LmM4LmA4Lij4Lii4LmM4LiC4Lit4LiH4Lin4Lix4LiZ4LiX4Li14LmI4Lii4LmJ4Lit4LiZ4Lir4Lil4Lix4LiHIDcg4Lin4Lix4LiZXG4gICAgY29uc3QgZGF0ZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSA3OyBpKyspIHtcbiAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShjdXJyZW50RGF0ZSk7XG4gICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgLSBpKTtcbiAgICAgIGRhdGVzLnB1c2goZm9ybWF0KGRhdGUsICd5eXl5LU1NLWRkJykpO1xuICAgIH1cblxuICAgIC8vIOC4lOC4tuC4h+C4guC5ieC4reC4oeC4ueC4peC4geC4sOC5gOC4iuC5ieC4suC4iOC4suC4geC4l+C4seC5ieC4hyA3IOC4p+C4seC4meC4ouC5ieC4reC4meC4q+C4peC4seC4h1xuICAgIGNvbnN0IHByb21pc2VzID0gZGF0ZXMubWFwKGRhdGUgPT4gZ2V0V2FyZERhdGFCeURhdGUoZGF0ZSwgJ+C5gOC4iuC5ieC4sicsIHdhcmRJZCkpO1xuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG5cbiAgICAvLyDguIHguKPguK3guIfguYDguInguJ7guLLguLDguKfguLHguJnguJfguLXguYjguKHguLXguILguYnguK3guKHguLnguKVcbiAgICBjb25zdCB2YWxpZERhdGEgPSByZXN1bHRzLmZpbHRlcihkYXRhID0+IGRhdGEgIT09IG51bGwpO1xuXG4gICAgLy8g4LiW4LmJ4Liy4LmE4Lih4LmI4Lih4Li14LiC4LmJ4Lit4Lih4Li54Lil4LmA4Lil4LiiIOC4quC5iOC4h+C4hOC5iOC4suC4p+C5iOC4suC4h1xuICAgIGlmICh2YWxpZERhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyDguYDguKPguLXguKLguIfguKXguLPguJTguLHguJrguILguYnguK3guKHguLnguKXguJXguLLguKHguKfguLHguJnguJfguLXguYggKOC4peC5iOC4suC4quC4uOC4lOC4geC5iOC4reC4mSlcbiAgICB2YWxpZERhdGEuc29ydCgoYSwgYikgPT4gbmV3IERhdGUoYi5kYXRlKSAtIG5ldyBEYXRlKGEuZGF0ZSkpO1xuXG4gICAgLy8g4Liq4LmI4LiH4LiC4LmJ4Lit4Lih4Li54Lil4Lil4LmI4Liy4Liq4Li44LiU4LiB4Lil4Lix4Lia4LmE4LibXG4gICAgcmV0dXJuIHZhbGlkRGF0YVswXTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBsYXN0IDcgZGF5cyBkYXRhOicsIGVycm9yKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiDguJ/guLHguIfguIHguYzguIrguLHguJnguKrguLPguKvguKPguLHguJrguITguLPguJnguKfguJPguITguYjguLIgUGF0aWVudCBDZW5zdXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBmb3JtRGF0YSDguILguYnguK3guKHguLnguKXguJ/guK3guKPguYzguKFcbiAqIEByZXR1cm5zIHtzdHJpbmd8bnVtYmVyfSDguITguYjguLIgUGF0aWVudCBDZW5zdXMg4LiX4Li14LmI4LiE4Liz4LiZ4Lin4LiT4LmE4LiU4LmJIOC4q+C4o+C4t+C4rSBlbXB0eSBzdHJpbmcg4LiW4LmJ4Liy4LmE4Lih4LmI4Lih4Li14LiC4LmJ4Lit4Lih4Li54LilXG4gKi9cbmV4cG9ydCBjb25zdCBjYWxjdWxhdGVQYXRpZW50Q2Vuc3VzID0gKHBhdGllbnREYXRhKSA9PiB7XG4gIGlmICghcGF0aWVudERhdGEpIHtcbiAgICBjb25zb2xlLndhcm4oJ+C5hOC4oeC5iOC4quC4suC4oeC4suC4o+C4luC4hOC4s+C4meC4p+C4k+C5hOC4lOC5iTog4LiC4LmJ4Lit4Lih4Li54LilIHBhdGllbnREYXRhIOC5hOC4oeC5iOC4oeC4tScpO1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIC8vIOC5geC4m+C4peC4h+C4hOC5iOC4suC5gOC4m+C5h+C4meC4leC4seC4p+C5gOC4peC4giDguYHguKXguLDguYPguIrguYkgcGFyc2VJbnQg4LiU4LmJ4Lin4LiiIHJhZGl4IOC5gOC4nuC4t+C5iOC4reC4m+C5ieC4reC4h+C4geC4seC4meC4geC4suC4o+C5geC4m+C4peC4h+C4hOC5iOC4suC4l+C4teC5iOC4nOC4tOC4lOC4nuC4peC4suC4lFxuICBjb25zdCBob3NwaXRhbFBhdGllbnRjZW5zdXMgPSBwYXJzZUludChwYXRpZW50RGF0YS5ob3NwaXRhbFBhdGllbnRjZW5zdXMgfHwgJzAnLCAxMCkgfHwgMDtcbiAgY29uc3QgbmV3QWRtaXQgPSBwYXJzZUludChwYXRpZW50RGF0YS5uZXdBZG1pdCB8fCAnMCcsIDEwKSB8fCAwO1xuICBjb25zdCB0cmFuc2ZlckluID0gcGFyc2VJbnQocGF0aWVudERhdGEudHJhbnNmZXJJbiB8fCAnMCcsIDEwKSB8fCAwO1xuICBjb25zdCByZWZlckluID0gcGFyc2VJbnQocGF0aWVudERhdGEucmVmZXJJbiB8fCAnMCcsIDEwKSB8fCAwO1xuICBjb25zdCB0cmFuc2Zlck91dCA9IHBhcnNlSW50KHBhdGllbnREYXRhLnRyYW5zZmVyT3V0IHx8ICcwJywgMTApIHx8IDA7XG4gIGNvbnN0IHJlZmVyT3V0ID0gcGFyc2VJbnQocGF0aWVudERhdGEucmVmZXJPdXQgfHwgJzAnLCAxMCkgfHwgMDtcbiAgY29uc3QgZGlzY2hhcmdlID0gcGFyc2VJbnQocGF0aWVudERhdGEuZGlzY2hhcmdlIHx8ICcwJywgMTApIHx8IDA7XG4gIGNvbnN0IGRlYWQgPSBwYXJzZUludChwYXRpZW50RGF0YS5kZWFkIHx8ICcwJywgMTApIHx8IDA7XG5cbiAgLy8gRGVidWc6IOC5geC4quC4lOC4h+C4hOC5iOC4suC4l+C4teC5iOC4meC4s+C4oeC4suC4hOC4s+C4meC4p+C4k1xuICBjb25zb2xlLmxvZygnRGF0YUZldGNoZXJzIC0gUGF0aWVudCBDZW5zdXMgVmFsdWVzOicsIHtcbiAgICBob3NwaXRhbFBhdGllbnRjZW5zdXMsXG4gICAgbmV3QWRtaXQsXG4gICAgdHJhbnNmZXJJbixcbiAgICByZWZlckluLFxuICAgIHRyYW5zZmVyT3V0LFxuICAgIHJlZmVyT3V0LFxuICAgIGRpc2NoYXJnZSxcbiAgICBkZWFkXG4gIH0pO1xuXG4gIC8vIOC4hOC4s+C4meC4p+C4k+C4leC4suC4oeC4quC4ueC4leC4ozogSG9zcGl0YWwgUGF0aWVudCBDZW5zdXMgKyBOZXcgQWRtaXQgKyBUcmFuc2ZlciBJbiArIFJlZmVyIEluIC0gVHJhbnNmZXIgT3V0IC0gUmVmZXIgT3V0IC0gRGlzY2hhcmdlIC0gRGVhZFxuICBjb25zdCB0b3RhbCA9IGhvc3BpdGFsUGF0aWVudGNlbnN1cyArIG5ld0FkbWl0ICsgdHJhbnNmZXJJbiArIHJlZmVySW4gLSB0cmFuc2Zlck91dCAtIHJlZmVyT3V0IC0gZGlzY2hhcmdlIC0gZGVhZDtcbiAgXG4gIGNvbnNvbGUubG9nKGBEYXRhRmV0Y2hlcnMg4LiE4Liz4LiZ4Lin4LiTIFBhdGllbnQgQ2Vuc3VzOiAke2hvc3BpdGFsUGF0aWVudGNlbnN1c30gKyAke25ld0FkbWl0fSArICR7dHJhbnNmZXJJbn0gKyAke3JlZmVySW59IC0gJHt0cmFuc2Zlck91dH0gLSAke3JlZmVyT3V0fSAtICR7ZGlzY2hhcmdlfSAtICR7ZGVhZH0gPSAke3RvdGFsfWApO1xuICBcbiAgLy8gRGlzcGxheSBlbXB0eSBzdHJpbmcgaWYgdG90YWwgaXMgMCBhbmQgYWxsIGlucHV0IGZpZWxkcyBhcmUgZW1wdHlcbiAgY29uc3Qgc2hvdWxkU2hvd0VtcHR5ID0gdG90YWwgPT09IDAgJiYgXG4gICAgICAhcGF0aWVudERhdGEuaG9zcGl0YWxQYXRpZW50Y2Vuc3VzICYmXG4gICAgICAhcGF0aWVudERhdGEubmV3QWRtaXQgJiYgXG4gICAgICAhcGF0aWVudERhdGEudHJhbnNmZXJJbiAmJiBcbiAgICAgICFwYXRpZW50RGF0YS5yZWZlckluICYmIFxuICAgICAgIXBhdGllbnREYXRhLnRyYW5zZmVyT3V0ICYmIFxuICAgICAgIXBhdGllbnREYXRhLnJlZmVyT3V0ICYmIFxuICAgICAgIXBhdGllbnREYXRhLmRpc2NoYXJnZSAmJiBcbiAgICAgICFwYXRpZW50RGF0YS5kZWFkO1xuICBcbiAgcmV0dXJuIHNob3VsZFNob3dFbXB0eSA/ICcnIDogdG90YWwudG9TdHJpbmcoKTtcbn07XG5cbi8qKlxuICog4Lif4Lix4LiH4LiB4LmM4LiK4Lix4LiZ4Liq4Liz4Lir4Lij4Lix4Lia4LiV4Lij4Lin4LiI4Liq4Lit4Lia4Liq4LiW4Liy4LiZ4Liw4LiB4Liy4Lij4Lit4LiZ4Li44Lih4Lix4LiV4Li04LiC4Lix4LmJ4LiZ4Liq4Li44LiU4LiX4LmJ4Liy4LiiXG4gKiBAcGFyYW0ge0RhdGV9IGRhdGUg4Lin4Lix4LiZ4LiX4Li14LmI4LiV4LmJ4Lit4LiH4LiB4Liy4Lij4LiV4Lij4Lin4LiI4Liq4Lit4LiaXG4gKiBAcGFyYW0ge3N0cmluZ30gd2FyZElkIOC4o+C4q+C4seC4quC4p+C4reC4o+C5jOC4lFxuICogQHBhcmFtIHtzdHJpbmd9IHNoaWZ0IOC4geC4sOC4geC4suC4o+C4l+C4s+C4h+C4suC4mVxuICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59IHRydWUg4LiW4LmJ4Liy4LmE4LiU4LmJ4Lij4Lix4Lia4LiB4Liy4Lij4Lit4LiZ4Li44Lih4Lix4LiV4Li04LmB4Lil4LmJ4LinLCBmYWxzZSDguJbguYnguLLguKLguLHguIfguYTguKHguYjguYTguJTguYnguKPguLHguJrguIHguLLguKPguK3guJnguLjguKHguLHguJXguLRcbiAqL1xuZXhwb3J0IGNvbnN0IGNoZWNrRmluYWxBcHByb3ZhbFN0YXR1cyA9IGFzeW5jIChkYXRlLCBzaGlmdCwgd2FyZElkLCBzdXBlcnZpc29ySWQpID0+IHtcbiAgdHJ5IHtcbiAgICAvLyDguJTguLbguIfguILguYnguK3guKHguLnguKXguKfguK3guKPguYzguJRcbiAgICBjb25zdCB3YXJkRGF0YSA9IGF3YWl0IGdldFdhcmREYXRhQnlEYXRlKGRhdGUsIHNoaWZ0LCB3YXJkSWQpO1xuICAgIGlmICghd2FyZERhdGEpIHJldHVybiB7IGFwcHJvdmVkOiBmYWxzZSwgbWVzc2FnZTogJ+C5hOC4oeC5iOC4nuC4muC4guC5ieC4reC4oeC4ueC4pScgfTtcblxuICAgIC8vIOC4leC4o+C4p+C4iOC4quC4reC4muC4p+C5iOC4suC4oeC4teC4geC4suC4o+C4muC4seC4meC4l+C4tuC4geC4iOC4o+C4tOC4h+C4q+C4o+C4t+C4reC5hOC4oeC5iFxuICAgIGlmICh3YXJkRGF0YS5zdGF0dXMgIT09ICdmaW5hbCcpIHtcbiAgICAgIHJldHVybiB7IFxuICAgICAgICBhcHByb3ZlZDogZmFsc2UsIFxuICAgICAgICBtZXNzYWdlOiAn4LiC4LmJ4Lit4Lih4Li54Lil4Lii4Lix4LiH4LmE4Lih4LmI4LiW4Li54LiB4Lia4Lix4LiZ4LiX4Li24LiB4LmA4Lib4LmH4LiZ4LiJ4Lia4Lix4Lia4Liq4Lih4Lia4Li54Lij4LiT4LmMJyBcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8g4LiV4Lij4Lin4LiI4Liq4Lit4Lia4Lij4Lir4Lix4Liq4Lic4Li54LmJ4Lit4LiZ4Li44Lih4Lix4LiV4Li0XG4gICAgaWYgKHdhcmREYXRhLmFwcHJvdmVkQnkgIT09IHN1cGVydmlzb3JJZCkge1xuICAgICAgLy8g4LiU4Li24LiH4LiC4LmJ4Lit4Lih4Li54Lil4Lic4Li54LmJ4Lit4LiZ4Li44Lih4Lix4LiV4Li04LiI4Liy4LiB4LiQ4Liy4LiZ4LiC4LmJ4Lit4Lih4Li54LilXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBhcHByb3ZlckRhdGEgPSBhd2FpdCBnZXRVc2VyRGF0YUZyb21Db2xsZWN0aW9uKHdhcmREYXRhLmFwcHJvdmVkQnkpO1xuICAgICAgICBjb25zdCBhcHByb3Zlck5hbWUgPSBhcHByb3ZlckRhdGE/Lm5hbWUgfHwgJ+C5hOC4oeC5iOC4l+C4o+C4suC4muC4iuC4t+C5iOC4rSc7XG4gICAgICAgIHJldHVybiB7IFxuICAgICAgICAgIGFwcHJvdmVkOiBmYWxzZSwgXG4gICAgICAgICAgbWVzc2FnZTogYOC4reC4meC4uOC4oeC4seC4leC4tOC5geC4peC5ieC4p+C5guC4lOC4oiAke2FwcHJvdmVyTmFtZX1gIFxuICAgICAgICB9O1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHsgXG4gICAgICAgICAgYXBwcm92ZWQ6IGZhbHNlLCBcbiAgICAgICAgICBtZXNzYWdlOiAn4Lit4LiZ4Li44Lih4Lix4LiV4Li04LmB4Lil4LmJ4Lin4LmC4LiU4Lii4Lic4Li54LmJ4LmD4LiK4LmJ4LiX4LmI4Liy4LiZ4Lit4Li34LmI4LiZJyBcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyDguIHguKPguJPguLXguJfguLXguYjguK3guJnguLjguKHguLHguJXguLTguYHguKXguYnguKfguYLguJTguKLguJzguLnguYnguYPguIrguYnguITguJnguJvguLHguIjguIjguLjguJrguLHguJlcbiAgICByZXR1cm4geyBcbiAgICAgIGFwcHJvdmVkOiB0cnVlLCBcbiAgICAgIG1lc3NhZ2U6ICfguITguLjguJPguYTguJTguYnguK3guJnguLjguKHguLHguJXguLTguILguYnguK3guKHguLnguKXguJnguLXguYnguYHguKXguYnguKcnIFxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgY2hlY2tpbmcgYXBwcm92YWwgc3RhdHVzOicsIGVycm9yKTtcbiAgICByZXR1cm4geyBcbiAgICAgIGFwcHJvdmVkOiBmYWxzZSwgXG4gICAgICBtZXNzYWdlOiAn4LmA4LiB4Li04LiU4LiC4LmJ4Lit4Lic4Li04LiU4Lie4Lil4Liy4LiU4LmD4LiZ4LiB4Liy4Lij4LiV4Lij4Lin4LiI4Liq4Lit4Lia4Liq4LiW4Liy4LiZ4LiwJyBcbiAgICB9O1xuICB9XG59O1xuXG4vKipcbiAqIOC4n+C4seC4h+C4geC5jOC4iuC4seC4meC4quC4s+C4q+C4o+C4seC4muC4lOC4tuC4h+C4p+C4seC4meC4l+C4teC5iOC4l+C4teC5iOC4oeC4teC4guC5ieC4reC4oeC4ueC4peC4reC4ouC4ueC5iOC5geC4peC5ieC4p+C5g+C4meC4o+C4sOC4muC4mlxuICogQHBhcmFtIHtzdHJpbmd9IHdhcmRJZCDguKPguKvguLHguKrguKfguK3guKPguYzguJRcbiAqIEByZXR1cm5zIHtQcm9taXNlPEFycmF5PE9iamVjdD4+fSDguK3guLLguKPguYzguYDguKPguKLguYzguILguK3guIfguKfguLHguJnguJfguLXguYjguJfguLXguYjguKHguLXguILguYnguK3guKHguLnguKVcbiAqL1xuZXhwb3J0IGNvbnN0IGZldGNoRGF0ZXNXaXRoRGF0YSA9IGFzeW5jICh3YXJkSWQpID0+IHtcbiAgdHJ5IHtcbiAgICBpZiAoIXdhcmRJZCkge1xuICAgICAgY29uc29sZS5lcnJvcignZmV0Y2hEYXRlc1dpdGhEYXRhOiBNaXNzaW5nIHdhcmRJZCcpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBcbiAgICAvLyDguJTguLbguIfguILguYnguK3guKHguLnguKXguIjguLLguIHguJfguLHguYnguIcgY29sbGVjdGlvbiB3YXJkRGF0YUZpbmFsIOC5geC4peC4sCB3YXJkRGF0YURyYWZ0c1xuICAgIC8vIOC5guC4hOC5ieC4lOC4iOC4s+C4peC4reC4h+C4geC4suC4o+C4lOC4tuC4h+C4guC5ieC4reC4oeC4ueC4pVxuICAgIGNvbnN0IGRhdGVzID0gW1xuICAgICAgeyBkYXRlOiAnMjAyNS0wMy0xOCcsIHNoaWZ0czogWydNb3JuaW5nICgwNzowMC0xOTowMCknLCAnTmlnaHQgKDE5OjAwLTA3OjAwKSddIH0sXG4gICAgICB7IGRhdGU6ICcyMDI1LTAzLTE3Jywgc2hpZnRzOiBbJ01vcm5pbmcgKDA3OjAwLTE5OjAwKSddIH0sXG4gICAgICB7IGRhdGU6ICcyMDI1LTAzLTE2Jywgc2hpZnRzOiBbJ05pZ2h0ICgxOTowMC0wNzowMCknXSB9XG4gICAgXTtcbiAgICBcbiAgICByZXR1cm4gZGF0ZXM7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgZGF0ZXMgd2l0aCBkYXRhOicsIGVycm9yKTtcbiAgICByZXR1cm4gW107XG4gIH1cbn07XG5cbi8qKlxuICog4Lif4Lix4LiH4LiB4LmM4LiK4Lix4LiZ4Liq4Liz4Lir4Lij4Lix4Lia4LiU4Li24LiH4LiC4LmJ4Lit4Lih4Li54Lil4LiB4Liw4LiH4Liy4LiZ4LiB4LmI4Lit4LiZ4Lir4LiZ4LmJ4LiyXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0ZSDguKfguLHguJnguJfguLXguYhcbiAqIEBwYXJhbSB7c3RyaW5nfSB3YXJkSWQg4Lij4Lir4Lix4Liq4Lin4Lit4Lij4LmM4LiUXG4gKiBAcGFyYW0ge3N0cmluZ30gY3VycmVudFNoaWZ0IOC4geC4sOC4h+C4suC4meC4m+C4seC4iOC4iOC4uOC4muC4seC4mVxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0fG51bGw+fSDguILguYnguK3guKHguLnguKXguIHguLDguIfguLLguJnguIHguYjguK3guJnguKvguJnguYnguLIg4Lir4Lij4Li34LitIG51bGwg4LiW4LmJ4Liy4LmE4Lih4LmI4Lie4LiaXG4gKi9cbmV4cG9ydCBjb25zdCBmZXRjaFByZXZpb3VzU2hpZnREYXRhID0gYXN5bmMgKGRhdGUsIHdhcmRJZCwgY3VycmVudFNoaWZ0KSA9PiB7XG4gIHRyeSB7XG4gICAgaWYgKCFkYXRlIHx8ICF3YXJkSWQgfHwgIWN1cnJlbnRTaGlmdCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIFxuICAgIC8vIOC4geC4s+C4q+C4meC4lOC4geC4sOC4h+C4suC4meC4geC5iOC4reC4meC4q+C4meC5ieC4slxuICAgIGxldCBwcmV2aW91c1NoaWZ0O1xuICAgIGxldCBwcmV2aW91c0RhdGUgPSBuZXcgRGF0ZShkYXRlKTtcbiAgICBcbiAgICBpZiAoY3VycmVudFNoaWZ0ID09PSAnTW9ybmluZyAoMDc6MDAtMTk6MDApJykge1xuICAgICAgLy8g4LiW4LmJ4Liy4LmA4Lib4LmH4LiZ4LiB4Liw4LmA4LiK4LmJ4LiyIOC5g+C4q+C5ieC4lOC4ueC4geC4sOC4lOC4tuC4geC4guC4reC4h+C4p+C4seC4meC4geC5iOC4reC4meC4q+C4meC5ieC4slxuICAgICAgcHJldmlvdXNEYXRlLnNldERhdGUocHJldmlvdXNEYXRlLmdldERhdGUoKSAtIDEpO1xuICAgICAgcHJldmlvdXNTaGlmdCA9ICdOaWdodCAoMTk6MDAtMDc6MDApJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8g4LiW4LmJ4Liy4LmA4Lib4LmH4LiZ4LiB4Liw4LiU4Li24LiBIOC5g+C4q+C5ieC4lOC4ueC4geC4sOC5gOC4iuC5ieC4suC4guC4reC4h+C4p+C4seC4meC5gOC4lOC4teC4ouC4p+C4geC4seC4mVxuICAgICAgcHJldmlvdXNTaGlmdCA9ICdNb3JuaW5nICgwNzowMC0xOTowMCknO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBmb3JtYXR0ZWRQcmV2aW91c0RhdGUgPSBmb3JtYXQocHJldmlvdXNEYXRlLCAneXl5eS1NTS1kZCcpO1xuICAgIGNvbnN0IHByZXZpb3VzRGF0YSA9IGF3YWl0IGdldFdhcmREYXRhQnlEYXRlKGZvcm1hdHRlZFByZXZpb3VzRGF0ZSwgcHJldmlvdXNTaGlmdCwgd2FyZElkKTtcbiAgICBcbiAgICByZXR1cm4gcHJldmlvdXNEYXRhO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHByZXZpb3VzIHNoaWZ0IGRhdGE6JywgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIOC4n+C4seC4h+C4geC5jOC4iuC4seC4meC4quC4s+C4q+C4o+C4seC4muC4lOC4tuC4h+C4guC5ieC4reC4oeC4ueC4peC4geC4suC4o+C4reC4meC4uOC4oeC4seC4leC4tFxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGUg4Lin4Lix4LiZ4LiX4Li14LmIXG4gKiBAcGFyYW0ge3N0cmluZ30gd2FyZElkIOC4o+C4q+C4seC4quC4p+C4reC4o+C5jOC4lFxuICogQHBhcmFtIHtzdHJpbmd9IHNoaWZ0IOC4geC4sOC4h+C4suC4mVxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0fG51bGw+fSDguILguYnguK3guKHguLnguKXguIHguLLguKPguK3guJnguLjguKHguLHguJXguLQg4Lir4Lij4Li34LitIG51bGwg4LiW4LmJ4Liy4LmE4Lih4LmI4Lie4LiaXG4gKi9cbmV4cG9ydCBjb25zdCBmZXRjaEFwcHJvdmFsRGF0YSA9IGFzeW5jIChkYXRlLCB3YXJkSWQsIHNoaWZ0KSA9PiB7XG4gIHRyeSB7XG4gICAgaWYgKCFkYXRlIHx8ICF3YXJkSWQgfHwgIXNoaWZ0KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgZm9ybWF0dGVkRGF0ZSA9IGZvcm1hdChuZXcgRGF0ZShkYXRlKSwgJ3l5eXktTU0tZGQnKTtcbiAgICBjb25zdCB3YXJkRGF0YSA9IGF3YWl0IGdldFdhcmREYXRhQnlEYXRlKGZvcm1hdHRlZERhdGUsIHNoaWZ0LCB3YXJkSWQpO1xuICAgIFxuICAgIGlmICghd2FyZERhdGEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgc3RhdHVzOiB3YXJkRGF0YS5hcHByb3ZhbFN0YXR1cyB8fCAncGVuZGluZycsXG4gICAgICBhcHByb3ZlZEJ5OiB3YXJkRGF0YS5hcHByb3ZlZEJ5IHx8IG51bGwsXG4gICAgICBhcHByb3ZhbFRpbWVzdGFtcDogd2FyZERhdGEuYXBwcm92YWxUaW1lc3RhbXAgfHwgbnVsbCxcbiAgICAgIHJlamVjdGVkQnk6IHdhcmREYXRhLnJlamVjdGVkQnkgfHwgbnVsbCxcbiAgICAgIHJlamVjdGlvblJlYXNvbjogd2FyZERhdGEucmVqZWN0aW9uUmVhc29uIHx8IG51bGwsXG4gICAgICBjb21tZW50czogd2FyZERhdGEuYXBwcm92YWxDb21tZW50cyB8fCBudWxsXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBhcHByb3ZhbCBkYXRhOicsIGVycm9yKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiDguJ/guLHguIfguIHguYzguIrguLHguJnguKrguLPguKvguKPguLHguJrguJTguLbguIfguILguYnguK3guKHguLnguKXguKXguYjguLLguKrguLjguJRcbiAqIEBwYXJhbSB7c3RyaW5nfSB3YXJkSWQg4Lij4Lir4Lix4Liq4Lin4Lit4Lij4LmM4LiUXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3R8bnVsbD59IOC4guC5ieC4reC4oeC4ueC4peC4peC5iOC4suC4quC4uOC4lCDguKvguKPguLfguK0gbnVsbCDguJbguYnguLLguYTguKHguYjguJ7guJpcbiAqL1xuZXhwb3J0IGNvbnN0IGZldGNoTGF0ZXN0UmVjb3JkID0gYXN5bmMgKHdhcmRJZCkgPT4ge1xuICB0cnkge1xuICAgIGlmICghd2FyZElkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgXG4gICAgLy8g4LiV4Lij4Lin4LiI4Liq4Lit4Lia4Lii4LmJ4Lit4LiZ4Lir4Lil4Lix4LiH4LiI4Liy4LiB4Lin4Lix4LiZ4Lib4Lix4LiI4LiI4Li44Lia4Lix4LiZ4LmE4Lib4LiI4LiZ4LiW4Li24LiHIDMwIOC4p+C4seC4meC4geC5iOC4reC4meC4q+C4meC5ieC4slxuICAgIGNvbnN0IGN1cnJlbnREYXRlID0gbmV3IERhdGUoKTtcbiAgICBsZXQgbGF0ZXN0RGF0YSA9IG51bGw7XG4gICAgXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzMDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGVja0RhdGUgPSBuZXcgRGF0ZShjdXJyZW50RGF0ZSk7XG4gICAgICBjaGVja0RhdGUuc2V0RGF0ZShjaGVja0RhdGUuZ2V0RGF0ZSgpIC0gaSk7XG4gICAgICBcbiAgICAgIGNvbnN0IGZvcm1hdHRlZERhdGUgPSBmb3JtYXQoY2hlY2tEYXRlLCAneXl5eS1NTS1kZCcpO1xuICAgICAgXG4gICAgICAvLyDguJXguKPguKfguIjguKrguK3guJrguIHguLDguJTguLbguIHguIHguYjguK3guJkg4LmB4Lil4LmJ4Lin4LiI4Li24LiH4LiV4Lij4Lin4LiI4Liq4Lit4Lia4LiB4Liw4LmA4LiK4LmJ4LiyXG4gICAgICBjb25zdCBuaWdodERhdGEgPSBhd2FpdCBnZXRXYXJkRGF0YUJ5RGF0ZShmb3JtYXR0ZWREYXRlLCAnTmlnaHQgKDE5OjAwLTA3OjAwKScsIHdhcmRJZCk7XG4gICAgICBpZiAobmlnaHREYXRhKSB7XG4gICAgICAgIHJldHVybiBuaWdodERhdGE7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IG1vcm5pbmdEYXRhID0gYXdhaXQgZ2V0V2FyZERhdGFCeURhdGUoZm9ybWF0dGVkRGF0ZSwgJ01vcm5pbmcgKDA3OjAwLTE5OjAwKScsIHdhcmRJZCk7XG4gICAgICBpZiAobW9ybmluZ0RhdGEpIHtcbiAgICAgICAgcmV0dXJuIG1vcm5pbmdEYXRhO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBsYXRlc3QgcmVjb3JkOicsIGVycm9yKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiDguJ/guLHguIfguIHguYzguIrguLHguJnguKrguLPguKvguKPguLHguJrguJXguKPguKfguIjguKrguK3guJrguKfguYjguLLguKHguLXguILguYnguK3guKHguLnguKXguYPguJkgMzAg4Lin4Lix4LiZ4Lil4LmI4Liy4Liq4Li44LiU4Lir4Lij4Li34Lit4LmE4Lih4LmIXG4gKiBAcGFyYW0ge3N0cmluZ30gd2FyZElkIOC4o+C4q+C4seC4quC4p+C4reC4o+C5jOC4lFxuICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59IHRydWUg4LiW4LmJ4Liy4Lih4Li14LiC4LmJ4Lit4Lih4Li54Lil4LmD4LiZIDMwIOC4p+C4seC4meC4peC5iOC4suC4quC4uOC4lCwgZmFsc2Ug4LiW4LmJ4Liy4LmE4Lih4LmI4Lih4Li1XG4gKi9cbmV4cG9ydCBjb25zdCBjaGVja1Bhc3QzMERheXNSZWNvcmRzID0gYXN5bmMgKHdhcmRJZCkgPT4ge1xuICB0cnkge1xuICAgIGlmICghd2FyZElkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGxhdGVzdFJlY29yZCA9IGF3YWl0IGZldGNoTGF0ZXN0UmVjb3JkKHdhcmRJZCk7XG4gICAgcmV0dXJuIGxhdGVzdFJlY29yZCAhPT0gbnVsbDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjaGVja2luZyBwYXN0IDMwIGRheXMgcmVjb3JkczonLCBlcnJvcik7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG4vKipcbiAqIOC4n+C4seC4h+C4geC5jOC4iuC4seC4meC4quC4s+C4q+C4o+C4seC4muC4lOC4tuC4h+C4guC5ieC4reC4oeC4ueC4peC4ouC5ieC4reC4meC4q+C4peC4seC4hyBYIOC4p+C4seC4mVxuICovXG5leHBvcnQgY29uc3QgZmV0Y2hQcmV2aW91c1dhcmREYXRhID0gYXN5bmMgKGRlcGFydG1lbnQsIGN1cnJlbnREYXRlLCBkYXlzID0gNykgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBHZXR0aW5nIHByZXZpb3VzICR7ZGF5c30gZGF5cyBkYXRhIGZvciAke2RlcGFydG1lbnR9IGZyb20gJHtjdXJyZW50RGF0ZX1gKTtcbiAgICAgICAgLy8g4LmC4LiE4LmJ4LiU4LiU4Li24LiH4LiC4LmJ4Lit4Lih4Li54Lil4Lii4LmJ4Lit4LiZ4Lir4Lil4Lix4LiHLi4uXG4gICAgICAgIC8vICjguITguLHguJTguKXguK3guIHguIjguLLguIEgV2FyZEZvcm0uanMg4LmD4Liq4LmI4LiV4Lij4LiH4LiZ4Li14LmJKVxuICAgICAgICByZXR1cm4gW107XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBwcmV2aW91cyBkYXRhOicsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbn07XG5cbi8qKlxuICog4LmB4Lib4Lil4LiH4Lij4Li54Lib4LmB4Lia4Lia4Lin4Lix4LiZ4LiX4Li14LmIXG4gKi9cbmV4cG9ydCBjb25zdCBmb3JtYXREYXRlID0gKGRhdGUpID0+IHtcbiAgICBpZiAoIWRhdGUpIHJldHVybiAnJztcbiAgICBcbiAgICBjb25zdCBkID0gbmV3IERhdGUoZGF0ZSk7XG4gICAgaWYgKGlzTmFOKGQuZ2V0VGltZSgpKSkgcmV0dXJuICcnO1xuICAgIFxuICAgIHJldHVybiBmb3JtYXQoZCwgJ3l5eXktTU0tZGQnKTtcbn07XG5cbi8qKlxuICog4Lif4Lix4LiH4LiB4LmM4LiK4Lix4LiZ4Liq4Liz4Lir4Lij4Lix4Lia4LiU4Li24LiH4LiC4LmJ4Lit4Lih4Li54Lil4LmB4Lil4Liw4LiI4Lix4LiU4LiB4Liy4Lij4LiB4Liy4Lij4LmC4Lir4Lil4LiU4LiC4LmJ4Lit4Lih4Li54Lil4Lit4Lix4LiV4LmC4LiZ4Lih4Lix4LiV4Li04LiV4Liy4Lih4LiB4LiwXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0ZSDguKfguLHguJnguJfguLXguYhcbiAqIEBwYXJhbSB7c3RyaW5nfSB3YXJkSWQg4Lij4Lir4Lix4Liq4Lin4Lit4Lij4LmM4LiUXG4gKiBAcGFyYW0ge3N0cmluZ30gc2hpZnQg4LiB4Liw4LiH4Liy4LiZXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSDguILguYnguK3guKHguLnguKXguJfguLXguYjguYLguKvguKXguJQg4Lie4Lij4LmJ4Lit4Lih4Liq4LiW4Liy4LiZ4LiwXG4gKi9cbmV4cG9ydCBjb25zdCBmZXRjaEFuZFByZXBhcmVXYXJkRGF0YSA9IGFzeW5jIChkYXRlLCB3YXJkSWQsIHNoaWZ0KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5sb2coYEZldGNoaW5nIGFuZCBwcmVwYXJpbmcgZGF0YSBmb3IgJHtkYXRlfSwgJHt3YXJkSWR9LCAke3NoaWZ0fWApO1xuICAgICAgICBcbiAgICAgICAgLy8g4LiU4Li24LiH4LiC4LmJ4Lit4Lih4Li54Lil4LiC4Lit4LiH4LiB4Liw4Lib4Lix4LiI4LiI4Li44Lia4Lix4LiZXG4gICAgICAgIGNvbnN0IHdhcmREYXRhID0gYXdhaXQgZmV0Y2hXYXJkRGF0YShkYXRlLCB3YXJkSWQsIHNoaWZ0KTtcbiAgICAgICAgbGV0IHBhdGllbnRDZW5zdXNUb3RhbCA9IDA7XG4gICAgICAgIGxldCBzb3VyY2VNZXNzYWdlID0gJyc7XG4gICAgICAgIFxuICAgICAgICAvLyDguJXguKPguKfguIjguKrguK3guJrguKfguYjguLLguKHguLXguILguYnguK3guKHguLnguKXguKvguKPguLfguK3guYTguKHguYhcbiAgICAgICAgaWYgKHdhcmREYXRhKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRm91bmQgZXhpc3RpbmcgZGF0YSBmb3IgdGhpcyBzaGlmdCcpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyDguITguLPguJnguKfguJMgUGF0aWVudCBDZW5zdXMg4LiW4LmJ4Liy4Lih4Li14LiC4LmJ4Lit4Lih4Li54LilXG4gICAgICAgICAgICBpZiAod2FyZERhdGEucGF0aWVudENlbnN1cykge1xuICAgICAgICAgICAgICAgIHBhdGllbnRDZW5zdXNUb3RhbCA9IGNhbGN1bGF0ZVBhdGllbnRDZW5zdXMod2FyZERhdGEucGF0aWVudENlbnN1cyk7XG4gICAgICAgICAgICAgICAgc291cmNlTWVzc2FnZSA9ICfguILguYnguK3guKHguLnguKXguJzguLnguYnguJvguYjguKfguKLguITguLPguJnguKfguJPguIjguLLguIHguILguYnguK3guKHguLnguKXguYPguJnguKPguLDguJrguJonO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGE6IHdhcmREYXRhLFxuICAgICAgICAgICAgICAgIGhhc0RhdGE6IHRydWUsXG4gICAgICAgICAgICAgICAgcGF0aWVudENlbnN1c1RvdGFsLFxuICAgICAgICAgICAgICAgIHNvdXJjZU1lc3NhZ2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIOC4luC5ieC4suC5hOC4oeC5iOC4oeC4teC4guC5ieC4reC4oeC4ueC4pSDguIjguLDguJTguLbguIfguILguYnguK3guKHguLnguKXguJXguLLguKHguIHguI7guJfguLXguYjguIHguLPguKvguJnguJRcbiAgICAgICAgaWYgKHNoaWZ0ID09PSAnTW9ybmluZyAoMDc6MDAtMTk6MDApJykge1xuICAgICAgICAgICAgLy8g4LiB4Lij4LiT4Li14LiB4Liw4LmA4LiK4LmJ4LiyOiDguJTguLbguIfguILguYnguK3guKHguLnguKXguKLguYnguK3guJnguKvguKXguLHguIcgNyDguKfguLHguJlcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzRGF0ZSA9IG5ldyBEYXRlKGRhdGUpO1xuICAgICAgICAgICAgcHJldmlvdXNEYXRlLnNldERhdGUocHJldmlvdXNEYXRlLmdldERhdGUoKSAtIDcpO1xuICAgICAgICAgICAgY29uc3QgZm9ybWF0dGVkUHJldmlvdXNEYXRlID0gZm9ybWF0KHByZXZpb3VzRGF0ZSwgJ3l5eXktTU0tZGQnKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc29sZS5sb2coJ05vIGRhdGEgZm91bmQgZm9yIG1vcm5pbmcgc2hpZnQsIGNoZWNraW5nIGRhdGEgZnJvbSA3IGRheXMgYWdvOicsIGZvcm1hdHRlZFByZXZpb3VzRGF0ZSk7XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91c0RhdGEgPSBhd2FpdCBmZXRjaFdhcmREYXRhKGZvcm1hdHRlZFByZXZpb3VzRGF0ZSwgd2FyZElkLCBzaGlmdCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChwcmV2aW91c0RhdGEpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnRm91bmQgcHJldmlvdXMgZGF0YSBmcm9tIDcgZGF5cyBhZ28nKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyDguITguLPguJnguKfguJMgUGF0aWVudCBDZW5zdXMg4LiW4LmJ4Liy4Lih4Li14LiC4LmJ4Lit4Lih4Li54LilXG4gICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzRGF0YS5wYXRpZW50Q2Vuc3VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGllbnRDZW5zdXNUb3RhbCA9IGNhbGN1bGF0ZVBhdGllbnRDZW5zdXMocHJldmlvdXNEYXRhLnBhdGllbnRDZW5zdXMpO1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2VNZXNzYWdlID0gJ+C4guC5ieC4reC4oeC4ueC4peC4nOC4ueC5ieC4m+C5iOC4p+C4ouC4hOC4s+C4meC4p+C4k+C4iOC4suC4geC4guC5ieC4reC4oeC4ueC4pSA3IOC4p+C4seC4meC4geC5iOC4reC4mSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIOC4quC4o+C5ieC4suC4h+C4guC5ieC4reC4oeC4ueC4peC5g+C4q+C4oeC5iOC5guC4lOC4ouC5g+C4iuC5ieC4guC5ieC4reC4oeC4ueC4peC5gOC4lOC4tOC4oeC5geC4leC5iOC5hOC4oeC5iOC5gOC4reC4siBJRCDguYHguKXguLDguILguYnguK3guKHguLnguKXguYDguInguJ7guLLguLDguK3guLfguYjguJnguYZcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdEYXRhID0geyAuLi5wcmV2aW91c0RhdGEgfTtcbiAgICAgICAgICAgICAgICBkZWxldGUgbmV3RGF0YS5pZDtcbiAgICAgICAgICAgICAgICBkZWxldGUgbmV3RGF0YS50aW1lc3RhbXA7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG5ld0RhdGEuY3JlYXRlZEF0O1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBuZXdEYXRhLnVwZGF0ZWRBdDtcbiAgICAgICAgICAgICAgICBkZWxldGUgbmV3RGF0YS5hcHByb3ZhbFN0YXR1cztcbiAgICAgICAgICAgICAgICBkZWxldGUgbmV3RGF0YS5hcHByb3ZlZEJ5O1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBuZXdEYXRhLmFwcHJvdmFsVGltZXN0YW1wO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIOC4reC4seC4m+C5gOC4lOC4leC4hOC5iOC4siBQYXRpZW50IENlbnN1c1xuICAgICAgICAgICAgICAgIGlmIChuZXdEYXRhLnBhdGllbnRDZW5zdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3RGF0YS5wYXRpZW50Q2Vuc3VzLnRvdGFsID0gcGF0aWVudENlbnN1c1RvdGFsLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IG5ld0RhdGEsXG4gICAgICAgICAgICAgICAgICAgIGhhc0RhdGE6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHBhdGllbnRDZW5zdXNUb3RhbCxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlTWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgaXNBdXRvRmlsbGVkRnJvbUhpc3Rvcnk6IHRydWVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHNoaWZ0ID09PSAnTmlnaHQgKDE5OjAwLTA3OjAwKScpIHtcbiAgICAgICAgICAgIC8vIOC4geC4o+C4k+C4teC4geC4sOC4lOC4tuC4gTog4LiU4Li24LiH4LiC4LmJ4Lit4Lih4Li54Lil4LiI4Liy4LiB4LiB4Liw4LmA4LiK4LmJ4Liy4LiC4Lit4LiH4Lin4Lix4LiZ4LmA4LiU4Li14Lii4Lin4LiB4Lix4LiZXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnTm8gZGF0YSBmb3VuZCBmb3IgbmlnaHQgc2hpZnQsIGNoZWNraW5nIG1vcm5pbmcgc2hpZnQgZnJvbSBzYW1lIGRheScpO1xuICAgICAgICAgICAgY29uc3QgbW9ybmluZ0RhdGEgPSBhd2FpdCBmZXRjaFdhcmREYXRhKGRhdGUsIHdhcmRJZCwgJ01vcm5pbmcgKDA3OjAwLTE5OjAwKScpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAobW9ybmluZ0RhdGEpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnRm91bmQgbW9ybmluZyBzaGlmdCBkYXRhIGZyb20gc2FtZSBkYXknKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyDguITguLPguJnguKfguJMgUGF0aWVudCBDZW5zdXMg4LiW4LmJ4Liy4Lih4Li14LiC4LmJ4Lit4Lih4Li54LilXG4gICAgICAgICAgICAgICAgaWYgKG1vcm5pbmdEYXRhLnBhdGllbnRDZW5zdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aWVudENlbnN1c1RvdGFsID0gY2FsY3VsYXRlUGF0aWVudENlbnN1cyhtb3JuaW5nRGF0YS5wYXRpZW50Q2Vuc3VzKTtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlTWVzc2FnZSA9ICfguILguYnguK3guKHguLnguKXguJzguLnguYnguJvguYjguKfguKLguITguLPguJnguKfguJPguIjguLLguIHguILguYnguK3guKHguLnguKXguIHguLDguYDguIrguYnguLInO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyDguKrguKPguYnguLLguIfguILguYnguK3guKHguLnguKXguYPguKvguKHguYjguYLguJTguKLguYPguIrguYnguILguYnguK3guKHguLnguKXguIjguLLguIHguIHguLDguYDguIrguYnguLJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdEYXRhID0geyAuLi5tb3JuaW5nRGF0YSB9O1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBuZXdEYXRhLmlkO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBuZXdEYXRhLnRpbWVzdGFtcDtcbiAgICAgICAgICAgICAgICBkZWxldGUgbmV3RGF0YS5jcmVhdGVkQXQ7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG5ld0RhdGEudXBkYXRlZEF0O1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBuZXdEYXRhLmFwcHJvdmFsU3RhdHVzO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBuZXdEYXRhLmFwcHJvdmVkQnk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG5ld0RhdGEuYXBwcm92YWxUaW1lc3RhbXA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8g4Lit4Lix4Lib4LmA4LiU4LiV4LiE4LmI4LiyIFBhdGllbnQgQ2Vuc3VzIOC5geC4peC4sCBPdmVyYWxsIERhdGEgKOC4quC4s+C4q+C4o+C4seC4muC4geC4sOC4lOC4tuC4gSlcbiAgICAgICAgICAgICAgICBpZiAobmV3RGF0YS5wYXRpZW50Q2Vuc3VzKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0RhdGEucGF0aWVudENlbnN1cy50b3RhbCA9IHBhdGllbnRDZW5zdXNUb3RhbC50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXdEYXRhLm92ZXJhbGxEYXRhID0gcGF0aWVudENlbnN1c1RvdGFsLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogbmV3RGF0YSxcbiAgICAgICAgICAgICAgICAgICAgaGFzRGF0YTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aWVudENlbnN1c1RvdGFsLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2VNZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICBpc0F1dG9GaWxsZWRGcm9tSGlzdG9yeTogdHJ1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIOC4luC5ieC4suC5hOC4oeC5iOC4oeC4teC4guC5ieC4reC4oeC4ueC4peC5g+C4lOC5hiDguYPguKvguYnguKrguKPguYnguLLguIfguILguYnguK3guKHguLnguKXguYDguJvguKXguYjguLJcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICBoYXNEYXRhOiBmYWxzZSxcbiAgICAgICAgICAgIHBhdGllbnRDZW5zdXNUb3RhbDogMCxcbiAgICAgICAgICAgIHNvdXJjZU1lc3NhZ2U6ICfguYTguKHguYjguJ7guJrguILguYnguK3guKHguLnguKXguIHguYjguK3guJnguKvguJnguYnguLInXG4gICAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgYW5kIHByZXBhcmluZyB3YXJkIGRhdGE6JywgZXJyb3IpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgIGhhc0RhdGE6IGZhbHNlLFxuICAgICAgICAgICAgcGF0aWVudENlbnN1c1RvdGFsOiAwLFxuICAgICAgICAgICAgc291cmNlTWVzc2FnZTogJ+C5gOC4geC4tOC4lOC4guC5ieC4reC4nOC4tOC4lOC4nuC4peC4suC4lOC5g+C4meC4geC4suC4o+C5guC4q+C4peC4lOC4guC5ieC4reC4oeC4ueC4pScsXG4gICAgICAgICAgICBlcnJvcjogZXJyb3IubWVzc2FnZVxuICAgICAgICB9O1xuICAgIH1cbn07Il0sIm5hbWVzIjpbImdldFVzZXJEYXRhRnJvbUNvbGxlY3Rpb24iLCJnZXRXYXJkRGF0YUJ5RGF0ZSIsImNoZWNrTGFzdDdEYXlzRGF0YSIsImdldFN1YmNvbGxlY3Rpb24iLCJnZXREb2N1bWVudEJ5SWQiLCJmb3JtYXQiLCJkYiIsImNvbGxlY3Rpb24iLCJxdWVyeSIsIndoZXJlIiwiZ2V0RG9jcyIsImRvYyIsImdldERvYyIsIm9yZGVyQnkiLCJsaW1pdCIsImNoZWNrQXBwcm92YWxTdGF0dXMiLCJkYXRlIiwic2hpZnQiLCJ3YXJkSWQiLCJmb3JtYXR0ZWREYXRlIiwiRGF0ZSIsIndhcmREYXRhIiwic3RhdHVzIiwibWVzc2FnZSIsImFwcHJvdmFsU3RhdHVzIiwidGltZXN0YW1wIiwiYXBwcm92YWxUaW1lc3RhbXAiLCJhcHByb3ZlZEJ5IiwicmVqZWN0ZWRCeSIsInJlamVjdGlvblJlYXNvbiIsImVycm9yIiwiY29uc29sZSIsImZldGNoV2FyZERhdGEiLCJsb2ciLCJkb2NJZCIsImRvY1JlZiIsImRvY1NuYXAiLCJleGlzdHMiLCJkYXRhIiwiZHJhZnRzUmVmIiwiZHJhZnRzUXVlcnkiLCJkcmFmdHNTbmFwIiwiZW1wdHkiLCJkcmFmdHMiLCJmb3JFYWNoIiwicHVzaCIsImlkIiwic29ydCIsImEiLCJiIiwiY2hlY2tNb3JuaW5nU2hpZnREYXRhRXhpc3RzIiwibW9ybmluZ0RhdGEiLCJmZXRjaExhc3Q3RGF5c0RhdGEiLCJjdXJyZW50RGF0ZSIsImRhdGVzIiwiaSIsInNldERhdGUiLCJnZXREYXRlIiwicHJvbWlzZXMiLCJtYXAiLCJyZXN1bHRzIiwiUHJvbWlzZSIsImFsbCIsInZhbGlkRGF0YSIsImZpbHRlciIsImxlbmd0aCIsImNhbGN1bGF0ZVBhdGllbnRDZW5zdXMiLCJwYXRpZW50RGF0YSIsIndhcm4iLCJob3NwaXRhbFBhdGllbnRjZW5zdXMiLCJwYXJzZUludCIsIm5ld0FkbWl0IiwidHJhbnNmZXJJbiIsInJlZmVySW4iLCJ0cmFuc2Zlck91dCIsInJlZmVyT3V0IiwiZGlzY2hhcmdlIiwiZGVhZCIsInRvdGFsIiwic2hvdWxkU2hvd0VtcHR5IiwidG9TdHJpbmciLCJjaGVja0ZpbmFsQXBwcm92YWxTdGF0dXMiLCJzdXBlcnZpc29ySWQiLCJhcHByb3ZlZCIsImFwcHJvdmVyRGF0YSIsImFwcHJvdmVyTmFtZSIsIm5hbWUiLCJmZXRjaERhdGVzV2l0aERhdGEiLCJzaGlmdHMiLCJmZXRjaFByZXZpb3VzU2hpZnREYXRhIiwiY3VycmVudFNoaWZ0IiwicHJldmlvdXNTaGlmdCIsInByZXZpb3VzRGF0ZSIsImZvcm1hdHRlZFByZXZpb3VzRGF0ZSIsInByZXZpb3VzRGF0YSIsImZldGNoQXBwcm92YWxEYXRhIiwiY29tbWVudHMiLCJhcHByb3ZhbENvbW1lbnRzIiwiZmV0Y2hMYXRlc3RSZWNvcmQiLCJsYXRlc3REYXRhIiwiY2hlY2tEYXRlIiwibmlnaHREYXRhIiwiY2hlY2tQYXN0MzBEYXlzUmVjb3JkcyIsImxhdGVzdFJlY29yZCIsImZldGNoUHJldmlvdXNXYXJkRGF0YSIsImRlcGFydG1lbnQiLCJkYXlzIiwiZm9ybWF0RGF0ZSIsImQiLCJpc05hTiIsImdldFRpbWUiLCJmZXRjaEFuZFByZXBhcmVXYXJkRGF0YSIsInBhdGllbnRDZW5zdXNUb3RhbCIsInNvdXJjZU1lc3NhZ2UiLCJwYXRpZW50Q2Vuc3VzIiwiaGFzRGF0YSIsIm5ld0RhdGEiLCJjcmVhdGVkQXQiLCJ1cGRhdGVkQXQiLCJpc0F1dG9GaWxsZWRGcm9tSGlzdG9yeSIsIm92ZXJhbGxEYXRhIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/components/forms/WardForm/DataFetchers.js\n"));

/***/ })

});
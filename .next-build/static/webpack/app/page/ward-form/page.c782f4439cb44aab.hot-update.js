"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page/ward-form/page",{

/***/ "(app-pages-browser)/./app/components/forms/WardForm/DataFetchers.js":
/*!*******************************************************!*\
  !*** ./app/components/forms/WardForm/DataFetchers.js ***!
  \*******************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculatePatientCensus: () => (/* binding */ calculatePatientCensus),\n/* harmony export */   checkApprovalStatus: () => (/* binding */ checkApprovalStatus),\n/* harmony export */   checkFinalApprovalStatus: () => (/* binding */ checkFinalApprovalStatus),\n/* harmony export */   checkMorningShiftDataExists: () => (/* binding */ checkMorningShiftDataExists),\n/* harmony export */   checkPast30DaysRecords: () => (/* binding */ checkPast30DaysRecords),\n/* harmony export */   fetchAndPrepareWardData: () => (/* binding */ fetchAndPrepareWardData),\n/* harmony export */   fetchApprovalData: () => (/* binding */ fetchApprovalData),\n/* harmony export */   fetchDatesWithData: () => (/* binding */ fetchDatesWithData),\n/* harmony export */   fetchLast7DaysData: () => (/* binding */ fetchLast7DaysData),\n/* harmony export */   fetchLatestRecord: () => (/* binding */ fetchLatestRecord),\n/* harmony export */   fetchPreviousShiftData: () => (/* binding */ fetchPreviousShiftData),\n/* harmony export */   fetchPreviousWardData: () => (/* binding */ fetchPreviousWardData),\n/* harmony export */   fetchWardData: () => (/* binding */ fetchWardData),\n/* harmony export */   formatDate: () => (/* binding */ formatDate)\n/* harmony export */ });\n/* harmony import */ var _lib_dataAccess__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../lib/dataAccess */ \"(app-pages-browser)/./app/lib/dataAccess.js\");\n/* harmony import */ var _lib_firebase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../lib/firebase */ \"(app-pages-browser)/./app/lib/firebase.js\");\n/* harmony import */ var _barrel_optimize_names_format_date_fns__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! __barrel_optimize__?names=format!=!date-fns */ \"(app-pages-browser)/./node_modules/date-fns/esm/format/index.js\");\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! firebase/firestore */ \"(app-pages-browser)/./node_modules/firebase/firestore/dist/esm/index.esm.js\");\n/* __next_internal_client_entry_do_not_use__ checkApprovalStatus,fetchWardData,checkMorningShiftDataExists,fetchLast7DaysData,calculatePatientCensus,checkFinalApprovalStatus,fetchDatesWithData,fetchPreviousShiftData,fetchApprovalData,fetchLatestRecord,checkPast30DaysRecords,fetchPreviousWardData,formatDate,fetchAndPrepareWardData auto */ \n\n\n\n\n/**\n * ฟังก์ชันสำหรับตรวจสอบการอนุมัติ\n * @param {string} date วันที่ตรวจสอบ\n * @param {string} shift กะงานที่ตรวจสอบ\n * @param {string} wardId รหัสวอร์ด\n * @returns {Promise<Object>} สถานะการอนุมัติ\n */ const checkApprovalStatus = async (date, shift, wardId)=>{\n    try {\n        const formattedDate = (0,_barrel_optimize_names_format_date_fns__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(new Date(date), 'yyyy-MM-dd');\n        // ตรวจสอบข้อมูลในฐานข้อมูล\n        const wardData = await (0,_lib_dataAccess__WEBPACK_IMPORTED_MODULE_0__.getWardDataByDate)(formattedDate, shift, wardId);\n        if (!wardData) {\n            return {\n                status: 'not_submitted',\n                message: 'ยังไม่ได้บันทึกข้อมูล'\n            };\n        }\n        if (wardData.approvalStatus === 'approved') {\n            return {\n                status: 'approved',\n                message: 'ได้รับการอนุมัติแล้ว',\n                timestamp: wardData.approvalTimestamp,\n                approvedBy: wardData.approvedBy\n            };\n        }\n        if (wardData.approvalStatus === 'rejected') {\n            return {\n                status: 'rejected',\n                message: 'ถูกปฏิเสธการอนุมัติ',\n                timestamp: wardData.approvalTimestamp,\n                rejectedBy: wardData.rejectedBy,\n                rejectionReason: wardData.rejectionReason\n            };\n        }\n        return {\n            status: 'pending',\n            message: 'รอการอนุมัติ'\n        };\n    } catch (error) {\n        console.error('Error checking approval status:', error);\n        return {\n            status: 'error',\n            message: 'เกิดข้อผิดพลาดในการตรวจสอบ'\n        };\n    }\n};\n/**\n * ฟังก์ชันสำหรับดึงข้อมูลวอร์ด\n * @param {string} date วันที่ต้องการดึงข้อมูล\n * @param {string} wardId รหัสวอร์ด\n * @param {string} shift กะงาน\n * @returns {Promise<Object|null>} ข้อมูลวอร์ดหรือ null ถ้าไม่พบ\n */ const fetchWardData = async (date, wardId, shift)=>{\n    try {\n        console.log('Fetching ward data:', {\n            date,\n            wardId,\n            shift\n        });\n        const formattedDate = (0,_barrel_optimize_names_format_date_fns__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(new Date(date), 'yyyy-MM-dd');\n        const docId = \"\".concat(formattedDate, \"_\").concat(wardId, \"_\").concat(shift);\n        // ลองดึงข้อมูลจาก wardDataFinal ก่อน\n        const docRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.doc)(_lib_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'wardDataFinal', docId);\n        const docSnap = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getDoc)(docRef);\n        if (docSnap.exists()) {\n            console.log('Found data in wardDataFinal');\n            return docSnap.data();\n        }\n        // ถ้าไม่มีข้อมูลใน wardDataFinal ให้ลองดึงข้อมูลร่าง\n        const draftsRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.collection)(_lib_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'wardDataDrafts');\n        const draftsQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.query)(draftsRef, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.where)('date', '==', formattedDate), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.where)('wardId', '==', wardId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.where)('shift', '==', shift));\n        const draftsSnap = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getDocs)(draftsQuery);\n        if (!draftsSnap.empty) {\n            console.log('Found data in wardDataDrafts');\n            // เรียงลำดับตาม timestamp เพื่อเอาร่างล่าสุด\n            const drafts = [];\n            draftsSnap.forEach((doc)=>{\n                drafts.push({\n                    id: doc.id,\n                    ...doc.data()\n                });\n            });\n            drafts.sort((a, b)=>new Date(b.timestamp) - new Date(a.timestamp));\n            return drafts[0];\n        }\n        console.log('No data found for this date/shift');\n        return null;\n    } catch (error) {\n        console.error('Error fetching ward data:', error);\n        throw error;\n    }\n};\n/**\n * ฟังก์ชันสำหรับตรวจสอบว่ามีข้อมูลกะเช้าหรือไม่\n * @param {Date} date วันที่ต้องการตรวจสอบ\n * @param {string} wardId รหัสวอร์ด\n * @returns {Promise<boolean>} true ถ้ามีข้อมูลกะเช้า, false ถ้าไม่มี\n */ const checkMorningShiftDataExists = async (date, wardId)=>{\n    try {\n        const formattedDate = (0,_barrel_optimize_names_format_date_fns__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(new Date(date), 'yyyy-MM-dd');\n        const morningData = await (0,_lib_dataAccess__WEBPACK_IMPORTED_MODULE_0__.getWardDataByDate)(formattedDate, 'เช้า', wardId);\n        return morningData ? true : false;\n    } catch (error) {\n        console.error('Error checking morning shift data:', error);\n        return false;\n    }\n};\n/**\n * ฟังก์ชันสำหรับดึงข้อมูล 7 วันย้อนหลัง\n * @param {string} wardId รหัส ward\n * @param {Date} currentDate วันที่ปัจจุบัน (optional)\n * @returns {Promise<Object|null>} ข้อมูลล่าสุดภายใน 7 วันย้อนหลัง หรือ null ถ้าไม่พบข้อมูล\n */ const fetchLast7DaysData = async (currentDate, wardId)=>{\n    try {\n        // สร้างอาร์เรย์ของวันที่ย้อนหลัง 7 วัน\n        const dates = [];\n        for(let i = 1; i <= 7; i++){\n            const date = new Date(currentDate);\n            date.setDate(date.getDate() - i);\n            dates.push((0,_barrel_optimize_names_format_date_fns__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(date, 'yyyy-MM-dd'));\n        }\n        // ดึงข้อมูลกะเช้าจากทั้ง 7 วันย้อนหลัง\n        const promises = dates.map((date)=>(0,_lib_dataAccess__WEBPACK_IMPORTED_MODULE_0__.getWardDataByDate)(date, 'เช้า', wardId));\n        const results = await Promise.all(promises);\n        // กรองเฉพาะวันที่มีข้อมูล\n        const validData = results.filter((data)=>data !== null);\n        // ถ้าไม่มีข้อมูลเลย ส่งค่าว่าง\n        if (validData.length === 0) {\n            return null;\n        }\n        // เรียงลำดับข้อมูลตามวันที่ (ล่าสุดก่อน)\n        validData.sort((a, b)=>new Date(b.date) - new Date(a.date));\n        // ส่งข้อมูลล่าสุดกลับไป\n        return validData[0];\n    } catch (error) {\n        console.error('Error fetching last 7 days data:', error);\n        return null;\n    }\n};\n/**\n * ฟังก์ชันสำหรับคำนวณค่า Patient Census\n * @param {Object} formData ข้อมูลฟอร์ม\n * @returns {string|number} ค่า Patient Census ที่คำนวณได้ หรือ empty string ถ้าไม่มีข้อมูล\n */ const calculatePatientCensus = (patientData)=>{\n    if (!patientData) {\n        console.warn('ไม่มีข้อมูลผู้ป่วยสำหรับการคำนวณ Patient Census');\n        return 0;\n    }\n    // แปลงค่าเป็นตัวเลข และใช้ Number() เพื่อป้องกันการเกิด string concatenation\n    const hospitalPatientcensus = Number(parseInt(patientData.hospitalPatientcensus || '0', 10));\n    const newAdmit = Number(parseInt(patientData.newAdmit || '0', 10));\n    const transferIn = Number(parseInt(patientData.transferIn || '0', 10));\n    const referIn = Number(parseInt(patientData.referIn || '0', 10));\n    const transferOut = Number(parseInt(patientData.transferOut || '0', 10));\n    const referOut = Number(parseInt(patientData.referOut || '0', 10));\n    const discharge = Number(parseInt(patientData.discharge || '0', 10));\n    const dead = Number(parseInt(patientData.dead || '0', 10));\n    // คำนวณตามสูตร: Hospital Patient Census + New Admit + Transfer In + Refer In - Transfer Out - Refer Out - Discharge - Dead\n    const total = hospitalPatientcensus + newAdmit + transferIn + referIn - transferOut - referOut - discharge - dead;\n    console.log(\"คำนวณ Patient Census: \".concat(hospitalPatientcensus, \" + \").concat(newAdmit, \" + \").concat(transferIn, \" + \").concat(referIn, \" - \").concat(transferOut, \" - \").concat(referOut, \" - \").concat(discharge, \" - \").concat(dead, \" = \").concat(total));\n    // Check if we should show empty string (when total is 0 and all input fields are empty)\n    const shouldShowEmpty = total === 0 && !patientData.hospitalPatientcensus && !patientData.newAdmit && !patientData.transferIn && !patientData.referIn && !patientData.transferOut && !patientData.referOut && !patientData.discharge && !patientData.dead;\n    return shouldShowEmpty ? '' : total;\n};\n/**\n * ฟังก์ชันสำหรับตรวจสอบสถานะการอนุมัติขั้นสุดท้าย\n * @param {Date} date วันที่ต้องการตรวจสอบ\n * @param {string} wardId รหัสวอร์ด\n * @param {string} shift กะการทำงาน\n * @returns {Promise<boolean>} true ถ้าได้รับการอนุมัติแล้ว, false ถ้ายังไม่ได้รับการอนุมัติ\n */ const checkFinalApprovalStatus = async (date, shift, wardId, supervisorId)=>{\n    try {\n        // ดึงข้อมูลวอร์ด\n        const wardData = await (0,_lib_dataAccess__WEBPACK_IMPORTED_MODULE_0__.getWardDataByDate)(date, shift, wardId);\n        if (!wardData) return {\n            approved: false,\n            message: 'ไม่พบข้อมูล'\n        };\n        // ตรวจสอบว่ามีการบันทึกจริงหรือไม่\n        if (wardData.status !== 'final') {\n            return {\n                approved: false,\n                message: 'ข้อมูลยังไม่ถูกบันทึกเป็นฉบับสมบูรณ์'\n            };\n        }\n        // ตรวจสอบรหัสผู้อนุมัติ\n        if (wardData.approvedBy !== supervisorId) {\n            // ดึงข้อมูลผู้อนุมัติจากฐานข้อมูล\n            try {\n                const approverData = await (0,_lib_dataAccess__WEBPACK_IMPORTED_MODULE_0__.getUserDataFromCollection)(wardData.approvedBy);\n                const approverName = (approverData === null || approverData === void 0 ? void 0 : approverData.name) || 'ไม่ทราบชื่อ';\n                return {\n                    approved: false,\n                    message: \"อนุมัติแล้วโดย \".concat(approverName)\n                };\n            } catch (error) {\n                return {\n                    approved: false,\n                    message: 'อนุมัติแล้วโดยผู้ใช้ท่านอื่น'\n                };\n            }\n        }\n        // กรณีที่อนุมัติแล้วโดยผู้ใช้คนปัจจุบัน\n        return {\n            approved: true,\n            message: 'คุณได้อนุมัติข้อมูลนี้แล้ว'\n        };\n    } catch (error) {\n        console.error('Error checking approval status:', error);\n        return {\n            approved: false,\n            message: 'เกิดข้อผิดพลาดในการตรวจสอบสถานะ'\n        };\n    }\n};\n/**\n * ฟังก์ชันสำหรับดึงวันที่ที่มีข้อมูลอยู่แล้วในระบบ\n * @param {string} wardId รหัสวอร์ด\n * @returns {Promise<Array<Object>>} อาร์เรย์ของวันที่ที่มีข้อมูล\n */ const fetchDatesWithData = async (wardId)=>{\n    try {\n        if (!wardId) {\n            console.error('fetchDatesWithData: Missing wardId');\n            return [];\n        }\n        // ดึงข้อมูลจากทั้ง collection wardDataFinal และ wardDataDrafts\n        // โค้ดจำลองการดึงข้อมูล\n        const dates = [\n            {\n                date: '2025-03-18',\n                shifts: [\n                    'Morning (07:00-19:00)',\n                    'Night (19:00-07:00)'\n                ]\n            },\n            {\n                date: '2025-03-17',\n                shifts: [\n                    'Morning (07:00-19:00)'\n                ]\n            },\n            {\n                date: '2025-03-16',\n                shifts: [\n                    'Night (19:00-07:00)'\n                ]\n            }\n        ];\n        return dates;\n    } catch (error) {\n        console.error('Error fetching dates with data:', error);\n        return [];\n    }\n};\n/**\n * ฟังก์ชันสำหรับดึงข้อมูลกะงานก่อนหน้า\n * @param {string} date วันที่\n * @param {string} wardId รหัสวอร์ด\n * @param {string} currentShift กะงานปัจจุบัน\n * @returns {Promise<Object|null>} ข้อมูลกะงานก่อนหน้า หรือ null ถ้าไม่พบ\n */ const fetchPreviousShiftData = async (date, wardId, currentShift)=>{\n    try {\n        if (!date || !wardId || !currentShift) {\n            return null;\n        }\n        // กำหนดกะงานก่อนหน้า\n        let previousShift;\n        let previousDate = new Date(date);\n        if (currentShift === 'Morning (07:00-19:00)') {\n            // ถ้าเป็นกะเช้า ให้ดูกะดึกของวันก่อนหน้า\n            previousDate.setDate(previousDate.getDate() - 1);\n            previousShift = 'Night (19:00-07:00)';\n        } else {\n            // ถ้าเป็นกะดึก ให้ดูกะเช้าของวันเดียวกัน\n            previousShift = 'Morning (07:00-19:00)';\n        }\n        const formattedPreviousDate = (0,_barrel_optimize_names_format_date_fns__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(previousDate, 'yyyy-MM-dd');\n        const previousData = await (0,_lib_dataAccess__WEBPACK_IMPORTED_MODULE_0__.getWardDataByDate)(formattedPreviousDate, previousShift, wardId);\n        return previousData;\n    } catch (error) {\n        console.error('Error fetching previous shift data:', error);\n        return null;\n    }\n};\n/**\n * ฟังก์ชันสำหรับดึงข้อมูลการอนุมัติ\n * @param {string} date วันที่\n * @param {string} wardId รหัสวอร์ด\n * @param {string} shift กะงาน\n * @returns {Promise<Object|null>} ข้อมูลการอนุมัติ หรือ null ถ้าไม่พบ\n */ const fetchApprovalData = async (date, wardId, shift)=>{\n    try {\n        if (!date || !wardId || !shift) {\n            return null;\n        }\n        const formattedDate = (0,_barrel_optimize_names_format_date_fns__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(new Date(date), 'yyyy-MM-dd');\n        const wardData = await (0,_lib_dataAccess__WEBPACK_IMPORTED_MODULE_0__.getWardDataByDate)(formattedDate, shift, wardId);\n        if (!wardData) {\n            return null;\n        }\n        return {\n            status: wardData.approvalStatus || 'pending',\n            approvedBy: wardData.approvedBy || null,\n            approvalTimestamp: wardData.approvalTimestamp || null,\n            rejectedBy: wardData.rejectedBy || null,\n            rejectionReason: wardData.rejectionReason || null,\n            comments: wardData.approvalComments || null\n        };\n    } catch (error) {\n        console.error('Error fetching approval data:', error);\n        return null;\n    }\n};\n/**\n * ฟังก์ชันสำหรับดึงข้อมูลล่าสุด\n * @param {string} wardId รหัสวอร์ด\n * @returns {Promise<Object|null>} ข้อมูลล่าสุด หรือ null ถ้าไม่พบ\n */ const fetchLatestRecord = async (wardId)=>{\n    try {\n        if (!wardId) {\n            return null;\n        }\n        // ตรวจสอบย้อนหลังจากวันปัจจุบันไปจนถึง 30 วันก่อนหน้า\n        const currentDate = new Date();\n        let latestData = null;\n        for(let i = 0; i < 30; i++){\n            const checkDate = new Date(currentDate);\n            checkDate.setDate(checkDate.getDate() - i);\n            const formattedDate = (0,_barrel_optimize_names_format_date_fns__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(checkDate, 'yyyy-MM-dd');\n            // ตรวจสอบกะดึกก่อน แล้วจึงตรวจสอบกะเช้า\n            const nightData = await (0,_lib_dataAccess__WEBPACK_IMPORTED_MODULE_0__.getWardDataByDate)(formattedDate, 'Night (19:00-07:00)', wardId);\n            if (nightData) {\n                return nightData;\n            }\n            const morningData = await (0,_lib_dataAccess__WEBPACK_IMPORTED_MODULE_0__.getWardDataByDate)(formattedDate, 'Morning (07:00-19:00)', wardId);\n            if (morningData) {\n                return morningData;\n            }\n        }\n        return null;\n    } catch (error) {\n        console.error('Error fetching latest record:', error);\n        return null;\n    }\n};\n/**\n * ฟังก์ชันสำหรับตรวจสอบว่ามีข้อมูลใน 30 วันล่าสุดหรือไม่\n * @param {string} wardId รหัสวอร์ด\n * @returns {Promise<boolean>} true ถ้ามีข้อมูลใน 30 วันล่าสุด, false ถ้าไม่มี\n */ const checkPast30DaysRecords = async (wardId)=>{\n    try {\n        if (!wardId) {\n            return false;\n        }\n        const latestRecord = await fetchLatestRecord(wardId);\n        return latestRecord !== null;\n    } catch (error) {\n        console.error('Error checking past 30 days records:', error);\n        return false;\n    }\n};\n/**\n * ฟังก์ชันสำหรับดึงข้อมูลย้อนหลัง X วัน\n */ const fetchPreviousWardData = async function(department, currentDate) {\n    let days = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 7;\n    try {\n        console.log(\"Getting previous \".concat(days, \" days data for \").concat(department, \" from \").concat(currentDate));\n        // โค้ดดึงข้อมูลย้อนหลัง...\n        // (คัดลอกจาก WardForm.js ใส่ตรงนี้)\n        return [];\n    } catch (error) {\n        console.error('Error getting previous data:', error);\n        return [];\n    }\n};\n/**\n * แปลงรูปแบบวันที่\n */ const formatDate = (date)=>{\n    if (!date) return '';\n    const d = new Date(date);\n    if (isNaN(d.getTime())) return '';\n    return (0,_barrel_optimize_names_format_date_fns__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(d, 'yyyy-MM-dd');\n};\n/**\n * ฟังก์ชันสำหรับดึงข้อมูลและจัดการการโหลดข้อมูลอัตโนมัติตามกะ\n * @param {string} date วันที่\n * @param {string} wardId รหัสวอร์ด\n * @param {string} shift กะงาน\n * @returns {Promise<Object>} ข้อมูลที่โหลด พร้อมสถานะ\n */ const fetchAndPrepareWardData = async (date, wardId, shift)=>{\n    try {\n        console.log(\"Fetching and preparing data for \".concat(date, \", \").concat(wardId, \", \").concat(shift));\n        // ดึงข้อมูลของกะปัจจุบัน\n        const wardData = await fetchWardData(date, wardId, shift);\n        let patientCensusTotal = 0;\n        let sourceMessage = '';\n        // ตรวจสอบว่ามีข้อมูลหรือไม่\n        if (wardData) {\n            console.log('Found existing data for this shift');\n            // คำนวณ Patient Census ถ้ามีข้อมูล\n            if (wardData.patientCensus) {\n                patientCensusTotal = calculatePatientCensus(wardData.patientCensus);\n                sourceMessage = 'ข้อมูลผู้ป่วยคำนวณจากข้อมูลในระบบ';\n            }\n            return {\n                data: wardData,\n                hasData: true,\n                patientCensusTotal,\n                sourceMessage\n            };\n        }\n        // ถ้าไม่มีข้อมูล จะดึงข้อมูลตามกฎที่กำหนด\n        if (shift === 'Morning (07:00-19:00)') {\n            // กรณีกะเช้า: ดึงข้อมูลย้อนหลัง 7 วัน\n            const previousDate = new Date(date);\n            previousDate.setDate(previousDate.getDate() - 7);\n            const formattedPreviousDate = (0,_barrel_optimize_names_format_date_fns__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(previousDate, 'yyyy-MM-dd');\n            console.log('No data found for morning shift, checking data from 7 days ago:', formattedPreviousDate);\n            const previousData = await fetchWardData(formattedPreviousDate, wardId, shift);\n            if (previousData) {\n                console.log('Found previous data from 7 days ago');\n                // คำนวณ Patient Census ถ้ามีข้อมูล\n                if (previousData.patientCensus) {\n                    patientCensusTotal = calculatePatientCensus(previousData.patientCensus);\n                    sourceMessage = 'ข้อมูลผู้ป่วยคำนวณจากข้อมูล 7 วันก่อน';\n                }\n                // สร้างข้อมูลใหม่โดยใช้ข้อมูลเดิมแต่ไม่เอา ID และข้อมูลเฉพาะอื่นๆ\n                const newData = {\n                    ...previousData\n                };\n                delete newData.id;\n                delete newData.timestamp;\n                delete newData.createdAt;\n                delete newData.updatedAt;\n                delete newData.approvalStatus;\n                delete newData.approvedBy;\n                delete newData.approvalTimestamp;\n                // อัปเดตค่า Patient Census\n                if (newData.patientCensus) {\n                    newData.patientCensus.total = patientCensusTotal.toString();\n                }\n                return {\n                    data: newData,\n                    hasData: true,\n                    patientCensusTotal,\n                    sourceMessage,\n                    isAutoFilledFromHistory: true\n                };\n            }\n        } else if (shift === 'Night (19:00-07:00)') {\n            // กรณีกะดึก: ดึงข้อมูลจากกะเช้าของวันเดียวกัน\n            console.log('No data found for night shift, checking morning shift from same day');\n            const morningData = await fetchWardData(date, wardId, 'Morning (07:00-19:00)');\n            if (morningData) {\n                console.log('Found morning shift data from same day');\n                // คำนวณ Patient Census ถ้ามีข้อมูล\n                if (morningData.patientCensus) {\n                    patientCensusTotal = calculatePatientCensus(morningData.patientCensus);\n                    sourceMessage = 'ข้อมูลผู้ป่วยคำนวณจากข้อมูลกะเช้า';\n                }\n                // สร้างข้อมูลใหม่โดยใช้ข้อมูลจากกะเช้า\n                const newData = {\n                    ...morningData\n                };\n                delete newData.id;\n                delete newData.timestamp;\n                delete newData.createdAt;\n                delete newData.updatedAt;\n                delete newData.approvalStatus;\n                delete newData.approvedBy;\n                delete newData.approvalTimestamp;\n                // อัปเดตค่า Patient Census และ Overall Data (สำหรับกะดึก)\n                if (newData.patientCensus) {\n                    newData.patientCensus.total = patientCensusTotal.toString();\n                }\n                newData.overallData = patientCensusTotal.toString();\n                return {\n                    data: newData,\n                    hasData: true,\n                    patientCensusTotal,\n                    sourceMessage,\n                    isAutoFilledFromHistory: true\n                };\n            }\n        }\n        // ถ้าไม่มีข้อมูลใดๆ ให้สร้างข้อมูลเปล่า\n        return {\n            data: null,\n            hasData: false,\n            patientCensusTotal: 0,\n            sourceMessage: 'ไม่พบข้อมูลก่อนหน้า'\n        };\n    } catch (error) {\n        console.error('Error fetching and preparing ward data:', error);\n        return {\n            data: null,\n            hasData: false,\n            patientCensusTotal: 0,\n            sourceMessage: 'เกิดข้อผิดพลาดในการโหลดข้อมูล',\n            error: error.message\n        };\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9jb21wb25lbnRzL2Zvcm1zL1dhcmRGb3JtL0RhdGFGZXRjaGVycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b1ZBRTJHO0FBQ2pDO0FBQ3hDO0FBQ1M7QUFDeUQ7QUFFcEc7Ozs7OztDQU1DLEdBQ00sTUFBTWUsc0JBQXNCLE9BQU9DLE1BQU1DLE9BQU9DO0lBQ3JELElBQUk7UUFDRixNQUFNQyxnQkFBZ0JkLGtGQUFNQSxDQUFDLElBQUllLEtBQUtKLE9BQU87UUFDN0MsMkJBQTJCO1FBQzNCLE1BQU1LLFdBQVcsTUFBTXBCLGtFQUFpQkEsQ0FBQ2tCLGVBQWVGLE9BQU9DO1FBRS9ELElBQUksQ0FBQ0csVUFBVTtZQUNiLE9BQU87Z0JBQUVDLFFBQVE7Z0JBQWlCQyxTQUFTO1lBQXdCO1FBQ3JFO1FBRUEsSUFBSUYsU0FBU0csY0FBYyxLQUFLLFlBQVk7WUFDMUMsT0FBTztnQkFDTEYsUUFBUTtnQkFDUkMsU0FBUztnQkFDVEUsV0FBV0osU0FBU0ssaUJBQWlCO2dCQUNyQ0MsWUFBWU4sU0FBU00sVUFBVTtZQUNqQztRQUNGO1FBRUEsSUFBSU4sU0FBU0csY0FBYyxLQUFLLFlBQVk7WUFDMUMsT0FBTztnQkFDTEYsUUFBUTtnQkFDUkMsU0FBUztnQkFDVEUsV0FBV0osU0FBU0ssaUJBQWlCO2dCQUNyQ0UsWUFBWVAsU0FBU08sVUFBVTtnQkFDL0JDLGlCQUFpQlIsU0FBU1EsZUFBZTtZQUMzQztRQUNGO1FBRUEsT0FBTztZQUFFUCxRQUFRO1lBQVdDLFNBQVM7UUFBZTtJQUN0RCxFQUFFLE9BQU9PLE9BQU87UUFDZEMsUUFBUUQsS0FBSyxDQUFDLG1DQUFtQ0E7UUFDakQsT0FBTztZQUFFUixRQUFRO1lBQVNDLFNBQVM7UUFBNkI7SUFDbEU7QUFDRixFQUFFO0FBRUY7Ozs7OztDQU1DLEdBQ00sTUFBTVMsZ0JBQWdCLE9BQU9oQixNQUFNRSxRQUFRRDtJQUM5QyxJQUFJO1FBQ0FjLFFBQVFF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QUFPc0UsUUFBUTNGLFNBQVM7Z0JBQ3hCLE9BQU8yRixRQUFRQyxTQUFTO2dCQUN4QixPQUFPRCxRQUFRRSxTQUFTO2dCQUN4QixPQUFPRixRQUFRNUYsY0FBYztnQkFDN0IsT0FBTzRGLFFBQVF6RixVQUFVO2dCQUN6QixPQUFPeUYsUUFBUTFGLGlCQUFpQjtnQkFFaEMsMERBQTBEO2dCQUMxRCxJQUFJMEYsUUFBUUYsYUFBYSxFQUFFO29CQUN2QkUsUUFBUUYsYUFBYSxDQUFDbkMsS0FBSyxHQUFHaUMsbUJBQW1CTyxRQUFRO2dCQUM3RDtnQkFDQUgsUUFBUUssV0FBVyxHQUFHVCxtQkFBbUJPLFFBQVE7Z0JBRWpELE9BQU87b0JBQ0hqRixNQUFNOEU7b0JBQ05ELFNBQVM7b0JBQ1RIO29CQUNBQztvQkFDQU8seUJBQXlCO2dCQUM3QjtZQUNKO1FBQ0o7UUFFQSx3Q0FBd0M7UUFDeEMsT0FBTztZQUNIbEYsTUFBTTtZQUNONkUsU0FBUztZQUNUSCxvQkFBb0I7WUFDcEJDLGVBQWU7UUFDbkI7SUFDSixFQUFFLE9BQU9uRixPQUFPO1FBQ1pDLFFBQVFELEtBQUssQ0FBQywyQ0FBMkNBO1FBQ3pELE9BQU87WUFDSFEsTUFBTTtZQUNONkUsU0FBUztZQUNUSCxvQkFBb0I7WUFDcEJDLGVBQWU7WUFDZm5GLE9BQU9BLE1BQU1QLE9BQU87UUFDeEI7SUFDSjtBQUNKLEVBQUUiLCJzb3VyY2VzIjpbIkM6XFxQcm9qZWN0IEJQSzkgMjAtMy0yNTY4XFxTdW1tYXJ5X29mX1BlcnNvbm5lbF9SYXRpb1xcYXBwXFxjb21wb25lbnRzXFxmb3Jtc1xcV2FyZEZvcm1cXERhdGFGZXRjaGVycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmltcG9ydCB7IGdldFVzZXJEYXRhRnJvbUNvbGxlY3Rpb24sIGdldFdhcmREYXRhQnlEYXRlLCBjaGVja0xhc3Q3RGF5c0RhdGEgfSBmcm9tICcuLi8uLi8uLi9saWIvZGF0YUFjY2Vzcyc7XG5pbXBvcnQgeyBnZXRTdWJjb2xsZWN0aW9uLCBnZXREb2N1bWVudEJ5SWQgfSBmcm9tICcuLi8uLi8uLi9saWIvZmlyZWJhc2UnO1xuaW1wb3J0IHsgZm9ybWF0IH0gZnJvbSAnZGF0ZS1mbnMnO1xuaW1wb3J0IHsgZGIgfSBmcm9tICcuLi8uLi8uLi9saWIvZmlyZWJhc2UnO1xuaW1wb3J0IHsgY29sbGVjdGlvbiwgcXVlcnksIHdoZXJlLCBnZXREb2NzLCBkb2MsIGdldERvYywgb3JkZXJCeSwgbGltaXQgfSBmcm9tICdmaXJlYmFzZS9maXJlc3RvcmUnO1xuXG4vKipcbiAqIOC4n+C4seC4h+C4geC5jOC4iuC4seC4meC4quC4s+C4q+C4o+C4seC4muC4leC4o+C4p+C4iOC4quC4reC4muC4geC4suC4o+C4reC4meC4uOC4oeC4seC4leC4tFxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGUg4Lin4Lix4LiZ4LiX4Li14LmI4LiV4Lij4Lin4LiI4Liq4Lit4LiaXG4gKiBAcGFyYW0ge3N0cmluZ30gc2hpZnQg4LiB4Liw4LiH4Liy4LiZ4LiX4Li14LmI4LiV4Lij4Lin4LiI4Liq4Lit4LiaXG4gKiBAcGFyYW0ge3N0cmluZ30gd2FyZElkIOC4o+C4q+C4seC4quC4p+C4reC4o+C5jOC4lFxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0g4Liq4LiW4Liy4LiZ4Liw4LiB4Liy4Lij4Lit4LiZ4Li44Lih4Lix4LiV4Li0XG4gKi9cbmV4cG9ydCBjb25zdCBjaGVja0FwcHJvdmFsU3RhdHVzID0gYXN5bmMgKGRhdGUsIHNoaWZ0LCB3YXJkSWQpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBmb3JtYXR0ZWREYXRlID0gZm9ybWF0KG5ldyBEYXRlKGRhdGUpLCAneXl5eS1NTS1kZCcpO1xuICAgIC8vIOC4leC4o+C4p+C4iOC4quC4reC4muC4guC5ieC4reC4oeC4ueC4peC5g+C4meC4kOC4suC4meC4guC5ieC4reC4oeC4ueC4pVxuICAgIGNvbnN0IHdhcmREYXRhID0gYXdhaXQgZ2V0V2FyZERhdGFCeURhdGUoZm9ybWF0dGVkRGF0ZSwgc2hpZnQsIHdhcmRJZCk7XG4gICAgXG4gICAgaWYgKCF3YXJkRGF0YSkge1xuICAgICAgcmV0dXJuIHsgc3RhdHVzOiAnbm90X3N1Ym1pdHRlZCcsIG1lc3NhZ2U6ICfguKLguLHguIfguYTguKHguYjguYTguJTguYnguJrguLHguJnguJfguLbguIHguILguYnguK3guKHguLnguKUnIH07XG4gICAgfVxuICAgIFxuICAgIGlmICh3YXJkRGF0YS5hcHByb3ZhbFN0YXR1cyA9PT0gJ2FwcHJvdmVkJykge1xuICAgICAgcmV0dXJuIHsgXG4gICAgICAgIHN0YXR1czogJ2FwcHJvdmVkJywgXG4gICAgICAgIG1lc3NhZ2U6ICfguYTguJTguYnguKPguLHguJrguIHguLLguKPguK3guJnguLjguKHguLHguJXguLTguYHguKXguYnguKcnLCBcbiAgICAgICAgdGltZXN0YW1wOiB3YXJkRGF0YS5hcHByb3ZhbFRpbWVzdGFtcCxcbiAgICAgICAgYXBwcm92ZWRCeTogd2FyZERhdGEuYXBwcm92ZWRCeSBcbiAgICAgIH07XG4gICAgfVxuICAgIFxuICAgIGlmICh3YXJkRGF0YS5hcHByb3ZhbFN0YXR1cyA9PT0gJ3JlamVjdGVkJykge1xuICAgICAgcmV0dXJuIHsgXG4gICAgICAgIHN0YXR1czogJ3JlamVjdGVkJywgXG4gICAgICAgIG1lc3NhZ2U6ICfguJbguLnguIHguJvguI/guLTguYDguKrguJjguIHguLLguKPguK3guJnguLjguKHguLHguJXguLQnLCBcbiAgICAgICAgdGltZXN0YW1wOiB3YXJkRGF0YS5hcHByb3ZhbFRpbWVzdGFtcCxcbiAgICAgICAgcmVqZWN0ZWRCeTogd2FyZERhdGEucmVqZWN0ZWRCeSxcbiAgICAgICAgcmVqZWN0aW9uUmVhc29uOiB3YXJkRGF0YS5yZWplY3Rpb25SZWFzb24gXG4gICAgICB9O1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4geyBzdGF0dXM6ICdwZW5kaW5nJywgbWVzc2FnZTogJ+C4o+C4reC4geC4suC4o+C4reC4meC4uOC4oeC4seC4leC4tCcgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjaGVja2luZyBhcHByb3ZhbCBzdGF0dXM6JywgZXJyb3IpO1xuICAgIHJldHVybiB7IHN0YXR1czogJ2Vycm9yJywgbWVzc2FnZTogJ+C5gOC4geC4tOC4lOC4guC5ieC4reC4nOC4tOC4lOC4nuC4peC4suC4lOC5g+C4meC4geC4suC4o+C4leC4o+C4p+C4iOC4quC4reC4micgfTtcbiAgfVxufTtcblxuLyoqXG4gKiDguJ/guLHguIfguIHguYzguIrguLHguJnguKrguLPguKvguKPguLHguJrguJTguLbguIfguILguYnguK3guKHguLnguKXguKfguK3guKPguYzguJRcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRlIOC4p+C4seC4meC4l+C4teC5iOC4leC5ieC4reC4h+C4geC4suC4o+C4lOC4tuC4h+C4guC5ieC4reC4oeC4ueC4pVxuICogQHBhcmFtIHtzdHJpbmd9IHdhcmRJZCDguKPguKvguLHguKrguKfguK3guKPguYzguJRcbiAqIEBwYXJhbSB7c3RyaW5nfSBzaGlmdCDguIHguLDguIfguLLguJlcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdHxudWxsPn0g4LiC4LmJ4Lit4Lih4Li54Lil4Lin4Lit4Lij4LmM4LiU4Lir4Lij4Li34LitIG51bGwg4LiW4LmJ4Liy4LmE4Lih4LmI4Lie4LiaXG4gKi9cbmV4cG9ydCBjb25zdCBmZXRjaFdhcmREYXRhID0gYXN5bmMgKGRhdGUsIHdhcmRJZCwgc2hpZnQpID0+IHtcbiAgICB0cnkge1xuICAgICAgICBjb25zb2xlLmxvZygnRmV0Y2hpbmcgd2FyZCBkYXRhOicsIHsgZGF0ZSwgd2FyZElkLCBzaGlmdCB9KTtcbiAgICAgICAgY29uc3QgZm9ybWF0dGVkRGF0ZSA9IGZvcm1hdChuZXcgRGF0ZShkYXRlKSwgJ3l5eXktTU0tZGQnKTtcbiAgICAgICAgY29uc3QgZG9jSWQgPSBgJHtmb3JtYXR0ZWREYXRlfV8ke3dhcmRJZH1fJHtzaGlmdH1gO1xuICAgICAgICBcbiAgICAgICAgLy8g4Lil4Lit4LiH4LiU4Li24LiH4LiC4LmJ4Lit4Lih4Li54Lil4LiI4Liy4LiBIHdhcmREYXRhRmluYWwg4LiB4LmI4Lit4LiZXG4gICAgICAgIGNvbnN0IGRvY1JlZiA9IGRvYyhkYiwgJ3dhcmREYXRhRmluYWwnLCBkb2NJZCk7XG4gICAgICAgIGNvbnN0IGRvY1NuYXAgPSBhd2FpdCBnZXREb2MoZG9jUmVmKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChkb2NTbmFwLmV4aXN0cygpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRm91bmQgZGF0YSBpbiB3YXJkRGF0YUZpbmFsJyk7XG4gICAgICAgICAgICByZXR1cm4gZG9jU25hcC5kYXRhKCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIOC4luC5ieC4suC5hOC4oeC5iOC4oeC4teC4guC5ieC4reC4oeC4ueC4peC5g+C4mSB3YXJkRGF0YUZpbmFsIOC5g+C4q+C5ieC4peC4reC4h+C4lOC4tuC4h+C4guC5ieC4reC4oeC4ueC4peC4o+C5iOC4suC4h1xuICAgICAgICBjb25zdCBkcmFmdHNSZWYgPSBjb2xsZWN0aW9uKGRiLCAnd2FyZERhdGFEcmFmdHMnKTtcbiAgICAgICAgY29uc3QgZHJhZnRzUXVlcnkgPSBxdWVyeShcbiAgICAgICAgICAgIGRyYWZ0c1JlZixcbiAgICAgICAgICAgIHdoZXJlKCdkYXRlJywgJz09JywgZm9ybWF0dGVkRGF0ZSksXG4gICAgICAgICAgICB3aGVyZSgnd2FyZElkJywgJz09Jywgd2FyZElkKSxcbiAgICAgICAgICAgIHdoZXJlKCdzaGlmdCcsICc9PScsIHNoaWZ0KVxuICAgICAgICApO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgZHJhZnRzU25hcCA9IGF3YWl0IGdldERvY3MoZHJhZnRzUXVlcnkpO1xuICAgICAgICBcbiAgICAgICAgaWYgKCFkcmFmdHNTbmFwLmVtcHR5KSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRm91bmQgZGF0YSBpbiB3YXJkRGF0YURyYWZ0cycpO1xuICAgICAgICAgICAgLy8g4LmA4Lij4Li14Lii4LiH4Lil4Liz4LiU4Lix4Lia4LiV4Liy4LihIHRpbWVzdGFtcCDguYDguJ7guLfguYjguK3guYDguK3guLLguKPguYjguLLguIfguKXguYjguLLguKrguLjguJRcbiAgICAgICAgICAgIGNvbnN0IGRyYWZ0cyA9IFtdO1xuICAgICAgICAgICAgZHJhZnRzU25hcC5mb3JFYWNoKGRvYyA9PiB7XG4gICAgICAgICAgICAgICAgZHJhZnRzLnB1c2goeyBpZDogZG9jLmlkLCAuLi5kb2MuZGF0YSgpIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGRyYWZ0cy5zb3J0KChhLCBiKSA9PiBuZXcgRGF0ZShiLnRpbWVzdGFtcCkgLSBuZXcgRGF0ZShhLnRpbWVzdGFtcCkpO1xuICAgICAgICAgICAgcmV0dXJuIGRyYWZ0c1swXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coJ05vIGRhdGEgZm91bmQgZm9yIHRoaXMgZGF0ZS9zaGlmdCcpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyB3YXJkIGRhdGE6JywgZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG59O1xuXG4vKipcbiAqIOC4n+C4seC4h+C4geC5jOC4iuC4seC4meC4quC4s+C4q+C4o+C4seC4muC4leC4o+C4p+C4iOC4quC4reC4muC4p+C5iOC4suC4oeC4teC4guC5ieC4reC4oeC4ueC4peC4geC4sOC5gOC4iuC5ieC4suC4q+C4o+C4t+C4reC5hOC4oeC5iFxuICogQHBhcmFtIHtEYXRlfSBkYXRlIOC4p+C4seC4meC4l+C4teC5iOC4leC5ieC4reC4h+C4geC4suC4o+C4leC4o+C4p+C4iOC4quC4reC4mlxuICogQHBhcmFtIHtzdHJpbmd9IHdhcmRJZCDguKPguKvguLHguKrguKfguK3guKPguYzguJRcbiAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fSB0cnVlIOC4luC5ieC4suC4oeC4teC4guC5ieC4reC4oeC4ueC4peC4geC4sOC5gOC4iuC5ieC4siwgZmFsc2Ug4LiW4LmJ4Liy4LmE4Lih4LmI4Lih4Li1XG4gKi9cbmV4cG9ydCBjb25zdCBjaGVja01vcm5pbmdTaGlmdERhdGFFeGlzdHMgPSBhc3luYyAoZGF0ZSwgd2FyZElkKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgZm9ybWF0dGVkRGF0ZSA9IGZvcm1hdChuZXcgRGF0ZShkYXRlKSwgJ3l5eXktTU0tZGQnKTtcbiAgICBjb25zdCBtb3JuaW5nRGF0YSA9IGF3YWl0IGdldFdhcmREYXRhQnlEYXRlKGZvcm1hdHRlZERhdGUsICfguYDguIrguYnguLInLCB3YXJkSWQpO1xuICAgIHJldHVybiBtb3JuaW5nRGF0YSA/IHRydWUgOiBmYWxzZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjaGVja2luZyBtb3JuaW5nIHNoaWZ0IGRhdGE6JywgZXJyb3IpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiDguJ/guLHguIfguIHguYzguIrguLHguJnguKrguLPguKvguKPguLHguJrguJTguLbguIfguILguYnguK3guKHguLnguKUgNyDguKfguLHguJnguKLguYnguK3guJnguKvguKXguLHguIdcbiAqIEBwYXJhbSB7c3RyaW5nfSB3YXJkSWQg4Lij4Lir4Lix4LiqIHdhcmRcbiAqIEBwYXJhbSB7RGF0ZX0gY3VycmVudERhdGUg4Lin4Lix4LiZ4LiX4Li14LmI4Lib4Lix4LiI4LiI4Li44Lia4Lix4LiZIChvcHRpb25hbClcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdHxudWxsPn0g4LiC4LmJ4Lit4Lih4Li54Lil4Lil4LmI4Liy4Liq4Li44LiU4Lig4Liy4Lii4LmD4LiZIDcg4Lin4Lix4LiZ4Lii4LmJ4Lit4LiZ4Lir4Lil4Lix4LiHIOC4q+C4o+C4t+C4rSBudWxsIOC4luC5ieC4suC5hOC4oeC5iOC4nuC4muC4guC5ieC4reC4oeC4ueC4pVxuICovXG5leHBvcnQgY29uc3QgZmV0Y2hMYXN0N0RheXNEYXRhID0gYXN5bmMgKGN1cnJlbnREYXRlLCB3YXJkSWQpID0+IHtcbiAgdHJ5IHtcbiAgICAvLyDguKrguKPguYnguLLguIfguK3guLLguKPguYzguYDguKPguKLguYzguILguK3guIfguKfguLHguJnguJfguLXguYjguKLguYnguK3guJnguKvguKXguLHguIcgNyDguKfguLHguJlcbiAgICBjb25zdCBkYXRlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IDc7IGkrKykge1xuICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKGN1cnJlbnREYXRlKTtcbiAgICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSAtIGkpO1xuICAgICAgZGF0ZXMucHVzaChmb3JtYXQoZGF0ZSwgJ3l5eXktTU0tZGQnKSk7XG4gICAgfVxuXG4gICAgLy8g4LiU4Li24LiH4LiC4LmJ4Lit4Lih4Li54Lil4LiB4Liw4LmA4LiK4LmJ4Liy4LiI4Liy4LiB4LiX4Lix4LmJ4LiHIDcg4Lin4Lix4LiZ4Lii4LmJ4Lit4LiZ4Lir4Lil4Lix4LiHXG4gICAgY29uc3QgcHJvbWlzZXMgPSBkYXRlcy5tYXAoZGF0ZSA9PiBnZXRXYXJkRGF0YUJ5RGF0ZShkYXRlLCAn4LmA4LiK4LmJ4LiyJywgd2FyZElkKSk7XG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcblxuICAgIC8vIOC4geC4o+C4reC4h+C5gOC4ieC4nuC4suC4sOC4p+C4seC4meC4l+C4teC5iOC4oeC4teC4guC5ieC4reC4oeC4ueC4pVxuICAgIGNvbnN0IHZhbGlkRGF0YSA9IHJlc3VsdHMuZmlsdGVyKGRhdGEgPT4gZGF0YSAhPT0gbnVsbCk7XG5cbiAgICAvLyDguJbguYnguLLguYTguKHguYjguKHguLXguILguYnguK3guKHguLnguKXguYDguKXguKIg4Liq4LmI4LiH4LiE4LmI4Liy4Lin4LmI4Liy4LiHXG4gICAgaWYgKHZhbGlkRGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIOC5gOC4o+C4teC4ouC4h+C4peC4s+C4lOC4seC4muC4guC5ieC4reC4oeC4ueC4peC4leC4suC4oeC4p+C4seC4meC4l+C4teC5iCAo4Lil4LmI4Liy4Liq4Li44LiU4LiB4LmI4Lit4LiZKVxuICAgIHZhbGlkRGF0YS5zb3J0KChhLCBiKSA9PiBuZXcgRGF0ZShiLmRhdGUpIC0gbmV3IERhdGUoYS5kYXRlKSk7XG5cbiAgICAvLyDguKrguYjguIfguILguYnguK3guKHguLnguKXguKXguYjguLLguKrguLjguJTguIHguKXguLHguJrguYTguJtcbiAgICByZXR1cm4gdmFsaWREYXRhWzBdO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGxhc3QgNyBkYXlzIGRhdGE6JywgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIOC4n+C4seC4h+C4geC5jOC4iuC4seC4meC4quC4s+C4q+C4o+C4seC4muC4hOC4s+C4meC4p+C4k+C4hOC5iOC4siBQYXRpZW50IENlbnN1c1xuICogQHBhcmFtIHtPYmplY3R9IGZvcm1EYXRhIOC4guC5ieC4reC4oeC4ueC4peC4n+C4reC4o+C5jOC4oVxuICogQHJldHVybnMge3N0cmluZ3xudW1iZXJ9IOC4hOC5iOC4siBQYXRpZW50IENlbnN1cyDguJfguLXguYjguITguLPguJnguKfguJPguYTguJTguYkg4Lir4Lij4Li34LitIGVtcHR5IHN0cmluZyDguJbguYnguLLguYTguKHguYjguKHguLXguILguYnguK3guKHguLnguKVcbiAqL1xuZXhwb3J0IGNvbnN0IGNhbGN1bGF0ZVBhdGllbnRDZW5zdXMgPSAocGF0aWVudERhdGEpID0+IHtcbiAgICBpZiAoIXBhdGllbnREYXRhKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybign4LmE4Lih4LmI4Lih4Li14LiC4LmJ4Lit4Lih4Li54Lil4Lic4Li54LmJ4Lib4LmI4Lin4Lii4Liq4Liz4Lir4Lij4Lix4Lia4LiB4Liy4Lij4LiE4Liz4LiZ4Lin4LiTIFBhdGllbnQgQ2Vuc3VzJyk7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBcbiAgICAvLyDguYHguJvguKXguIfguITguYjguLLguYDguJvguYfguJnguJXguLHguKfguYDguKXguIIg4LmB4Lil4Liw4LmD4LiK4LmJIE51bWJlcigpIOC5gOC4nuC4t+C5iOC4reC4m+C5ieC4reC4h+C4geC4seC4meC4geC4suC4o+C5gOC4geC4tOC4lCBzdHJpbmcgY29uY2F0ZW5hdGlvblxuICAgIGNvbnN0IGhvc3BpdGFsUGF0aWVudGNlbnN1cyA9IE51bWJlcihwYXJzZUludChwYXRpZW50RGF0YS5ob3NwaXRhbFBhdGllbnRjZW5zdXMgfHwgJzAnLCAxMCkpO1xuICAgIGNvbnN0IG5ld0FkbWl0ID0gTnVtYmVyKHBhcnNlSW50KHBhdGllbnREYXRhLm5ld0FkbWl0IHx8ICcwJywgMTApKTtcbiAgICBjb25zdCB0cmFuc2ZlckluID0gTnVtYmVyKHBhcnNlSW50KHBhdGllbnREYXRhLnRyYW5zZmVySW4gfHwgJzAnLCAxMCkpO1xuICAgIGNvbnN0IHJlZmVySW4gPSBOdW1iZXIocGFyc2VJbnQocGF0aWVudERhdGEucmVmZXJJbiB8fCAnMCcsIDEwKSk7XG4gICAgY29uc3QgdHJhbnNmZXJPdXQgPSBOdW1iZXIocGFyc2VJbnQocGF0aWVudERhdGEudHJhbnNmZXJPdXQgfHwgJzAnLCAxMCkpO1xuICAgIGNvbnN0IHJlZmVyT3V0ID0gTnVtYmVyKHBhcnNlSW50KHBhdGllbnREYXRhLnJlZmVyT3V0IHx8ICcwJywgMTApKTtcbiAgICBjb25zdCBkaXNjaGFyZ2UgPSBOdW1iZXIocGFyc2VJbnQocGF0aWVudERhdGEuZGlzY2hhcmdlIHx8ICcwJywgMTApKTtcbiAgICBjb25zdCBkZWFkID0gTnVtYmVyKHBhcnNlSW50KHBhdGllbnREYXRhLmRlYWQgfHwgJzAnLCAxMCkpO1xuICAgIFxuICAgIC8vIOC4hOC4s+C4meC4p+C4k+C4leC4suC4oeC4quC4ueC4leC4ozogSG9zcGl0YWwgUGF0aWVudCBDZW5zdXMgKyBOZXcgQWRtaXQgKyBUcmFuc2ZlciBJbiArIFJlZmVyIEluIC0gVHJhbnNmZXIgT3V0IC0gUmVmZXIgT3V0IC0gRGlzY2hhcmdlIC0gRGVhZFxuICAgIGNvbnN0IHRvdGFsID0gaG9zcGl0YWxQYXRpZW50Y2Vuc3VzICsgbmV3QWRtaXQgKyB0cmFuc2ZlckluICsgcmVmZXJJbiAtIHRyYW5zZmVyT3V0IC0gcmVmZXJPdXQgLSBkaXNjaGFyZ2UgLSBkZWFkO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKGDguITguLPguJnguKfguJMgUGF0aWVudCBDZW5zdXM6ICR7aG9zcGl0YWxQYXRpZW50Y2Vuc3VzfSArICR7bmV3QWRtaXR9ICsgJHt0cmFuc2ZlcklufSArICR7cmVmZXJJbn0gLSAke3RyYW5zZmVyT3V0fSAtICR7cmVmZXJPdXR9IC0gJHtkaXNjaGFyZ2V9IC0gJHtkZWFkfSA9ICR7dG90YWx9YCk7XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgd2Ugc2hvdWxkIHNob3cgZW1wdHkgc3RyaW5nICh3aGVuIHRvdGFsIGlzIDAgYW5kIGFsbCBpbnB1dCBmaWVsZHMgYXJlIGVtcHR5KVxuICAgIGNvbnN0IHNob3VsZFNob3dFbXB0eSA9IHRvdGFsID09PSAwICYmIFxuICAgICAgICAhcGF0aWVudERhdGEuaG9zcGl0YWxQYXRpZW50Y2Vuc3VzICYmXG4gICAgICAgICFwYXRpZW50RGF0YS5uZXdBZG1pdCAmJiBcbiAgICAgICAgIXBhdGllbnREYXRhLnRyYW5zZmVySW4gJiYgXG4gICAgICAgICFwYXRpZW50RGF0YS5yZWZlckluICYmIFxuICAgICAgICAhcGF0aWVudERhdGEudHJhbnNmZXJPdXQgJiYgXG4gICAgICAgICFwYXRpZW50RGF0YS5yZWZlck91dCAmJiBcbiAgICAgICAgIXBhdGllbnREYXRhLmRpc2NoYXJnZSAmJiBcbiAgICAgICAgIXBhdGllbnREYXRhLmRlYWQ7XG4gICAgICAgIFxuICAgIHJldHVybiBzaG91bGRTaG93RW1wdHkgPyAnJyA6IHRvdGFsO1xufTtcblxuLyoqXG4gKiDguJ/guLHguIfguIHguYzguIrguLHguJnguKrguLPguKvguKPguLHguJrguJXguKPguKfguIjguKrguK3guJrguKrguJbguLLguJnguLDguIHguLLguKPguK3guJnguLjguKHguLHguJXguLTguILguLHguYnguJnguKrguLjguJTguJfguYnguLLguKJcbiAqIEBwYXJhbSB7RGF0ZX0gZGF0ZSDguKfguLHguJnguJfguLXguYjguJXguYnguK3guIfguIHguLLguKPguJXguKPguKfguIjguKrguK3guJpcbiAqIEBwYXJhbSB7c3RyaW5nfSB3YXJkSWQg4Lij4Lir4Lix4Liq4Lin4Lit4Lij4LmM4LiUXG4gKiBAcGFyYW0ge3N0cmluZ30gc2hpZnQg4LiB4Liw4LiB4Liy4Lij4LiX4Liz4LiH4Liy4LiZXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn0gdHJ1ZSDguJbguYnguLLguYTguJTguYnguKPguLHguJrguIHguLLguKPguK3guJnguLjguKHguLHguJXguLTguYHguKXguYnguKcsIGZhbHNlIOC4luC5ieC4suC4ouC4seC4h+C5hOC4oeC5iOC5hOC4lOC5ieC4o+C4seC4muC4geC4suC4o+C4reC4meC4uOC4oeC4seC4leC4tFxuICovXG5leHBvcnQgY29uc3QgY2hlY2tGaW5hbEFwcHJvdmFsU3RhdHVzID0gYXN5bmMgKGRhdGUsIHNoaWZ0LCB3YXJkSWQsIHN1cGVydmlzb3JJZCkgPT4ge1xuICB0cnkge1xuICAgIC8vIOC4lOC4tuC4h+C4guC5ieC4reC4oeC4ueC4peC4p+C4reC4o+C5jOC4lFxuICAgIGNvbnN0IHdhcmREYXRhID0gYXdhaXQgZ2V0V2FyZERhdGFCeURhdGUoZGF0ZSwgc2hpZnQsIHdhcmRJZCk7XG4gICAgaWYgKCF3YXJkRGF0YSkgcmV0dXJuIHsgYXBwcm92ZWQ6IGZhbHNlLCBtZXNzYWdlOiAn4LmE4Lih4LmI4Lie4Lia4LiC4LmJ4Lit4Lih4Li54LilJyB9O1xuXG4gICAgLy8g4LiV4Lij4Lin4LiI4Liq4Lit4Lia4Lin4LmI4Liy4Lih4Li14LiB4Liy4Lij4Lia4Lix4LiZ4LiX4Li24LiB4LiI4Lij4Li04LiH4Lir4Lij4Li34Lit4LmE4Lih4LmIXG4gICAgaWYgKHdhcmREYXRhLnN0YXR1cyAhPT0gJ2ZpbmFsJykge1xuICAgICAgcmV0dXJuIHsgXG4gICAgICAgIGFwcHJvdmVkOiBmYWxzZSwgXG4gICAgICAgIG1lc3NhZ2U6ICfguILguYnguK3guKHguLnguKXguKLguLHguIfguYTguKHguYjguJbguLnguIHguJrguLHguJnguJfguLbguIHguYDguJvguYfguJnguInguJrguLHguJrguKrguKHguJrguLnguKPguJPguYwnIFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyDguJXguKPguKfguIjguKrguK3guJrguKPguKvguLHguKrguJzguLnguYnguK3guJnguLjguKHguLHguJXguLRcbiAgICBpZiAod2FyZERhdGEuYXBwcm92ZWRCeSAhPT0gc3VwZXJ2aXNvcklkKSB7XG4gICAgICAvLyDguJTguLbguIfguILguYnguK3guKHguLnguKXguJzguLnguYnguK3guJnguLjguKHguLHguJXguLTguIjguLLguIHguJDguLLguJnguILguYnguK3guKHguLnguKVcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGFwcHJvdmVyRGF0YSA9IGF3YWl0IGdldFVzZXJEYXRhRnJvbUNvbGxlY3Rpb24od2FyZERhdGEuYXBwcm92ZWRCeSk7XG4gICAgICAgIGNvbnN0IGFwcHJvdmVyTmFtZSA9IGFwcHJvdmVyRGF0YT8ubmFtZSB8fCAn4LmE4Lih4LmI4LiX4Lij4Liy4Lia4LiK4Li34LmI4LitJztcbiAgICAgICAgcmV0dXJuIHsgXG4gICAgICAgICAgYXBwcm92ZWQ6IGZhbHNlLCBcbiAgICAgICAgICBtZXNzYWdlOiBg4Lit4LiZ4Li44Lih4Lix4LiV4Li04LmB4Lil4LmJ4Lin4LmC4LiU4LiiICR7YXBwcm92ZXJOYW1lfWAgXG4gICAgICAgIH07XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4geyBcbiAgICAgICAgICBhcHByb3ZlZDogZmFsc2UsIFxuICAgICAgICAgIG1lc3NhZ2U6ICfguK3guJnguLjguKHguLHguJXguLTguYHguKXguYnguKfguYLguJTguKLguJzguLnguYnguYPguIrguYnguJfguYjguLLguJnguK3guLfguYjguJknIFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIOC4geC4o+C4k+C4teC4l+C4teC5iOC4reC4meC4uOC4oeC4seC4leC4tOC5geC4peC5ieC4p+C5guC4lOC4ouC4nOC4ueC5ieC5g+C4iuC5ieC4hOC4meC4m+C4seC4iOC4iOC4uOC4muC4seC4mVxuICAgIHJldHVybiB7IFxuICAgICAgYXBwcm92ZWQ6IHRydWUsIFxuICAgICAgbWVzc2FnZTogJ+C4hOC4uOC4k+C5hOC4lOC5ieC4reC4meC4uOC4oeC4seC4leC4tOC4guC5ieC4reC4oeC4ueC4peC4meC4teC5ieC5geC4peC5ieC4pycgXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjaGVja2luZyBhcHByb3ZhbCBzdGF0dXM6JywgZXJyb3IpO1xuICAgIHJldHVybiB7IFxuICAgICAgYXBwcm92ZWQ6IGZhbHNlLCBcbiAgICAgIG1lc3NhZ2U6ICfguYDguIHguLTguJTguILguYnguK3guJzguLTguJTguJ7guKXguLLguJTguYPguJnguIHguLLguKPguJXguKPguKfguIjguKrguK3guJrguKrguJbguLLguJnguLAnIFxuICAgIH07XG4gIH1cbn07XG5cbi8qKlxuICog4Lif4Lix4LiH4LiB4LmM4LiK4Lix4LiZ4Liq4Liz4Lir4Lij4Lix4Lia4LiU4Li24LiH4Lin4Lix4LiZ4LiX4Li14LmI4LiX4Li14LmI4Lih4Li14LiC4LmJ4Lit4Lih4Li54Lil4Lit4Lii4Li54LmI4LmB4Lil4LmJ4Lin4LmD4LiZ4Lij4Liw4Lia4LiaXG4gKiBAcGFyYW0ge3N0cmluZ30gd2FyZElkIOC4o+C4q+C4seC4quC4p+C4reC4o+C5jOC4lFxuICogQHJldHVybnMge1Byb21pc2U8QXJyYXk8T2JqZWN0Pj59IOC4reC4suC4o+C5jOC5gOC4o+C4ouC5jOC4guC4reC4h+C4p+C4seC4meC4l+C4teC5iOC4l+C4teC5iOC4oeC4teC4guC5ieC4reC4oeC4ueC4pVxuICovXG5leHBvcnQgY29uc3QgZmV0Y2hEYXRlc1dpdGhEYXRhID0gYXN5bmMgKHdhcmRJZCkgPT4ge1xuICB0cnkge1xuICAgIGlmICghd2FyZElkKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdmZXRjaERhdGVzV2l0aERhdGE6IE1pc3Npbmcgd2FyZElkJyk7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIFxuICAgIC8vIOC4lOC4tuC4h+C4guC5ieC4reC4oeC4ueC4peC4iOC4suC4geC4l+C4seC5ieC4hyBjb2xsZWN0aW9uIHdhcmREYXRhRmluYWwg4LmB4Lil4LiwIHdhcmREYXRhRHJhZnRzXG4gICAgLy8g4LmC4LiE4LmJ4LiU4LiI4Liz4Lil4Lit4LiH4LiB4Liy4Lij4LiU4Li24LiH4LiC4LmJ4Lit4Lih4Li54LilXG4gICAgY29uc3QgZGF0ZXMgPSBbXG4gICAgICB7IGRhdGU6ICcyMDI1LTAzLTE4Jywgc2hpZnRzOiBbJ01vcm5pbmcgKDA3OjAwLTE5OjAwKScsICdOaWdodCAoMTk6MDAtMDc6MDApJ10gfSxcbiAgICAgIHsgZGF0ZTogJzIwMjUtMDMtMTcnLCBzaGlmdHM6IFsnTW9ybmluZyAoMDc6MDAtMTk6MDApJ10gfSxcbiAgICAgIHsgZGF0ZTogJzIwMjUtMDMtMTYnLCBzaGlmdHM6IFsnTmlnaHQgKDE5OjAwLTA3OjAwKSddIH1cbiAgICBdO1xuICAgIFxuICAgIHJldHVybiBkYXRlcztcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBkYXRlcyB3aXRoIGRhdGE6JywgZXJyb3IpO1xuICAgIHJldHVybiBbXTtcbiAgfVxufTtcblxuLyoqXG4gKiDguJ/guLHguIfguIHguYzguIrguLHguJnguKrguLPguKvguKPguLHguJrguJTguLbguIfguILguYnguK3guKHguLnguKXguIHguLDguIfguLLguJnguIHguYjguK3guJnguKvguJnguYnguLJcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRlIOC4p+C4seC4meC4l+C4teC5iFxuICogQHBhcmFtIHtzdHJpbmd9IHdhcmRJZCDguKPguKvguLHguKrguKfguK3guKPguYzguJRcbiAqIEBwYXJhbSB7c3RyaW5nfSBjdXJyZW50U2hpZnQg4LiB4Liw4LiH4Liy4LiZ4Lib4Lix4LiI4LiI4Li44Lia4Lix4LiZXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3R8bnVsbD59IOC4guC5ieC4reC4oeC4ueC4peC4geC4sOC4h+C4suC4meC4geC5iOC4reC4meC4q+C4meC5ieC4siDguKvguKPguLfguK0gbnVsbCDguJbguYnguLLguYTguKHguYjguJ7guJpcbiAqL1xuZXhwb3J0IGNvbnN0IGZldGNoUHJldmlvdXNTaGlmdERhdGEgPSBhc3luYyAoZGF0ZSwgd2FyZElkLCBjdXJyZW50U2hpZnQpID0+IHtcbiAgdHJ5IHtcbiAgICBpZiAoIWRhdGUgfHwgIXdhcmRJZCB8fCAhY3VycmVudFNoaWZ0KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgXG4gICAgLy8g4LiB4Liz4Lir4LiZ4LiU4LiB4Liw4LiH4Liy4LiZ4LiB4LmI4Lit4LiZ4Lir4LiZ4LmJ4LiyXG4gICAgbGV0IHByZXZpb3VzU2hpZnQ7XG4gICAgbGV0IHByZXZpb3VzRGF0ZSA9IG5ldyBEYXRlKGRhdGUpO1xuICAgIFxuICAgIGlmIChjdXJyZW50U2hpZnQgPT09ICdNb3JuaW5nICgwNzowMC0xOTowMCknKSB7XG4gICAgICAvLyDguJbguYnguLLguYDguJvguYfguJnguIHguLDguYDguIrguYnguLIg4LmD4Lir4LmJ4LiU4Li54LiB4Liw4LiU4Li24LiB4LiC4Lit4LiH4Lin4Lix4LiZ4LiB4LmI4Lit4LiZ4Lir4LiZ4LmJ4LiyXG4gICAgICBwcmV2aW91c0RhdGUuc2V0RGF0ZShwcmV2aW91c0RhdGUuZ2V0RGF0ZSgpIC0gMSk7XG4gICAgICBwcmV2aW91c1NoaWZ0ID0gJ05pZ2h0ICgxOTowMC0wNzowMCknO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyDguJbguYnguLLguYDguJvguYfguJnguIHguLDguJTguLbguIEg4LmD4Lir4LmJ4LiU4Li54LiB4Liw4LmA4LiK4LmJ4Liy4LiC4Lit4LiH4Lin4Lix4LiZ4LmA4LiU4Li14Lii4Lin4LiB4Lix4LiZXG4gICAgICBwcmV2aW91c1NoaWZ0ID0gJ01vcm5pbmcgKDA3OjAwLTE5OjAwKSc7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGZvcm1hdHRlZFByZXZpb3VzRGF0ZSA9IGZvcm1hdChwcmV2aW91c0RhdGUsICd5eXl5LU1NLWRkJyk7XG4gICAgY29uc3QgcHJldmlvdXNEYXRhID0gYXdhaXQgZ2V0V2FyZERhdGFCeURhdGUoZm9ybWF0dGVkUHJldmlvdXNEYXRlLCBwcmV2aW91c1NoaWZ0LCB3YXJkSWQpO1xuICAgIFxuICAgIHJldHVybiBwcmV2aW91c0RhdGE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcHJldmlvdXMgc2hpZnQgZGF0YTonLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICog4Lif4Lix4LiH4LiB4LmM4LiK4Lix4LiZ4Liq4Liz4Lir4Lij4Lix4Lia4LiU4Li24LiH4LiC4LmJ4Lit4Lih4Li54Lil4LiB4Liy4Lij4Lit4LiZ4Li44Lih4Lix4LiV4Li0XG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0ZSDguKfguLHguJnguJfguLXguYhcbiAqIEBwYXJhbSB7c3RyaW5nfSB3YXJkSWQg4Lij4Lir4Lix4Liq4Lin4Lit4Lij4LmM4LiUXG4gKiBAcGFyYW0ge3N0cmluZ30gc2hpZnQg4LiB4Liw4LiH4Liy4LiZXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3R8bnVsbD59IOC4guC5ieC4reC4oeC4ueC4peC4geC4suC4o+C4reC4meC4uOC4oeC4seC4leC4tCDguKvguKPguLfguK0gbnVsbCDguJbguYnguLLguYTguKHguYjguJ7guJpcbiAqL1xuZXhwb3J0IGNvbnN0IGZldGNoQXBwcm92YWxEYXRhID0gYXN5bmMgKGRhdGUsIHdhcmRJZCwgc2hpZnQpID0+IHtcbiAgdHJ5IHtcbiAgICBpZiAoIWRhdGUgfHwgIXdhcmRJZCB8fCAhc2hpZnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBmb3JtYXR0ZWREYXRlID0gZm9ybWF0KG5ldyBEYXRlKGRhdGUpLCAneXl5eS1NTS1kZCcpO1xuICAgIGNvbnN0IHdhcmREYXRhID0gYXdhaXQgZ2V0V2FyZERhdGFCeURhdGUoZm9ybWF0dGVkRGF0ZSwgc2hpZnQsIHdhcmRJZCk7XG4gICAgXG4gICAgaWYgKCF3YXJkRGF0YSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB7XG4gICAgICBzdGF0dXM6IHdhcmREYXRhLmFwcHJvdmFsU3RhdHVzIHx8ICdwZW5kaW5nJyxcbiAgICAgIGFwcHJvdmVkQnk6IHdhcmREYXRhLmFwcHJvdmVkQnkgfHwgbnVsbCxcbiAgICAgIGFwcHJvdmFsVGltZXN0YW1wOiB3YXJkRGF0YS5hcHByb3ZhbFRpbWVzdGFtcCB8fCBudWxsLFxuICAgICAgcmVqZWN0ZWRCeTogd2FyZERhdGEucmVqZWN0ZWRCeSB8fCBudWxsLFxuICAgICAgcmVqZWN0aW9uUmVhc29uOiB3YXJkRGF0YS5yZWplY3Rpb25SZWFzb24gfHwgbnVsbCxcbiAgICAgIGNvbW1lbnRzOiB3YXJkRGF0YS5hcHByb3ZhbENvbW1lbnRzIHx8IG51bGxcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGFwcHJvdmFsIGRhdGE6JywgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIOC4n+C4seC4h+C4geC5jOC4iuC4seC4meC4quC4s+C4q+C4o+C4seC4muC4lOC4tuC4h+C4guC5ieC4reC4oeC4ueC4peC4peC5iOC4suC4quC4uOC4lFxuICogQHBhcmFtIHtzdHJpbmd9IHdhcmRJZCDguKPguKvguLHguKrguKfguK3guKPguYzguJRcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdHxudWxsPn0g4LiC4LmJ4Lit4Lih4Li54Lil4Lil4LmI4Liy4Liq4Li44LiUIOC4q+C4o+C4t+C4rSBudWxsIOC4luC5ieC4suC5hOC4oeC5iOC4nuC4mlxuICovXG5leHBvcnQgY29uc3QgZmV0Y2hMYXRlc3RSZWNvcmQgPSBhc3luYyAod2FyZElkKSA9PiB7XG4gIHRyeSB7XG4gICAgaWYgKCF3YXJkSWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBcbiAgICAvLyDguJXguKPguKfguIjguKrguK3guJrguKLguYnguK3guJnguKvguKXguLHguIfguIjguLLguIHguKfguLHguJnguJvguLHguIjguIjguLjguJrguLHguJnguYTguJvguIjguJnguJbguLbguIcgMzAg4Lin4Lix4LiZ4LiB4LmI4Lit4LiZ4Lir4LiZ4LmJ4LiyXG4gICAgY29uc3QgY3VycmVudERhdGUgPSBuZXcgRGF0ZSgpO1xuICAgIGxldCBsYXRlc3REYXRhID0gbnVsbDtcbiAgICBcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDMwOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoZWNrRGF0ZSA9IG5ldyBEYXRlKGN1cnJlbnREYXRlKTtcbiAgICAgIGNoZWNrRGF0ZS5zZXREYXRlKGNoZWNrRGF0ZS5nZXREYXRlKCkgLSBpKTtcbiAgICAgIFxuICAgICAgY29uc3QgZm9ybWF0dGVkRGF0ZSA9IGZvcm1hdChjaGVja0RhdGUsICd5eXl5LU1NLWRkJyk7XG4gICAgICBcbiAgICAgIC8vIOC4leC4o+C4p+C4iOC4quC4reC4muC4geC4sOC4lOC4tuC4geC4geC5iOC4reC4mSDguYHguKXguYnguKfguIjguLbguIfguJXguKPguKfguIjguKrguK3guJrguIHguLDguYDguIrguYnguLJcbiAgICAgIGNvbnN0IG5pZ2h0RGF0YSA9IGF3YWl0IGdldFdhcmREYXRhQnlEYXRlKGZvcm1hdHRlZERhdGUsICdOaWdodCAoMTk6MDAtMDc6MDApJywgd2FyZElkKTtcbiAgICAgIGlmIChuaWdodERhdGEpIHtcbiAgICAgICAgcmV0dXJuIG5pZ2h0RGF0YTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgbW9ybmluZ0RhdGEgPSBhd2FpdCBnZXRXYXJkRGF0YUJ5RGF0ZShmb3JtYXR0ZWREYXRlLCAnTW9ybmluZyAoMDc6MDAtMTk6MDApJywgd2FyZElkKTtcbiAgICAgIGlmIChtb3JuaW5nRGF0YSkge1xuICAgICAgICByZXR1cm4gbW9ybmluZ0RhdGE7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBudWxsO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGxhdGVzdCByZWNvcmQ6JywgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIOC4n+C4seC4h+C4geC5jOC4iuC4seC4meC4quC4s+C4q+C4o+C4seC4muC4leC4o+C4p+C4iOC4quC4reC4muC4p+C5iOC4suC4oeC4teC4guC5ieC4reC4oeC4ueC4peC5g+C4mSAzMCDguKfguLHguJnguKXguYjguLLguKrguLjguJTguKvguKPguLfguK3guYTguKHguYhcbiAqIEBwYXJhbSB7c3RyaW5nfSB3YXJkSWQg4Lij4Lir4Lix4Liq4Lin4Lit4Lij4LmM4LiUXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn0gdHJ1ZSDguJbguYnguLLguKHguLXguILguYnguK3guKHguLnguKXguYPguJkgMzAg4Lin4Lix4LiZ4Lil4LmI4Liy4Liq4Li44LiULCBmYWxzZSDguJbguYnguLLguYTguKHguYjguKHguLVcbiAqL1xuZXhwb3J0IGNvbnN0IGNoZWNrUGFzdDMwRGF5c1JlY29yZHMgPSBhc3luYyAod2FyZElkKSA9PiB7XG4gIHRyeSB7XG4gICAgaWYgKCF3YXJkSWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgbGF0ZXN0UmVjb3JkID0gYXdhaXQgZmV0Y2hMYXRlc3RSZWNvcmQod2FyZElkKTtcbiAgICByZXR1cm4gbGF0ZXN0UmVjb3JkICE9PSBudWxsO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNoZWNraW5nIHBhc3QgMzAgZGF5cyByZWNvcmRzOicsIGVycm9yKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbi8qKlxuICog4Lif4Lix4LiH4LiB4LmM4LiK4Lix4LiZ4Liq4Liz4Lir4Lij4Lix4Lia4LiU4Li24LiH4LiC4LmJ4Lit4Lih4Li54Lil4Lii4LmJ4Lit4LiZ4Lir4Lil4Lix4LiHIFgg4Lin4Lix4LiZXG4gKi9cbmV4cG9ydCBjb25zdCBmZXRjaFByZXZpb3VzV2FyZERhdGEgPSBhc3luYyAoZGVwYXJ0bWVudCwgY3VycmVudERhdGUsIGRheXMgPSA3KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5sb2coYEdldHRpbmcgcHJldmlvdXMgJHtkYXlzfSBkYXlzIGRhdGEgZm9yICR7ZGVwYXJ0bWVudH0gZnJvbSAke2N1cnJlbnREYXRlfWApO1xuICAgICAgICAvLyDguYLguITguYnguJTguJTguLbguIfguILguYnguK3guKHguLnguKXguKLguYnguK3guJnguKvguKXguLHguIcuLi5cbiAgICAgICAgLy8gKOC4hOC4seC4lOC4peC4reC4geC4iOC4suC4gSBXYXJkRm9ybS5qcyDguYPguKrguYjguJXguKPguIfguJnguLXguYkpXG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHByZXZpb3VzIGRhdGE6JywgZXJyb3IpO1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxufTtcblxuLyoqXG4gKiDguYHguJvguKXguIfguKPguLnguJvguYHguJrguJrguKfguLHguJnguJfguLXguYhcbiAqL1xuZXhwb3J0IGNvbnN0IGZvcm1hdERhdGUgPSAoZGF0ZSkgPT4ge1xuICAgIGlmICghZGF0ZSkgcmV0dXJuICcnO1xuICAgIFxuICAgIGNvbnN0IGQgPSBuZXcgRGF0ZShkYXRlKTtcbiAgICBpZiAoaXNOYU4oZC5nZXRUaW1lKCkpKSByZXR1cm4gJyc7XG4gICAgXG4gICAgcmV0dXJuIGZvcm1hdChkLCAneXl5eS1NTS1kZCcpO1xufTtcblxuLyoqXG4gKiDguJ/guLHguIfguIHguYzguIrguLHguJnguKrguLPguKvguKPguLHguJrguJTguLbguIfguILguYnguK3guKHguLnguKXguYHguKXguLDguIjguLHguJTguIHguLLguKPguIHguLLguKPguYLguKvguKXguJTguILguYnguK3guKHguLnguKXguK3guLHguJXguYLguJnguKHguLHguJXguLTguJXguLLguKHguIHguLBcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRlIOC4p+C4seC4meC4l+C4teC5iFxuICogQHBhcmFtIHtzdHJpbmd9IHdhcmRJZCDguKPguKvguLHguKrguKfguK3guKPguYzguJRcbiAqIEBwYXJhbSB7c3RyaW5nfSBzaGlmdCDguIHguLDguIfguLLguJlcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IOC4guC5ieC4reC4oeC4ueC4peC4l+C4teC5iOC5guC4q+C4peC4lCDguJ7guKPguYnguK3guKHguKrguJbguLLguJnguLBcbiAqL1xuZXhwb3J0IGNvbnN0IGZldGNoQW5kUHJlcGFyZVdhcmREYXRhID0gYXN5bmMgKGRhdGUsIHdhcmRJZCwgc2hpZnQpID0+IHtcbiAgICB0cnkge1xuICAgICAgICBjb25zb2xlLmxvZyhgRmV0Y2hpbmcgYW5kIHByZXBhcmluZyBkYXRhIGZvciAke2RhdGV9LCAke3dhcmRJZH0sICR7c2hpZnR9YCk7XG4gICAgICAgIFxuICAgICAgICAvLyDguJTguLbguIfguILguYnguK3guKHguLnguKXguILguK3guIfguIHguLDguJvguLHguIjguIjguLjguJrguLHguJlcbiAgICAgICAgY29uc3Qgd2FyZERhdGEgPSBhd2FpdCBmZXRjaFdhcmREYXRhKGRhdGUsIHdhcmRJZCwgc2hpZnQpO1xuICAgICAgICBsZXQgcGF0aWVudENlbnN1c1RvdGFsID0gMDtcbiAgICAgICAgbGV0IHNvdXJjZU1lc3NhZ2UgPSAnJztcbiAgICAgICAgXG4gICAgICAgIC8vIOC4leC4o+C4p+C4iOC4quC4reC4muC4p+C5iOC4suC4oeC4teC4guC5ieC4reC4oeC4ueC4peC4q+C4o+C4t+C4reC5hOC4oeC5iFxuICAgICAgICBpZiAod2FyZERhdGEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGb3VuZCBleGlzdGluZyBkYXRhIGZvciB0aGlzIHNoaWZ0Jyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIOC4hOC4s+C4meC4p+C4kyBQYXRpZW50IENlbnN1cyDguJbguYnguLLguKHguLXguILguYnguK3guKHguLnguKVcbiAgICAgICAgICAgIGlmICh3YXJkRGF0YS5wYXRpZW50Q2Vuc3VzKSB7XG4gICAgICAgICAgICAgICAgcGF0aWVudENlbnN1c1RvdGFsID0gY2FsY3VsYXRlUGF0aWVudENlbnN1cyh3YXJkRGF0YS5wYXRpZW50Q2Vuc3VzKTtcbiAgICAgICAgICAgICAgICBzb3VyY2VNZXNzYWdlID0gJ+C4guC5ieC4reC4oeC4ueC4peC4nOC4ueC5ieC4m+C5iOC4p+C4ouC4hOC4s+C4meC4p+C4k+C4iOC4suC4geC4guC5ieC4reC4oeC4ueC4peC5g+C4meC4o+C4sOC4muC4mic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0YTogd2FyZERhdGEsXG4gICAgICAgICAgICAgICAgaGFzRGF0YTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBwYXRpZW50Q2Vuc3VzVG90YWwsXG4gICAgICAgICAgICAgICAgc291cmNlTWVzc2FnZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8g4LiW4LmJ4Liy4LmE4Lih4LmI4Lih4Li14LiC4LmJ4Lit4Lih4Li54LilIOC4iOC4sOC4lOC4tuC4h+C4guC5ieC4reC4oeC4ueC4peC4leC4suC4oeC4geC4juC4l+C4teC5iOC4geC4s+C4q+C4meC4lFxuICAgICAgICBpZiAoc2hpZnQgPT09ICdNb3JuaW5nICgwNzowMC0xOTowMCknKSB7XG4gICAgICAgICAgICAvLyDguIHguKPguJPguLXguIHguLDguYDguIrguYnguLI6IOC4lOC4tuC4h+C4guC5ieC4reC4oeC4ueC4peC4ouC5ieC4reC4meC4q+C4peC4seC4hyA3IOC4p+C4seC4mVxuICAgICAgICAgICAgY29uc3QgcHJldmlvdXNEYXRlID0gbmV3IERhdGUoZGF0ZSk7XG4gICAgICAgICAgICBwcmV2aW91c0RhdGUuc2V0RGF0ZShwcmV2aW91c0RhdGUuZ2V0RGF0ZSgpIC0gNyk7XG4gICAgICAgICAgICBjb25zdCBmb3JtYXR0ZWRQcmV2aW91c0RhdGUgPSBmb3JtYXQocHJldmlvdXNEYXRlLCAneXl5eS1NTS1kZCcpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnTm8gZGF0YSBmb3VuZCBmb3IgbW9ybmluZyBzaGlmdCwgY2hlY2tpbmcgZGF0YSBmcm9tIDcgZGF5cyBhZ286JywgZm9ybWF0dGVkUHJldmlvdXNEYXRlKTtcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzRGF0YSA9IGF3YWl0IGZldGNoV2FyZERhdGEoZm9ybWF0dGVkUHJldmlvdXNEYXRlLCB3YXJkSWQsIHNoaWZ0KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHByZXZpb3VzRGF0YSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGb3VuZCBwcmV2aW91cyBkYXRhIGZyb20gNyBkYXlzIGFnbycpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIOC4hOC4s+C4meC4p+C4kyBQYXRpZW50IENlbnN1cyDguJbguYnguLLguKHguLXguILguYnguK3guKHguLnguKVcbiAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNEYXRhLnBhdGllbnRDZW5zdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aWVudENlbnN1c1RvdGFsID0gY2FsY3VsYXRlUGF0aWVudENlbnN1cyhwcmV2aW91c0RhdGEucGF0aWVudENlbnN1cyk7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZU1lc3NhZ2UgPSAn4LiC4LmJ4Lit4Lih4Li54Lil4Lic4Li54LmJ4Lib4LmI4Lin4Lii4LiE4Liz4LiZ4Lin4LiT4LiI4Liy4LiB4LiC4LmJ4Lit4Lih4Li54LilIDcg4Lin4Lix4LiZ4LiB4LmI4Lit4LiZJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8g4Liq4Lij4LmJ4Liy4LiH4LiC4LmJ4Lit4Lih4Li54Lil4LmD4Lir4Lih4LmI4LmC4LiU4Lii4LmD4LiK4LmJ4LiC4LmJ4Lit4Lih4Li54Lil4LmA4LiU4Li04Lih4LmB4LiV4LmI4LmE4Lih4LmI4LmA4Lit4LiyIElEIOC5geC4peC4sOC4guC5ieC4reC4oeC4ueC4peC5gOC4ieC4nuC4suC4sOC4reC4t+C5iOC4meC5hlxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0RhdGEgPSB7IC4uLnByZXZpb3VzRGF0YSB9O1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBuZXdEYXRhLmlkO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBuZXdEYXRhLnRpbWVzdGFtcDtcbiAgICAgICAgICAgICAgICBkZWxldGUgbmV3RGF0YS5jcmVhdGVkQXQ7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG5ld0RhdGEudXBkYXRlZEF0O1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBuZXdEYXRhLmFwcHJvdmFsU3RhdHVzO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBuZXdEYXRhLmFwcHJvdmVkQnk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG5ld0RhdGEuYXBwcm92YWxUaW1lc3RhbXA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8g4Lit4Lix4Lib4LmA4LiU4LiV4LiE4LmI4LiyIFBhdGllbnQgQ2Vuc3VzXG4gICAgICAgICAgICAgICAgaWYgKG5ld0RhdGEucGF0aWVudENlbnN1cykge1xuICAgICAgICAgICAgICAgICAgICBuZXdEYXRhLnBhdGllbnRDZW5zdXMudG90YWwgPSBwYXRpZW50Q2Vuc3VzVG90YWwudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogbmV3RGF0YSxcbiAgICAgICAgICAgICAgICAgICAgaGFzRGF0YTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aWVudENlbnN1c1RvdGFsLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2VNZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICBpc0F1dG9GaWxsZWRGcm9tSGlzdG9yeTogdHJ1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc2hpZnQgPT09ICdOaWdodCAoMTk6MDAtMDc6MDApJykge1xuICAgICAgICAgICAgLy8g4LiB4Lij4LiT4Li14LiB4Liw4LiU4Li24LiBOiDguJTguLbguIfguILguYnguK3guKHguLnguKXguIjguLLguIHguIHguLDguYDguIrguYnguLLguILguK3guIfguKfguLHguJnguYDguJTguLXguKLguKfguIHguLHguJlcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdObyBkYXRhIGZvdW5kIGZvciBuaWdodCBzaGlmdCwgY2hlY2tpbmcgbW9ybmluZyBzaGlmdCBmcm9tIHNhbWUgZGF5Jyk7XG4gICAgICAgICAgICBjb25zdCBtb3JuaW5nRGF0YSA9IGF3YWl0IGZldGNoV2FyZERhdGEoZGF0ZSwgd2FyZElkLCAnTW9ybmluZyAoMDc6MDAtMTk6MDApJyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChtb3JuaW5nRGF0YSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGb3VuZCBtb3JuaW5nIHNoaWZ0IGRhdGEgZnJvbSBzYW1lIGRheScpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIOC4hOC4s+C4meC4p+C4kyBQYXRpZW50IENlbnN1cyDguJbguYnguLLguKHguLXguILguYnguK3guKHguLnguKVcbiAgICAgICAgICAgICAgICBpZiAobW9ybmluZ0RhdGEucGF0aWVudENlbnN1cykge1xuICAgICAgICAgICAgICAgICAgICBwYXRpZW50Q2Vuc3VzVG90YWwgPSBjYWxjdWxhdGVQYXRpZW50Q2Vuc3VzKG1vcm5pbmdEYXRhLnBhdGllbnRDZW5zdXMpO1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2VNZXNzYWdlID0gJ+C4guC5ieC4reC4oeC4ueC4peC4nOC4ueC5ieC4m+C5iOC4p+C4ouC4hOC4s+C4meC4p+C4k+C4iOC4suC4geC4guC5ieC4reC4oeC4ueC4peC4geC4sOC5gOC4iuC5ieC4sic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIOC4quC4o+C5ieC4suC4h+C4guC5ieC4reC4oeC4ueC4peC5g+C4q+C4oeC5iOC5guC4lOC4ouC5g+C4iuC5ieC4guC5ieC4reC4oeC4ueC4peC4iOC4suC4geC4geC4sOC5gOC4iuC5ieC4slxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0RhdGEgPSB7IC4uLm1vcm5pbmdEYXRhIH07XG4gICAgICAgICAgICAgICAgZGVsZXRlIG5ld0RhdGEuaWQ7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG5ld0RhdGEudGltZXN0YW1wO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBuZXdEYXRhLmNyZWF0ZWRBdDtcbiAgICAgICAgICAgICAgICBkZWxldGUgbmV3RGF0YS51cGRhdGVkQXQ7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG5ld0RhdGEuYXBwcm92YWxTdGF0dXM7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG5ld0RhdGEuYXBwcm92ZWRCeTtcbiAgICAgICAgICAgICAgICBkZWxldGUgbmV3RGF0YS5hcHByb3ZhbFRpbWVzdGFtcDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyDguK3guLHguJvguYDguJTguJXguITguYjguLIgUGF0aWVudCBDZW5zdXMg4LmB4Lil4LiwIE92ZXJhbGwgRGF0YSAo4Liq4Liz4Lir4Lij4Lix4Lia4LiB4Liw4LiU4Li24LiBKVxuICAgICAgICAgICAgICAgIGlmIChuZXdEYXRhLnBhdGllbnRDZW5zdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3RGF0YS5wYXRpZW50Q2Vuc3VzLnRvdGFsID0gcGF0aWVudENlbnN1c1RvdGFsLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5ld0RhdGEub3ZlcmFsbERhdGEgPSBwYXRpZW50Q2Vuc3VzVG90YWwudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBuZXdEYXRhLFxuICAgICAgICAgICAgICAgICAgICBoYXNEYXRhOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBwYXRpZW50Q2Vuc3VzVG90YWwsXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZU1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIGlzQXV0b0ZpbGxlZEZyb21IaXN0b3J5OiB0cnVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8g4LiW4LmJ4Liy4LmE4Lih4LmI4Lih4Li14LiC4LmJ4Lit4Lih4Li54Lil4LmD4LiU4LmGIOC5g+C4q+C5ieC4quC4o+C5ieC4suC4h+C4guC5ieC4reC4oeC4ueC4peC5gOC4m+C4peC5iOC4slxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgIGhhc0RhdGE6IGZhbHNlLFxuICAgICAgICAgICAgcGF0aWVudENlbnN1c1RvdGFsOiAwLFxuICAgICAgICAgICAgc291cmNlTWVzc2FnZTogJ+C5hOC4oeC5iOC4nuC4muC4guC5ieC4reC4oeC4ueC4peC4geC5iOC4reC4meC4q+C4meC5ieC4sidcbiAgICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBhbmQgcHJlcGFyaW5nIHdhcmQgZGF0YTonLCBlcnJvcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgaGFzRGF0YTogZmFsc2UsXG4gICAgICAgICAgICBwYXRpZW50Q2Vuc3VzVG90YWw6IDAsXG4gICAgICAgICAgICBzb3VyY2VNZXNzYWdlOiAn4LmA4LiB4Li04LiU4LiC4LmJ4Lit4Lic4Li04LiU4Lie4Lil4Liy4LiU4LmD4LiZ4LiB4Liy4Lij4LmC4Lir4Lil4LiU4LiC4LmJ4Lit4Lih4Li54LilJyxcbiAgICAgICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlXG4gICAgICAgIH07XG4gICAgfVxufTsiXSwibmFtZXMiOlsiZ2V0VXNlckRhdGFGcm9tQ29sbGVjdGlvbiIsImdldFdhcmREYXRhQnlEYXRlIiwiY2hlY2tMYXN0N0RheXNEYXRhIiwiZ2V0U3ViY29sbGVjdGlvbiIsImdldERvY3VtZW50QnlJZCIsImZvcm1hdCIsImRiIiwiY29sbGVjdGlvbiIsInF1ZXJ5Iiwid2hlcmUiLCJnZXREb2NzIiwiZG9jIiwiZ2V0RG9jIiwib3JkZXJCeSIsImxpbWl0IiwiY2hlY2tBcHByb3ZhbFN0YXR1cyIsImRhdGUiLCJzaGlmdCIsIndhcmRJZCIsImZvcm1hdHRlZERhdGUiLCJEYXRlIiwid2FyZERhdGEiLCJzdGF0dXMiLCJtZXNzYWdlIiwiYXBwcm92YWxTdGF0dXMiLCJ0aW1lc3RhbXAiLCJhcHByb3ZhbFRpbWVzdGFtcCIsImFwcHJvdmVkQnkiLCJyZWplY3RlZEJ5IiwicmVqZWN0aW9uUmVhc29uIiwiZXJyb3IiLCJjb25zb2xlIiwiZmV0Y2hXYXJkRGF0YSIsImxvZyIsImRvY0lkIiwiZG9jUmVmIiwiZG9jU25hcCIsImV4aXN0cyIsImRhdGEiLCJkcmFmdHNSZWYiLCJkcmFmdHNRdWVyeSIsImRyYWZ0c1NuYXAiLCJlbXB0eSIsImRyYWZ0cyIsImZvckVhY2giLCJwdXNoIiwiaWQiLCJzb3J0IiwiYSIsImIiLCJjaGVja01vcm5pbmdTaGlmdERhdGFFeGlzdHMiLCJtb3JuaW5nRGF0YSIsImZldGNoTGFzdDdEYXlzRGF0YSIsImN1cnJlbnREYXRlIiwiZGF0ZXMiLCJpIiwic2V0RGF0ZSIsImdldERhdGUiLCJwcm9taXNlcyIsIm1hcCIsInJlc3VsdHMiLCJQcm9taXNlIiwiYWxsIiwidmFsaWREYXRhIiwiZmlsdGVyIiwibGVuZ3RoIiwiY2FsY3VsYXRlUGF0aWVudENlbnN1cyIsInBhdGllbnREYXRhIiwid2FybiIsImhvc3BpdGFsUGF0aWVudGNlbnN1cyIsIk51bWJlciIsInBhcnNlSW50IiwibmV3QWRtaXQiLCJ0cmFuc2ZlckluIiwicmVmZXJJbiIsInRyYW5zZmVyT3V0IiwicmVmZXJPdXQiLCJkaXNjaGFyZ2UiLCJkZWFkIiwidG90YWwiLCJzaG91bGRTaG93RW1wdHkiLCJjaGVja0ZpbmFsQXBwcm92YWxTdGF0dXMiLCJzdXBlcnZpc29ySWQiLCJhcHByb3ZlZCIsImFwcHJvdmVyRGF0YSIsImFwcHJvdmVyTmFtZSIsIm5hbWUiLCJmZXRjaERhdGVzV2l0aERhdGEiLCJzaGlmdHMiLCJmZXRjaFByZXZpb3VzU2hpZnREYXRhIiwiY3VycmVudFNoaWZ0IiwicHJldmlvdXNTaGlmdCIsInByZXZpb3VzRGF0ZSIsImZvcm1hdHRlZFByZXZpb3VzRGF0ZSIsInByZXZpb3VzRGF0YSIsImZldGNoQXBwcm92YWxEYXRhIiwiY29tbWVudHMiLCJhcHByb3ZhbENvbW1lbnRzIiwiZmV0Y2hMYXRlc3RSZWNvcmQiLCJsYXRlc3REYXRhIiwiY2hlY2tEYXRlIiwibmlnaHREYXRhIiwiY2hlY2tQYXN0MzBEYXlzUmVjb3JkcyIsImxhdGVzdFJlY29yZCIsImZldGNoUHJldmlvdXNXYXJkRGF0YSIsImRlcGFydG1lbnQiLCJkYXlzIiwiZm9ybWF0RGF0ZSIsImQiLCJpc05hTiIsImdldFRpbWUiLCJmZXRjaEFuZFByZXBhcmVXYXJkRGF0YSIsInBhdGllbnRDZW5zdXNUb3RhbCIsInNvdXJjZU1lc3NhZ2UiLCJwYXRpZW50Q2Vuc3VzIiwiaGFzRGF0YSIsIm5ld0RhdGEiLCJjcmVhdGVkQXQiLCJ1cGRhdGVkQXQiLCJ0b1N0cmluZyIsImlzQXV0b0ZpbGxlZEZyb21IaXN0b3J5Iiwib3ZlcmFsbERhdGEiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/components/forms/WardForm/DataFetchers.js\n"));

/***/ })

});